<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuxiaoKun</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LiuZiQiao.github.io/"/>
  <updated>2019-02-07T15:33:09.422Z</updated>
  <id>https://LiuZiQiao.github.io/</id>
  
  <author>
    <name>LiuXiaoKun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树的子结构</title>
    <link href="https://LiuZiQiao.github.io/2019/02/07/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>https://LiuZiQiao.github.io/2019/02/07/树的子结构/</id>
    <published>2019-02-07T15:32:17.000Z</published>
    <updated>2019-02-07T15:33:09.422Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = isSubtree(pRoot1,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>说说网络之名词解析</title>
    <link href="https://LiuZiQiao.github.io/2019/02/02/%E8%AF%B4%E8%AF%B4%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%90%8D%E8%AF%8D%E8%A7%A3%E6%9E%90/"/>
    <id>https://LiuZiQiao.github.io/2019/02/02/说说网络之名词解析/</id>
    <published>2019-02-02T14:49:29.000Z</published>
    <updated>2019-02-02T14:50:54.238Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>学习一些网络之后，发现存在对一些名词的含义还是记不住，因此作此文章来梳理网络中的一些关键名词。</p><h3 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a>网络名词术语解析</h3><h4 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a>路由(route)</h4><p>路由（名词）<br>数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。<br>路由（动词）<br>某个路由节点为数据包选择投递方向的选路过程。</p><h4 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h4><p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。   </p><p>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。   </p><p>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。   </p><p>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。   </p><p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</p><h3 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h3><p>路由表中的一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。</p><h3 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h3><p>路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。</p><h3 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a>路由节点</h3><p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p><h3 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。<br>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p><h3 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a>hub工作原理</h3><p>集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。<br>集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。其次是Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。<br>由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作：   </p><ul><li>第一步是将信息上传到上联设备；</li><li>第二步是上联设备再将该信息广播到所有端口上。<h3 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a>半双工/全双工</h3>Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。<br>Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3>DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。<br>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。<h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h3>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。</li></ul><ol><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</li><li>通信延迟时间短，可靠性较高</li><li>局域网可以支持多种传输介质<h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h3>wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。<br>覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。<br>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</li><li>适应大容量与突发性通信的要求；</li><li>适应综合业务服务的要求；</li><li>开放的设备接口与规范化的协议；</li><li>完善的通信服务与网络管理。<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3>逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li><li>端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。</li><li>客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</li><li>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。<br>我们应该在自定义端口时，避免使用well-known的端口。如：80、21等等。</li></ol><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU）<br>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。    </p><p>以下是一些协议的MTU：<br>FDDI协议：4352字节<br>以太网（Ethernet）协议：1500字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up/Modem）：576字节<br>Point-to-Point：4470字节   </p><h3 id="网络知识点的一些常见题"><a href="#网络知识点的一些常见题" class="headerlink" title="网络知识点的一些常见题"></a>网络知识点的一些常见题</h3><ol><li>TCP如何建立链接</li><li>TCP如何通信</li><li>TCP如何关闭链接</li><li>什么是滑动窗口</li><li>什么是半关闭</li><li>局域网内两台机器如何利用TCP/IP通信</li><li>internet上两台主机如何进行通信</li><li>如何在internet上识别唯一一个进程<br>答：通过“IP地址+端口号”来区分不同的服务</li><li>为什么说TCP是可靠的链接，UDP不可靠</li><li>路由器和交换机的区别</li><li>点到点，端到端</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;学习一些网络之后，发现存在对一些名词的含义还是记不住，因此作此文章来梳理网络中的一些关键名词。&lt;/p&gt;
&lt;h3 id=&quot;网络名词术语解析&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>再浅谈网络之“TCP协议”</title>
    <link href="https://LiuZiQiao.github.io/2019/01/31/%E5%86%8D%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9CTCP%E5%8D%8F%E8%AE%AE%E2%80%9D/"/>
    <id>https://LiuZiQiao.github.io/2019/01/31/再浅谈网络之“TCP协议”/</id>
    <published>2019-01-31T14:39:29.000Z</published>
    <updated>2019-02-02T11:47:44.528Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。<br><img src="https://img-blog.csdnimg.cn/20190202193733165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1">   </p><p>首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。   </p><h3 id="建立连接（三次握手）的过程："><a href="#建立连接（三次握手）的过程：" class="headerlink" title="建立连接（三次握手）的过程："></a>建立连接（三次握手）的过程：</h3><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。   </li><li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。   </li><li>客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为==三方握手（three-way-handshake）==。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</li></ol><h4 id="数据传输的过程："><a href="#数据传输的过程：" class="headerlink" title="数据传输的过程："></a>数据传输的过程：</h4><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据。</li><li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</li></ol><h3 id="关闭连接（四次挥手）的过程："><a href="#关闭连接（四次挥手）的过程：" class="headerlink" title="关闭连接（四次挥手）的过程："></a>关闭连接（四次挥手）的过程：</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端发出段7，FIN位表示关闭连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求。</li><li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</li><li>客户端发出段10，应答服务器的关闭连接请求。<br>建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</li></ol><h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口 (TCP流量控制)"></a>滑动窗口 (TCP流量控制)</h3><p>UDP传输的时候描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过<code>滑动窗口（Sliding Window)</code>机制解决这一问题。看下图的通讯过程：<br><img src="https://img-blog.csdnimg.cn/20190202193849279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ol><li>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li><li>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li><li>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</li><li>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li><li>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</li><li>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</li><li>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li><li>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</li><li>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。<br>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。<br>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。<h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3></li></ol><p><img src="https://img-blog.csdnimg.cn/20190202194033294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"><br><strong>CLOSED</strong>：表示初始状态。<br><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。<br><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。<br><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。<br><strong>ESTABLISHED</strong>：表示连接已经建立。<br><strong>FIN_WAIT_1</strong>:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：<br>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。<br>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。<br><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。<br><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。<br><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。<br><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure></p><p>使用close中止一个连接，它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。<br>shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 </li><li>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信，如果一个进程close(sfd)将不会影响到其它进程。</li></ol><h4 id="2MSL-Maximum-Segment-Lifetime"><a href="#2MSL-Maximum-Segment-Lifetime" class="headerlink" title="2MSL(Maximum Segment Lifetime)"></a>2MSL(Maximum Segment Lifetime)</h4><p> TIME_WAIT状态的存在有两个理由：   </p><ul><li>让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。   </li><li>防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</li></ul><h4 id="程序设计中出现的问题"><a href="#程序设计中出现的问题" class="headerlink" title="程序设计中出现的问题"></a>程序设计中出现的问题</h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure></p><p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">1</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       CLOSE_WAIT  <span class="number">3525</span>/client     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      FIN_WAIT2   -</span><br></pre></td></tr></table></figure><p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。<br>现在用Ctrl-C把client也终止掉，再观察现象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38104</span>      TIME_WAIT   -</span><br><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。==TCP协议规定==，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。<br>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。</p><h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:8888）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:8888），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。<br>在server代码的socket()和bind()调用之间插入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a>TCP异常断开</h3><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。<br><strong>Heart-Beat线程:</strong><br>这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。<br>该方法的==好处是通用==，但缺点就是==会改变现有的通讯协议==！大家一般都是使用业务层心跳来处理，主要是灵活可控。<br>UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p><h4 id="设置TCP属性"><a href="#设置TCP属性" class="headerlink" title="设置TCP属性"></a>设置TCP属性</h4><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持==存活探测分节==(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。&lt;br&gt;&lt;img src=&quot;https://img-b
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>再谈网络之“协议格式”</title>
    <link href="https://LiuZiQiao.github.io/2019/01/30/%E5%86%8D%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9C%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E2%80%9D/"/>
    <id>https://LiuZiQiao.github.io/2019/01/30/再谈网络之“协议格式”/</id>
    <published>2019-01-30T13:27:30.000Z</published>
    <updated>2019-01-30T13:28:02.614Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上一篇中是有关网络的设计模式和分层模型，这篇就来说说网络里面用到的几个重要协议的格式，用程序员来的话来说就是报头格式。当然，在进入主题之前，先了解下通信的过程。</p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p><strong>两台计算机通过TCP/IP协议通讯的过程如下所示：</strong><br><img src="https://img-blog.csdnimg.cn/2019013021170727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</strong><br><img src="https://img-blog.csdnimg.cn/20190130211750435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ul><li>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。   </li><li>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。   </li><li>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。   </li><li>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说 的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。   </li><li>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。   </li><li>那么目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211851391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></li><li>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</li><li>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</li></ul><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><h3 id="数据表封装"><a href="#数据表封装" class="headerlink" title="数据表封装"></a>数据表封装</h3><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（也就是我们常说的socket编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211956396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网的帧格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212040538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"></p><p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，<code>HWaddr 00:15:F2:14:9E:3F</code>部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行<code>分片</code>（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p><p><strong>上面说到的分片？为什么要分片？如何分片？</strong></p><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须==获得目的主机的硬件地址==。==ARP协议就起到这个作用==。例如：源主机发出ARP请求，询问“IP地址是<code>192.168.0.1</code>的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。<br>每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。<br><strong>为什么表项要有过期时间而不是一直有效？</strong></p><p>ARP数据报的格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212121578.png" alt="6"></p><p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为==1表示ARP请求==，op字段为==2表示ARP应答==。</p><p><strong>源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</strong></p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212157821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="6"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p><p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212215315.png" alt="8"></p><p>UDP首部：源端口号是客户端的端口号，目的端口号是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</p><h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212243418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="9"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小等。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，关于SYN、ACK、FIN、RST四个位，会在后面的文章里详细解释，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。</p><p>以上为网络协议的格式介绍，协议相关的具体内容将在后面的文章里介绍。欢迎大家关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;上一篇中是有关网络的设计模式和分层模型，这篇就来说说网络里面用到的几个重要协议的格式，用程序员来的话来说就是报头格式。当然，在进入主题之前
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>谈谈网络之设计模式与分层模型</title>
    <link href="https://LiuZiQiao.github.io/2019/01/30/%E8%B0%88%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://LiuZiQiao.github.io/2019/01/30/谈谈网络之设计模式与分层模型/</id>
    <published>2019-01-30T05:18:09.000Z</published>
    <updated>2019-01-30T05:18:36.214Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型</p><h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p><strong>优缺点：</strong> 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<code>提高数据传输效率。</code>且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所<code>采用的协议相对灵活。</code>可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。<br>    因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br>    C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。<code>工作量</code>将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<code>安全性</code>构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>    B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其<code>工作开发量较小</code>。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br>    B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<code>缓存数据不尽如人意</code>，从而<code>传输数据量受到限制</code>。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，<code>协议选择不灵活</code>。<br>    因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="https://img-blog.csdnimg.cn/20190130131007694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li><li>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li><li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li></ol><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190130131054219.png" alt="2"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。但也有一些自定义协议类型，只是在其之上进行一些修改完成需求功能即可的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型&lt;/p&gt;
&lt;h3 id=&quot;网络应用程序设计模式&quot;&gt;&lt;a href=&quot;#网络
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/二叉搜索树的第k个结点/</id>
    <published>2019-01-24T15:04:05.000Z</published>
    <updated>2019-01-24T15:05:40.441Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = KthNode(pRoot-&gt;left,k);</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            index++;  </span><br><span class="line">            <span class="keyword">if</span>(index == k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot-&gt;right,k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>“三次握手，四次挥手”你真的懂吗？</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/“三次握手，四次挥手”你真的懂吗？/</id>
    <published>2019-01-24T04:30:19.000Z</published>
    <updated>2019-01-24T04:31:02.327Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是”三次握手，四次挥手“"><a href="#什么是”三次握手，四次挥手“" class="headerlink" title="什么是”三次握手，四次挥手“"></a>什么是”三次握手，四次挥手“</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用3次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p><img src="https://img-blog.csdnimg.cn/20190124115039196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>三次握手和四次挥手的状态转换如下图<br><img src="https://img-blog.csdnimg.cn/20190124115225958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h4 id="“三次握手，四次挥手”是怎么完成的？"><a href="#“三次握手，四次挥手”是怎么完成的？" class="headerlink" title="“三次握手，四次挥手”是怎么完成的？"></a>“三次握手，四次挥手”是怎么完成的？</h4><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。<br><img src="https://img-blog.csdnimg.cn/20190124115513655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p><h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://img-blog.csdnimg.cn/20190124115650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p></li><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p></li></ol><h4 id="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h3 id="”三次握手，四次挥手“进阶"><a href="#”三次握手，四次挥手“进阶" class="headerlink" title="”三次握手，四次挥手“进阶"></a>”三次握手，四次挥手“进阶</h3><h4 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p><p>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h4 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h4><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h5 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h5><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h5 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h5><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h5><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。<br><img src="https://img-blog.csdnimg.cn/20190124122642462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"><br>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><p>查看是否有连接溢出 <code>netstat -s | grep LISTEN</code></p><h5 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h5><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><h5 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h5><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><code>netstat -s</code>命令</p><p>[root@server ~]# netstat -s | grep “listen|LISTEN” </p><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><p>[root@server ~]# netstat -s | grep TCPBacklogDrop </p><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><p>[root@server ~]# ss -lnt</p><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;什么是”三次握手，四次挥手“&quot;&gt;&lt;a href=&quot;#什么是”三次握手，四次挥手“&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="TCP" scheme="https://LiuZiQiao.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装更新git的正确打开方式</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0git%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7安装更新git的正确打开方式/</id>
    <published>2019-01-03T08:52:12.000Z</published>
    <updated>2019-01-03T08:54:13.402Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">1</a></p><p>安装centos7 之后一直用自带的git，在提交的时候总是出现下面这种情况，原因是git版本太低导致的，于是就想了办法去更新git，<br>百度看了很多教程，都是什么先卸载再重新安装，卸载之前还需要备份一份配置文件，看了很多感觉非常麻烦，于是就在Linux网站中看到了一个最正确的更新及安装方式。以下是记录我更新安装过程。</p><h3 id="配置存储库"><a href="#配置存储库" class="headerlink" title="配置存储库"></a>配置存储库</h3><p>在这之前，我们需要在root权限下才可以进一步操作。<br>1.启用Wandisco GIT存储库<br>启用存储库需要在/etc/yum.repos.d/目录中命名的新yum存储库配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/wandisco-git.repo</span><br></pre></td></tr></table></figure></p><p>添加以下字段，ESC，然后:输入wq保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><p>使用以下命名了导入存储库GPG密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>完成之后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p><p>输出<code>git version 2.18.0</code></p><h3 id="验证配置文件更改"><a href="#验证配置文件更改" class="headerlink" title="验证配置文件更改"></a>验证配置文件更改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Your Name</span><br><span class="line">user.email=youremail@yourdomain.com</span><br></pre></td></tr></table></figure></p><p>配置设置存储在~/.gitconfig文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = youremail@yourdomain.com</span><br></pre></td></tr></table></figure><p>要进一步更改Git配置，可以使用git config命令或~/.gitconfig手动编辑文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-proc
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="git centos" scheme="https://LiuZiQiao.github.io/tags/git-centos/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装vscode</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7环境下安装vscode/</id>
    <published>2019-01-02T16:00:47.000Z</published>
    <updated>2019-01-02T16:01:07.936Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了CentOS7下安装过程。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>环境参数：<br>操作系统版本：CentOS-7-x86_64-1511<br>软件版本：visual stdio code 1.2   </p><p>操作步骤：<br>1.下载 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode_x86_64.rpm</a><br>2.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>可能会报这样一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libXss.so.1()(64bit) is needed by code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libXss*  -y</span><br></pre></td></tr></table></figure></p><p>然后在重新安装rpm文件，没报错可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>然后打开应用程序可以看见vscode安装好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了Cen
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装Chrome</title>
    <link href="https://LiuZiQiao.github.io/2019/01/02/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Chrome/"/>
    <id>https://LiuZiQiao.github.io/2019/01/02/CentOS7环境下安装Chrome/</id>
    <published>2019-01-02T15:01:15.000Z</published>
    <updated>2019-01-02T15:38:50.065Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>下载Chrome浏览器的rpm包（<a href="https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）" target="_blank" rel="noopener">https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）</a><br>利用xshell连接好Linux，使用命令rz，弹出选择窗口，将下载好的包上传进去，然后进入包目录，使用rpm命令进行安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>当然，这里需要切换到root用户下才可以执行。<br>执行完命令后会出现错误<br><img src="https://img-blog.csdnimg.cn/20190102230011852.png" alt="1"></p><p>出现这个错误是因为少了redhat-lsb这个依赖</p><p>安装readhat-lsb依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  redhat-lsb</span><br></pre></td></tr></table></figure></p><p>安装完上面的lsb依赖后，再来执行chrome安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>至此Chrome就安装完毕了，打开 应用程序 》互联网 就会发现Chrome的图标了</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>在以上正常的安装方式中， 我安装失败了，原因是我的key无法更新，于是我就选择了另外一种在线安装。以下记录了在线安装的过程。仅供参考，大佬勿喷。   </p><h4 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h4><p>在/etc/yum.repos.d/目录下新建文件google-chrome.repo，向其中添加如下内容:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[google-chrome]</span><br><span class="line">name=google-chrome</span><br><span class="line">baseurl=http:<span class="comment">//dl.google.com/linux/chrome/rpm/stable/$basearch</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//dl-ssl.google.com/linux/linux_signing_key.pub</span></span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable</span><br></pre></td></tr></table></figure></p><p>注：Google官方源在国内可能无法正常访问，导致安装失败或安装后无法正常更新，可以尝试添加–nogpgcheck参数再安装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable --nogpgcheck</span><br></pre></td></tr></table></figure></p><p>或者可以尝试修改gpgcheck=0再安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Linux下静态链接库出现的问题</title>
    <link href="https://LiuZiQiao.github.io/2018/12/31/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2018/12/31/解决Linux下静态链接库出现的问题/</id>
    <published>2018-12-31T13:04:57.000Z</published>
    <updated>2018-12-31T13:05:49.081Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我们用Makefile工具时，在Makefile文件中写编译语句时，希望编译时用静态链接库来编译，例如语句如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o $@ $^ -<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>编译时链接静态库的方式有好几种，这里我使用static。问题出现的是，当我们make时，出现如下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test test.cpp -<span class="keyword">static</span></span><br><span class="line">/usr/bin/ld: cannot find -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lm</span><br><span class="line">/usr/bin/ld: cannot find -lc</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">make: *** [tcpClient] Error <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在我百度了很久之后CSDN未能解决如下问题，还是Stack Overflow解决了该问题。<br>用如下两条命令安装所需要的静态库即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libstdc++-<span class="keyword">static</span></span><br><span class="line">sudo yum install glibc-<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>安装了以上两个库之后，make一下，编译成功，使用<code>ll</code>查看你会发现编译之后的目标文件会非常大。这时就是成功的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的几款内存泄漏检测工具</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/Linux%E4%B8%8B%E7%9A%84%E5%87%A0%E6%AC%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/Linux下的几款内存泄漏检测工具/</id>
    <published>2018-12-24T13:31:00.000Z</published>
    <updated>2018-12-24T13:38:51.473Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme/article/details/51959654" target="_blank" rel="noopener">原文链接</a></p><p>Linux下编写C或者C++程序，有很多工具，但是主要编译器仍然是gcc和g++。最近用到STL中的List编程，为了检测写的代码是否会发现内存泄漏，了解了一下相关的知识。</p><p>所有使用动态内存分配(dynamic memory allocation)的程序都有机会遇上内存泄露(memory leakage)问题，在Linux里有三种常用工具来检测内存泄露的情況，包括：</p><p>参见 <a href="http://elinux.org/Memory_Debuggers" rel="nofollow" target="_blank">http://elinux.org/Memory_Debuggers</a> <br><br>偶然发现的<a href="http://blog.163.com/zhuang_qianxin/blog/static/29765138201051092529107/" rel="nofollow" target="_blank">内存泄露检测工具比较 </a></p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">工具</th><br>  <th align="center">描述</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#valgrind" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center">一个强大开源的程序检测工具</td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#mtrace" rel="nofollow" target="_blank">mtrace</a></td><br>  <td align="center">GNU扩展, 用来跟踪malloc, mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数</td><br></tr><br><tr><br>  <td align="center"><a href="" rel="nofollow" target="_blank">dmalloc</a></td><br>  <td align="center">用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存,以一个运行库的方式发布</td><br></tr><br><tr><br>  <td align="center">memwatch</td><br>  <td align="center">和dmalloc一样，它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域</td><br></tr><br><tr><br>  <td align="center"><a href="http://mpatrol.sourceforge.net/" rel="nofollow" target="_blank">mpatrol</a></td><br>  <td align="center"><a href="http://www.ibm.com/developerworks/cn/linux/l-mleak2/" rel="nofollow" target="_blank">一个跨平台的 C++ 内存泄漏检测器</a></td><br></tr><br><tr><br>  <td align="center"><a href="http://dbgmem.sourceforge.net/" rel="nofollow" target="_blank">dbgmem</a></td><br>  <td align="center"></td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Electric_Fence" rel="nofollow" target="_blank">Electric Fence</a></td><br>  <td align="center"></td><br></tr><br></tbody></table></div><h1 id="1-被测程序"><a name="t0"></a>1  被测程序</h1><hr><p class="cye-lm-tag">为了方便测试,,我们编写了一个简单的程序, 循环10次每次申请了一个100个字节的单元, 但是却不释放</p><h1 id="2-valgrind"><a name="t1"></a>2  valgrind</h1><hr><h2 id="21-valgrind介绍"><a name="t2"></a>2.1   valgrind介绍</h2><hr><p class="cye-lm-tag">是不是说没有一种内存检查工具能够在Linux使用呢，也不是，像开源的valgrind工具还是相当不错的</p><ul><br><li><p class="cye-lm-tag">Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p></li><br><li><p class="cye-lm-tag">Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p></li><br><li><p class="cye-lm-tag">Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p></li><br><li><p class="cye-lm-tag">Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p></li><br><li><p class="cye-lm-tag">Massif。它主要用来检查程序中堆栈使用中出现的问题。</p></li><br><li><p class="cye-lm-tag">Extension。可以利用core提供的功能，自己编写特定的内存调试工具</p></li><br></ul><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">主页</th><br>  <th align="center">下载</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://valgrind.org/" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center"><a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">downloads</a></td><br></tr><br></tbody></table></div><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719211251895" alt="valgrind介绍" title=""></p><blockquote><br>  <p class="cye-lm-tag">参照</p><br><br>  <p class="cye-lm-tag"><a href="http://www.cnblogs.com/sunyubo/archive/2010/05/05/2282170.html" rel="nofollow" target="_blank">Valgrind简单用法</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">Unix下C程序内存泄漏检测工具Valgrind安装与使用</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">valgrind 的使用简介</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" rel="nofollow" target="_blank">应用 Valgrind 发现 Linux 程序的内存问题</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.oschina.net/translate/valgrind-memcheck" rel="nofollow" target="_blank">如何使用Valgrind memcheck工具进行C/C++的内存泄漏检测</a></p><br></blockquote><h2 id="22-安装"><a name="t3"></a>2.2   安装</h2><hr><p class="cye-lm-tag"><strong>源码安装</strong></p><p class="cye-lm-tag">到<a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">下载地址</a>)下载最新版的valgrind,按照里面的README提示，安装后就可以使用这个工具来检测内存泄露和内存越界等</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">/configuremakesudo make install<p class="cye-lm-tag">当然也可以使用发行版的自带的源中安装</p>sudo apt install valgrind这是一个没有界面的内存检测工具，安装后，输入 valgrind ls -l 验证一下该工具是否工作正常（这是README里面的方法，实际上是验证一下对ls -l命令的内存检测），如果你看到一堆的信息说明你的工具可以使用了。<h2 id="23-使用说明"><a name="t4"></a>2.3   使用说明</h2><hr><p class="cye-lm-tag">Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif。</p><p class="cye-lm-tag"><strong>Memcheck</strong></p><p class="cye-lm-tag">最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，Memcheck 工具主要检查下面的程序错误</p><div class="table-box"><table><thead><tr>  <th align="center">内容</th>  <th align="center">描述</th></tr></thead><tbody><tr>  <td align="center">使用未初始化的内存</td>  <td align="center">Use of uninitialised memory</td></tr><tr>  <td align="center">使用已经释放了的内存</td>  <td align="center">Reading/writing memory after it has been free’d</td></tr><tr>  <td align="center">使用超过 malloc分配的内存空间</td>  <td align="center">Reading/writing off the end of malloc’d blocks</td></tr><tr>  <td align="center">对堆栈的非法访问</td>  <td align="center">Reading/writing inappropriate areas on the stack</td></tr><tr>  <td align="center">申请的空间是否有释放</td>  <td align="center">Memory leaks – where pointers to malloc’d blocks are lost forever</td></tr><tr>  <td align="center">malloc/free/new/delete申请和释放内存的匹配</td>  <td align="center">Mismatched use of malloc/new/new [] vs free/delete/delete []</td></tr><tr>  <td align="center">src和dst的重叠</td>  <td align="center">Overlapping src and dst pointers in memcpy() and related functions</td></tr></tbody></table></div><p class="cye-lm-tag">这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。 </p><p class="cye-lm-tag"><strong>Callgrind</strong></p><p class="cye-lm-tag">和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 </p><p class="cye-lm-tag"><strong>Cachegrind</strong></p><p class="cye-lm-tag">Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 </p><p class="cye-lm-tag"><strong>Helgrind</strong></p><p class="cye-lm-tag">它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 </p><p class="cye-lm-tag"><strong>Massif</strong></p><p class="cye-lm-tag">堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 </p><blockquote>  <p class="cye-lm-tag">此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具</p>  <p class="cye-lm-tag"><strong>注意</strong></p>  <p class="cye-lm-tag">Valgrind不检查静态分配数组的使用情况</p>  <p class="cye-lm-tag">Valgrind占用了更多的内存–可达两倍于你程序的正常使用量</p>  <p class="cye-lm-tag">如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试</p></blockquote><h2 id="24-使用说明"><a name="t5"></a>2.4   使用说明</h2><hr><p class="cye-lm-tag">编译程序</p>g++ -g -o leak leak.c <p class="cye-lm-tag">被检测程序加入 –g   -fno-inline 编译选项保留调试信息, 否则后面的valgrind不能显示到出错行号。</p>valgrind被设计成非侵入式的，它直接工作于可执行文件上，因此在检查前不需要重新编译、连接和修改你的程序。要检查一个程序很简单，只需要执行下面的命令就可以了。valgrind --tool=tool_name program_name比如我们要对ls -l命令做内存检查，只需要执行下面的命令就可以了<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck ls -l</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><blockquote><br>  <p class="cye-lm-tag">小提示 <br><br>  如果不知道有哪些参数, 可以先输入valgrind –tool=, 然后狂按两次tab, 会输出linux系统的只能提示, 同样,如果你输入了valgrind –tool=mem再狂按两次tab,linux系统会为你自动补全</p><br></blockquote><h2 id="25-使用valgrind检测memcheck"><a name="t6"></a>2.5   使用valgrind检测Memcheck</h2><hr><p class="cye-lm-tag">下面我们就可以用valgrind对我们的程序检测leak</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes    ./leak</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag">其中–leak-check=full 指的是完全检查内存泄漏，</p><p class="cye-lm-tag">–show-reachable=yes是显示内存泄漏的地点，</p><p class="cye-lm-tag">–trace-children=yes是跟入子进程。</p><p class="cye-lm-tag">当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理：</p><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719210756831" alt="输出内存泄漏的信息原" title=""></p><h1 id="3-mtrace检测内存泄露"><a name="t7"></a>3  mtrace检测内存泄露</h1><hr><h2 id="31-mtrace简介"><a name="t8"></a>3.1   mtrace简介</h2><hr><p class="cye-lm-tag">在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace. </p><p class="cye-lm-tag">mtrace其实是GNU扩展函数，用来跟踪malloc。</p><p class="cye-lm-tag">mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。 <br><br>在程序中，这些trace信息可以被用来发现内存泄漏和释放不是申请的内存。 <br><br>当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。 <br><br>如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。</p><p class="cye-lm-tag">详细说明可参考man page：man 3 mtrace</p><h2 id="32-mtrace使用"><a name="t9"></a>3.2   mtrace使用</h2><hr><p class="cye-lm-tag">mtrace能监测程序是否内存泄露</p><ul><br><li>在程序的起始处包含头文件</li></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-preprocessor cye-lm-tag">#include &lt;mcheck.h&gt;</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>更改环境变量：export   MALLOC_TRACE=”mtrace.out”可以加入如下代码</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">setenv(<span class="hljs-string cye-lm-tag">"MALLOC_TRACE"</span>, <span class="hljs-string cye-lm-tag">"mtrace.out"</span>, <span class="hljs-number cye-lm-tag">1</span>);</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>调用函数mtrace()</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace()</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>编译程序带上 -g 选项</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">gcc -g -c leak_mtrace.c -o leak_mtrace.o  -<span class="hljs-built_in cye-lm-tag">std</span>=gnu9x -Wall</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">./leak_mtrace </code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>mtrace a.out  mtrace.out查看内存监测情况</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace a.out  mtrace.out</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719214131721" alt="这里写图片描述" title=""></p><h1 id="4-dmalloc"><a name="t10"></a>4  dmalloc</h1><hr><p class="cye-lm-tag">dmalloc是一种用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存，并且能够精确指出在哪个源文件的第几行。</p><h1 id="5-linux内核的kmemleak"><a name="t11"></a>5  Linux内核的Kmemleak</h1><h2 id="51-kmemleak检测工具介绍"><a name="t12"></a>5.1   Kmemleak检测工具介绍</h2><hr><p class="cye-lm-tag">Kmemleak工作于内核态是内核自带的内核泄露检测工具, 其源代码位于<a href="http://lxr.free-electrons.com/source/mm/kmemleak.c?v4.7" rel="nofollow" target="_blank">mm/kmemleak.c</a></p><p class="cye-lm-tag">Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，其方法类似于跟踪内存收集器。当独立的对象没有被释放时，其报告记录在 /sys/kernel/debug/kmemleak中，Kmemcheck能够帮助定位大多数内存错误的上下文。</p><h2 id="52-kmemleak使用过程概述"><a name="t13"></a>5.2   Kmemleak使用过程概述</h2><ul><br><li><p class="cye-lm-tag">首先`CONFIG_DEBUG_KMEMLEAK在Kernel hacking中被使能.</p></li><br><li><p class="cye-lm-tag">查看内核打印信息详细过程如下：</p><br><br><ol><li>挂载debugfs文件系统 <br><br>mount -t debugfs nodev /sys/kernel/debug/</li><br><li>开启内核自动检测线程 <br><br>echo scan &gt; /sys/kernel/debug/kmemleak</li><br><li>查看打印信息 <br><br>cat /sys/kernel/debug/kmemleak</li><br><li>清除内核检测报告，新的内存泄露报告将重新写入/sys/kernel/debug/kmemleak <br><br>echo clear &gt; /sys/kernel/debug/kmemleak</li></ol></li><br></ul><p class="cye-lm-tag">内存扫描参数可以进行修改通过向/sys/kernel/debug/kmemleak 文件写入。 参数使用如下</p><pre class="prettyprint" name="code"><code class="language-cpp hljs  has-numbering">off 禁用kmemleak（不可逆）<span class="hljs-built_in cye-lm-tag">stack</span>=on 启用任务堆栈扫描(<span class="hljs-keyword cye-lm-tag">default</span>)<span class="hljs-built_in cye-lm-tag">stack</span>=off 禁用任务堆栈扫描scan=on 启动自动记忆扫描线程(<span class="hljs-keyword cye-lm-tag">default</span>)scan=off 停止自动记忆扫描线程scan=&lt;secs&gt; 设置n秒内自动记忆扫描scan 开启内核扫描clear 清除内存泄露报告dump=&lt;addr&gt; 转存信息对象在&lt;addr&gt;</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p class="cye-lm-tag">通过“kmemleak = OFF”，也可以在启动时禁用Kmemleak在内核命令行。在初始化kmemleak之前，内存的分配或释放这些动作被存储在一个前期日志缓冲区。这个缓冲区的大小通过配CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE设置。 </p><h2 id="53-kmemleak动态检测原理"><a name="t14"></a>5.3   Kmemleak动态检测原理</h2><hr><p class="cye-lm-tag">通过的kmalloc、vmalloc、kmem_cache_alloc等内存分配会跟踪其指针，连同其他的分配大小和堆栈跟踪信息，存储在PRIO搜索树。相应的释放函数调用跟踪和指针就会从kmemleak数据结构中移除。 <br><br>分配的内存块，被认为是独立的，如果没有指针指向它起始地址或块的内部的任何位置，可以发现扫描内存（包括已保存的寄存器）。这意味着，有可能没有办法为内核通过所分配的地址传递块到一个释放函数，因此，该块被认为是一个内存泄漏。</p><p class="cye-lm-tag">扫描算法步骤： <br><br>1.  标记的所有分配对象为白色（稍后将剩余的白色物体考虑独立的）</p><ol><br><li><p class="cye-lm-tag">扫描存储器与所述数据片段和栈开始，检查对地址的值存储在PRIO搜索树。如果一个白色的对象的指针被发现，该对象将被添加到灰名单</p></li><br><li><p class="cye-lm-tag">扫描的灰色对象匹配的地址（一些白色物体可以变成灰色，并添加结束时的灰名单），直到黑色集结束</p></li><br><li><p class="cye-lm-tag">剩下的白色物体被认为是独立儿，并报告写入/sys/kernel/debug/kmemleak。 <br><br>一些分配的内存块的指针在内核的内部数据结构和它们不能被检测为孤儿。对避免这种情况，kmemleak也可以存储的数量的值，指向一个内的块的地址范围内的地址，需要找到使块不被认为是泄漏.</p></li><br></ol><h2 id="54-kmem相关函数"><a name="t15"></a>5.4   kmem相关函数</h2><hr><p class="cye-lm-tag">从kernel源代码中的目录<code>include /linux/kmemleak.h</code>中可查看函数原型的头</p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">函数</th><br>  <th align="center">功能</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center">kmemleak_init</td><br>  <td align="center">初始化kmemleak</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc</td><br>  <td align="center">一个内存块分配的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_percpu</td><br>  <td align="center">通知的一个percpu的内存块分配</td><br></tr><br><tr><br>  <td align="center">kmemleak_free</td><br>  <td align="center">通知的内存块释放</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_part</td><br>  <td align="center">通知释放部分内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_percpu</td><br>  <td align="center">一个percpu内存块释放的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_not_leak</td><br>  <td align="center">当不是泄露时，标记对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_ignore</td><br>  <td align="center">当泄漏时不扫描或报告对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_scan_area</td><br>  <td align="center">添加扫描区域内的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_no_scan</td><br>  <td align="center">不扫描的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_erase</td><br>  <td align="center">删除一个指针变量的旧值</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_recursive</td><br>  <td align="center">为kmemleak_alloc，只检查递归</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_recursive</td><br>  <td align="center">为kmemleak_free，只检查递归</td><br></tr><br></tbody></table></div>            <br>                        <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"><br>                </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>window双系统Deepin安装及正确删除</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/window%E5%8F%8C%E7%B3%BB%E7%BB%9FDeepin%E5%AE%89%E8%A3%85%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/window双系统Deepin安装及正确删除/</id>
    <published>2018-12-24T13:18:34.000Z</published>
    <updated>2018-12-24T13:34:11.549Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://blog.csdn.net/qq_39478237/article/details/85239249" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39478237/article/details/85239249&quot; 
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="https://LiuZiQiao.github.io/2018/12/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://LiuZiQiao.github.io/2018/12/10/滑动窗口的最大值/</id>
    <published>2018-12-10T14:54:59.000Z</published>
    <updated>2018-12-10T15:00:41.932Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>暴力破解法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || num.size() &lt; size || num.size() &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> end = size;   <span class="comment">//定义end为窗口数组的大小</span></span><br><span class="line"><span class="keyword">while</span> (end &lt;= num.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = num[end-size];    <span class="comment">//默认窗口中第一个元素为最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = end - size+<span class="number">1</span>; i &lt; end; ++i)         <span class="comment">//从第二个元素开始进行窗口元素遍历，找到窗口中最大的元素，存入v中，end后移</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; num[i])</span><br><span class="line">&#123;</span><br><span class="line">max = num[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br><span class="line">v.push_back(max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><strong>Thinking</strong> 。。。</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux编程之进程间通信</title>
    <link href="https://LiuZiQiao.github.io/2018/12/08/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://LiuZiQiao.github.io/2018/12/08/Linux编程之进程间通信/</id>
    <published>2018-12-08T14:00:40.000Z</published>
    <updated>2018-12-08T14:01:29.334Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程,在这个过程中，伴随着资源的分配和释放。那么释放的资源可能是其他进程需要的，然而进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。</p><h3 id="进程通信应用场景"><a href="#进程通信应用场景" class="headerlink" title="进程通信应用场景"></a>进程通信应用场景</h3><ul><li><p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p></li><li><p>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p></li><li><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p></li><li><p>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p></li><li><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p></li></ul><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h4><p><img src="https://img-blog.csdnimg.cn/20181208215636614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>管道实现细节</strong><br>在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图<br><img src="https://img-blog.csdnimg.cn/20181208215019885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><p>仅仅适用于具有亲缘关系的进程间通信，因为匿名管道其它进程根本找不到，因此也就没有办法通信，所以只能通过子进程复制父进程的方法，让子进程能够访问相同的管道，来实现通信。<br>（管道的操作：io操作—文件描述符）</p><h5 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5><p>有名字：体现在文件系统可见性，因为其它进程都能看见这个管道文件，因此都能打开可以用于任意（本机）进程间通信<br>（单向通信）所以一个管道使用的时候就必须确定数据流向，但是不能一创建就确 定，因为我们不确定谁读谁写。   因此，操作系统提供两个描述符来供<br>使用，一个读一个写，这样的确定方向就是将对应的一段关闭掉就可以，这样操作系统就把方向的控制权交给用户了<br>接口：pipe（int fd[2]）fd[0]— 读  fd[1]—写</p><h4 id="信号量（semophore）"><a href="#信号量（semophore）" class="headerlink" title="信号量（semophore）"></a>信号量（semophore）</h4><p>信号量并不是用来数据传输的，而是用来进程控制，是解决进程间同步与互斥问题<br>是一个具有等待队列的计数器<br>释放资源+1，<br>获取资源-1，<br>当计数器的值不大于0，意味着没有资源，想要获取信号量资源（计数器-1）的就需要等待<br>同步：如果现在没有资源，等待，等待别人释放资源，别人释放资源后会通知等待的人<br>互斥：一元信号量实现互斥（计数器是0或 1）   </p><h4 id="消息队列（message-queue）"><a href="#消息队列（message-queue）" class="headerlink" title="消息队列（message queue）"></a>消息队列（message queue）</h4><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   它通常在内核中创建一个消息队列，其它的所有进程都可以通过相同的<code>IPC_KEY</code> 打开消息队列<br>这时候既可以向消息队列中放数据，也可以从中拿数据，但是这样的数据就有可能拿错了，拿到的不是自己的数据，因此消息队列中能够放的数据是有类型的数据块，并且读写的时候只能按消息块来发送/接收。</p><h4 id="信号（sinal）"><a href="#信号（sinal）" class="headerlink" title="信号（sinal）"></a>信号（sinal）</h4><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>它是通过软中断的方式来进行的，信号产生之后第一时间也不是直接处理，而是先存储下来，处理信号<br>为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去准备处理事件，事件处理完毕后进程回到原先运行的位置继续运行   </p><p><strong>信号的产生-&gt;信号的注册-&gt;注销信号-&gt;信号的处理</strong><br>Linux下有62种信号，kill -l查看<br>信号分两类：普通信号（不可靠信号1~31)(非实时信号)<br>可靠信号（34~64）(实时信号)</p><p><strong>信号的产生：</strong>   </p><ul><li>1.硬件中断产生  Ctrl+C</li><li>2.程序异常   SIGFPE   SIGSEGV  </li><li>3.软件条件产生<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line">kill(getpid(),SIGINT);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">()</span></span>;   </span><br><span class="line">raise(SIGTERM);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">sigqueue</span><br><span class="line">alarm(<span class="number">3</span>); <span class="comment">// 在3秒后向进程发送SIGALRM信号，返回值会取消上一次的定时器，并且返回上一次定时器剩余时间</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心转储（core dump）</strong>：<br>保存当前程序运行的数据以及调用栈信息，用于错误原因定位调试。如果程序运行出现错误，可以直接通过core文件来gdb调试（有些错误可能偶然发生）  coredump默认关闭：隐私安全/资源占用   </p><p><strong>信号的注册：</strong><br>pcb中有一个信号结构体,信号注册/进程发送信号，就是修改这个进程pcb中关于信号的pending位图，将相应的信号为置1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">sigset_t</span> pending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号的阻塞</strong>：暂时不处理信号（阻止信号的递达），并不是不接收信号,<br>pcb中还有一个信号位图block，要阻止一个信号就是修改pcb中关于信号的<code>block</code>位图，将相应的信号位置1，这个位置就像是一个备注说明如果接收到这<br>个信号暂时不处理   </p><p>信号未决：这是一种状态，信号从注册成功到信号递达之间   </p><p><strong>信号的注销：</strong><br>就是从<code>pending</code>集合中将即将处理的信号相应位置0（从pcb的<code>pending</code>集合中移除）<br>非可靠信号注册就是将相应pending位图置1，然后添加一个<code>sigqueue</code>结构到链表中，之后如果有相应信号到来，一看位图已经            置1那么就不做任何操作，意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了！！！   </p><blockquote><p>可靠信号就是不管有没有注册都要置1，并且添加结点到链表中，所以不会丢信号。<br>非可靠注销就是删除链表结点，相应位图置0.<br>可靠信号删除结点，判断是否有相同信号结点，如果没有则位图置0，如果有则置1；</p></blockquote><p><strong>信号的递达（信号的处理）：</strong>  </p><ul><li>默认操作——安装操作系统中对信号事件的既定处理方式   </li><li>忽略操作——直接将信号丢掉   </li><li><p>自定义处理—–用户自定义事件处理方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signal接口</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    signum：信号的编号</span><br><span class="line">    handler：处理方式</span><br><span class="line">    SIG_IGN 忽略</span><br><span class="line">    SIG_DFL 默认</span><br></pre></td></tr></table></figure></li></ul><p><strong>信号的捕捉流程：</strong><br> 信号并不是立即处理，而是选择一个合适的时机处理，合适的时机就是当前程序从==内核态==切换到==用户态==的时候<br>程序如何从内核态切换到用户态：发起系统调用，程序异常，中断时<br>信号是当我们发起系统调用/程序异常/中断当前程序从用户态切换到内核态，去处理这些事情，处理完毕后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有，就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕后再次返回内核态，判断如果没有信号要处理了就调用<code>sys_sigreturn</code>返回用户态（我们程序之前的运行位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigaddset</span><br><span class="line">sigdelst</span><br><span class="line">sigfillset</span><br><span class="line">sigprocmask信号阻塞接口，阻塞函数，向block添加信号</span><br><span class="line">sigismember </span><br><span class="line">sigpending</span><br></pre></td></tr></table></figure><p>struct sigqueue</p><p>操作系统如何通知父进程说子进程退出了？<br>信号：SIGCHLD -17号信号<br>用户自定义信号：SIGCHLD -17处理方式，相当于提前告诉进程，当接收到这个信号时使用waitpid，这样就不用一直等待 </p><h4 id="共享内存（shared-memory）"><a href="#共享内存（shared-memory）" class="headerlink" title="共享内存（shared memory）"></a>共享内存（shared memory）</h4><p>是进程间通信速度最快的方式<br>其它的进程间通信方式，都会涉及到将用户空间的数据拷贝到内核空间（因为公共缓冲区都在内核空间），这是两步操作（拷入和拷出）<br>而共享内存的原理是多个进程将同一块物理内存映射到自己的虚拟地址空间，以这种方式实现数据共享，操作这个虚拟地址就是操作这个物理内存，相较于其它通信方式，少了两步用户空间和内核空间的拷贝过程，因此速度最快<br>共享内存操作步骤：    共享内存的生命周期随内核<br>1.创建/打开一块共享内存<br>2.将这块共享空间映射到自己的虚拟地址空间<br>3.各种内存操作<br>4.解除映射关系<br>5.删除共享内存  </p><h4 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h4><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。因此被广泛应用于网络通信中。</p><h3 id="进程间通信的实现"><a href="#进程间通信的实现" class="headerlink" title="进程间通信的实现"></a>进程间通信的实现</h3><h4 id="匿名管道通信"><a href="#匿名管道通信" class="headerlink" title="匿名管道通信"></a>匿名管道通信</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个匿名管道的demo</span></span><br><span class="line"><span class="comment"> *      匿名管道操作：</span></span><br><span class="line"><span class="comment"> *          创建：pipe</span></span><br><span class="line"><span class="comment"> *          读写：read write</span></span><br><span class="line"><span class="comment"> *      匿名管道仅能用于具有亲缘关系的进程间通信</span></span><br><span class="line"><span class="comment"> *      创建匿名管道必须在创建子进程之前，否则子进程将无法复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程 读</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程 写</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *ptr = <span class="string">"hello world"</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名管道通信"><a href="#命名管道通信" class="headerlink" title="命名管道通信"></a>命名管道通信</h4><p>这是一个命名管道的实现实例，实现两个进程聊天功能<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(file, <span class="number">0664</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fifo exist!!\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open fifo success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0x00</span>, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = read(fd, buff, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer say:%s\n"</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="管道符实现命令"><a href="#管道符实现命令" class="headerlink" title="管道符实现命令"></a>管道符实现命令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个实现管道符的demo</span></span><br><span class="line"><span class="comment"> *  命令：ps -ef |grep ssh</span></span><br><span class="line"><span class="comment"> *  一个进程运行ps程序，一个进程运行grep程序</span></span><br><span class="line"><span class="comment"> *  ps程序就需要将结果通过匿名管道传递给grep程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程运行grep程序处理ps的结果（从管道读数据）</span></span><br><span class="line">        dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/grep"</span>, <span class="string">"grep"</span>, <span class="string">"ssh"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程运行ps程序，将结果写入管道</span></span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/ps"</span>, <span class="string">"ps"</span>, <span class="string">"-ef"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一块共享内存的demo，共享数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x01234567</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int shmget(key_t key, size_t size, int shmflg);</span></span><br><span class="line">    <span class="comment">//  key：共享内存在系统中的标识啊</span></span><br><span class="line">    <span class="comment">//      ftok这个接口可以通过一个文件计算出一个key值</span></span><br><span class="line">    <span class="comment">//  size：共享内存大小</span></span><br><span class="line">    <span class="comment">//  shmflg：IPC_CREAT 创建|权限</span></span><br><span class="line">    <span class="comment">//  返回值：共享内存的操作句柄</span></span><br><span class="line">    shmid = shmget(IPC_KEY, <span class="number">32</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmget error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建的这个共享内存无法直接操作，因为我们只能操作虚拟地址空间</span></span><br><span class="line">    <span class="comment">//中的地址，因此第二步就是将共享内存映射到虚拟地址空间，让我们</span></span><br><span class="line">    <span class="comment">//能够通过虚拟地址来访问这块内存</span></span><br><span class="line">    <span class="comment">//void *shmat(int shmid, const void *shmaddr, int shmflg);</span></span><br><span class="line">    <span class="comment">//  shmid:  共享内存句柄</span></span><br><span class="line">    <span class="comment">//  shmaddr：映射首地址（通常置空）</span></span><br><span class="line">    <span class="comment">//  shmflg：</span></span><br><span class="line">    <span class="comment">//      SHM_RDONLY  只读 否则可读可写</span></span><br><span class="line">    <span class="comment">//  返回：映射到虚拟地址空间的首地址 失败：(void*)-1</span></span><br><span class="line">    <span class="keyword">void</span> *shm_start = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmat error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while(1) &#123;</span></span><br><span class="line"><span class="comment">        sprintf(shm_start, "%s---%d\n", "吃什么呢??", i++);</span></span><br><span class="line"><span class="comment">        sleep(1);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//int shmdt(const void *shmaddr);</span></span><br><span class="line">    <span class="comment">//  解除共享内存在虚拟地址空间中的映射关系</span></span><br><span class="line">    <span class="comment">//  shmaddr: 映射的首地址</span></span><br><span class="line">    <span class="comment">//  返回值 成功：0  失败：-1</span></span><br><span class="line">    shmdt(shm_start);</span><br><span class="line">    <span class="comment">//int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span></span><br><span class="line">    <span class="comment">//  cmd:</span></span><br><span class="line">    <span class="comment">//      IPC_RMID    删除共享内存</span></span><br><span class="line">    <span class="comment">//  buf：存放获取到的共享内存信息</span></span><br><span class="line">    <span class="comment">//  删除共享内存（并不会立即删除，会判断映射链接数是否为0）</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个演示signal接口修改信号处理方式的demo</span></span><br><span class="line"><span class="comment"> *  信号的处理方式有三种：</span></span><br><span class="line"><span class="comment"> *      忽略</span></span><br><span class="line"><span class="comment"> *      默认</span></span><br><span class="line"><span class="comment"> *      自定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    b++;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv signo:%d--%d\n"</span>, signo, c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line">    <span class="comment">//  signum: 信号的编号</span></span><br><span class="line">    <span class="comment">//  handler：   处理方式</span></span><br><span class="line">    <span class="comment">//      SIG_IGN 忽略</span></span><br><span class="line">    <span class="comment">//      SIG_DFL 默认</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGINT, sigcb);</span><br><span class="line">    signal(SIGQUIT, sigcb);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        printf("-----------\n");</span></span><br><span class="line"><span class="comment">        kill(getpid(), SIGINT);</span></span><br><span class="line"><span class="comment">        if (++i == 3) &#123;</span></span><br><span class="line"><span class="comment">            signal(SIGINT, SIG_DFL);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sigcb(SIGQUIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="僵尸进程的避免"><a href="#僵尸进程的避免" class="headerlink" title="僵尸进程的避免"></a>僵尸进程的避免</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*僵尸进程的避免：</span></span><br><span class="line"><span class="comment"> *  僵尸进程是子进程先于父进程退出，操作系统会通知父进程说你的子进</span></span><br><span class="line"><span class="comment"> *  程挂了，你去收尸吧，但是父进程没有管，所以子进程死不瞑目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  操作系统如何通知父进程说子进程退出呢？</span></span><br><span class="line"><span class="comment"> *      信号：SIGCHLD -17号信号</span></span><br><span class="line"><span class="comment"> *  以前因为没有学信号，因此我们避免产生僵尸进程，只能让父进程一直</span></span><br><span class="line"><span class="comment"> *  等待子进程的退出（因为实在是不知道子进程到底什么时候退出，），</span></span><br><span class="line"><span class="comment"> *  浪费了父进程资源，</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  现在学了信号完全可以这样做：</span></span><br><span class="line"><span class="comment"> *      自定义信号：SIGCHLD的处理方式，相当于提前告诉进程，当接收到</span></span><br><span class="line"><span class="comment"> *      这个信号的时候使用waitpid，这样就不用一直等了；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用非阻塞的循环来处理SIGCHLD信号</span></span><br><span class="line">    <span class="comment">//因为SIGCHLD信号不是可靠信号，有可能丢失</span></span><br><span class="line">    <span class="comment">//因此就有可能漏掉僵尸子进程没有处理，</span></span><br><span class="line">    <span class="comment">//所以一旦接收到信号就处理到不能处理为止</span></span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"have child exit!!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGCHLD, sigcb);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;进程通信概念&quot;&gt;&lt;a href=&quot;#进程通信概念&quot; class=&quot;headerlink&quot; title=&quot;进程通信概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="signal" scheme="https://LiuZiQiao.github.io/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://LiuZiQiao.github.io/2018/12/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://LiuZiQiao.github.io/2018/12/08/旋转数组的最小数字/</id>
    <published>2018-12-08T05:40:23.000Z</published>
    <updated>2018-12-08T05:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>咋眼一看这题，很简单啊，就一次遍历找到最小值就可以了啊，那答案就很简单。如下给出一般解决方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;rotateArray.size()<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i] &gt; rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这个题目时我们应该更加进一步去思考该题，这个题难道就这么简单？其实不然，当我们控制其时间复杂度时，我们可以思考另外一种方式来解决，如下给出思路：   </p><p>我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。<br> 我们试着用<strong>二分查找法</strong>的思路在寻找这个最小的元素。<br>首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。<br>接着我们得到处在数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。<br>我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。<br>我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的两个指针，去得到和比较新的中间元素，循环下去。<br>按照上述的思路，我们的第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最后第一个指针将指向前面子数组的最后一个元素，而第二个指针会指向后面子数组的第一个元素。<br>也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rotateArray.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[begin]&lt;rotateArray[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">                middle = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[middle] &gt;= rotateArray[begin])</span><br><span class="line">            &#123;</span><br><span class="line">                begin = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[middle] &lt;= rotateArray[begin])&#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> rotateArray[middle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二分" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之线程</title>
    <link href="https://LiuZiQiao.github.io/2018/12/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>https://LiuZiQiao.github.io/2018/12/05/Linux系统编程之线程/</id>
    <published>2018-12-05T14:32:12.000Z</published>
    <updated>2018-12-05T14:53:35.938Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p><strong>回顾进程</strong><br>在介绍线程之前，我们先来回顾下进程，进程的定义就是指一个具有独立功能的程序在某个数据集上的一次动态执行的过程，是系统进程资源分配和调度的基本单元。 一次任务的运行可以并发激活多个进程，这些进程相互合作完成该任务的一个最终目标。 操作系统对进程的描述：PCB（进程控制块）Linux下的进程描述——task_struct。   </p><p><strong>那么线程是什么呢？</strong>   </p><ul><li>线程是进程中的一条执行流，Linux下的线程是用进程的PCB模拟的，所以Linux下的线程也叫轻量级进程。 <strong>进程是资源分配的基本单位,</strong> 那么<strong>线程就是CPU调度的基本单位。</strong> </li><li>一个进程至少有一个线程，因此我们的进程其实就是线程组。进程id = 线程组id，所以才说Linux下的进程是线程组，资源分配的基本单位，并且进程中的线程共享大部分进程的资源。</li><li>Linux下的线程共用进程的虚拟地址空间，与进程内的其他线程共享进程的资源,共享代码段，数据段。</li><li>文件描述符表，信号处理方式，工作目录用户id</li><li>线程不仅共享进程的这些资源，并且还独自有一些资源：栈，上下文数据。</li></ul><p><strong>有了进程为什么还要线程呢？</strong><br>线程的优缺点正好说明了我们操作系统为什么还要线程。   </p><blockquote><p>优点：</p><ul><li>线程的创建和销毁成本更低。</li><li>线程的调度切换成本也会更低</li><li>线程间通信更加方便</li><li>线程执行的力度更加细致<br>缺点 </li><li>缺乏访问控制：进程是访问的基本粒度，在一个线程中调用可能会对整个进程造成影响</li><li>多个线程对临界资源进行操作时会造成数据混乱</li><li>性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享一个处理器。如果密集型线程数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加额外的同步和调度开销，而可用的资源不变。</li><li>调试难度大大提高：编写与调试一个多线程程序比单线程程序困难的多。</li></ul></blockquote><p>即便是线程有一些缺点，但它的作用依然非常强大，任然引用与一些项目中。</p><p>进程的一些特征：<br>我们知道，进程有进程的标识符pid，那么线程也有自己的标识符tid</p><h3 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h3><p>1.pthread_create函数<br>功能：创建线程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line">    函数参数解释：</span><br><span class="line">      <span class="keyword">pthread_t</span> *tid：一个进程内的各个线程是由线程ID标识的，如果新线程创建成功，返回tid指针。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr：每个线程有多个属性，包括优先级、初始栈大小、是否是一个守护线程等等。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *)：线程启动函数，线程从调用这个函数开始，或显示结束（调用pthread_exit()），或隐式结束（让该函数返回）。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *arg：线程执行func函数的传递参数。</span><br></pre></td></tr></table></figure></p><p>2.pthread_join函数 功能：等待一个线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line">      <span class="keyword">void</span> **status：二级指针，如果status指针非空，那么所等待线程的返回值将存放在status指向的位置。</span><br></pre></td></tr></table></figure></p><p>3.pthread_self函数  功能：返回线程ID<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      跟进程比较，相当于getpid。</span><br></pre></td></tr></table></figure></p><p>4.pthread_detach函数 功能：线程分离<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;　　</span><br><span class="line">      线程或者是可汇合的（joinable），或者是脱离的（detach）。当可汇合的线程终止时，线程ID和退出状态将保留，知道另外一个线程调用pthread_join。脱离的线程终止时，释放所有的资源，因此我们不能等待它终止。若要一个线程知道另一个线程的终止时间，我们就要保留第二个线程的可汇合性。</span><br></pre></td></tr></table></figure></p><p>5.pthread_exit函数  功能：线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> **status)</span></span>;　　</span><br><span class="line">      若线程未脱离，那么它的线程ID和退出状态将保留到另外一个线程调用pthread_join为止。</span><br></pre></td></tr></table></figure></p><p>下面我们演示一个线程的创建<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> *tid = (<span class="keyword">pthread_t</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child~~~%p\n"</span>, *tid);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//void pthread_exit(void *retval);</span></span><br><span class="line">        <span class="comment">//用于退出自己，可以返回一个数据</span></span><br><span class="line">        <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//演示多个线程的并行</span></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="comment">//int pthread_create(pthread_t *thread, pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//  void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">    <span class="comment">//  thread: 用于获取线程id（用户态的线程id）</span></span><br><span class="line">    <span class="comment">//  attr：  设置线程属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//  start_routine：线程入口函数，线程所运行的代码</span></span><br><span class="line">    <span class="comment">//  arg：   线程入口函数的参数</span></span><br><span class="line">    <span class="comment">//  返回值：成功：0     失败：非0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)&amp;tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid);  <span class="comment">//用于取消标识符为tid线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//pthread_t pthread_self(void);</span></span><br><span class="line">        <span class="comment">//获取线程自身的线程id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am main~~~~!%d---%p\n"</span>, pid, pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个线程分离演示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int pthread_detach(pthread_t thread);</span></span><br><span class="line">    <span class="comment">//  分离指定的线程，被分离的线程退出时自动被回收资源</span></span><br><span class="line">    <span class="comment">//  因为资源立即被回收，所以不会保存返回值，也就无法被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定要分离的线程id</span></span><br><span class="line">    <span class="comment">//pthread_t pthread_self(void)</span></span><br><span class="line">    <span class="comment">//  获取自身线程 id</span></span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">"laozaotai!!\n"</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line">    <span class="comment">//这是一个阻塞函数，如果线程没有退出就一直等待</span></span><br><span class="line">    <span class="comment">//这里等待的线程必须是处于joinable属性才可以被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定等待的线程id</span></span><br><span class="line">    <span class="comment">//  retval：获取线程的退出返回值</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="keyword">if</span> (err == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread is detached!!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child thread:%s\n"</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个线程的作用不大，但是一堆线程能干大事，了解王者荣耀的人可能会知道，王者荣耀采用了多线程开发技术，多线程模式，这个模式的作用可以让玩家在团战中帧率更高，打起来更加的流畅，这就是多线程的一个好处。   </p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>因为线程是CPU调度的基本单位，因此多个线程就有可能同时争抢临界资源，那么这种情况就有可能导致数据的二义性。打个比方：当两个线程同时向一个文件修改数据时，那么这个文件的数据到底让那个线程修改？这就是一个线程安全问题。</p><p>为了解决线程安全问题，我们引入了线程的同步与互斥   </p><ul><li><p>互斥：保证数据同一时间唯一的访问，那么我们就可以用一个锁来锁住当前线程，不让其它线程进行访问，即互斥锁   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init  <span class="comment">//初始化   </span></span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock   </span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock </span><br><span class="line">pthread_mutex_timedlock <span class="comment">//指定一段时间内获取锁</span></span><br></pre></td></tr></table></figure></li><li><p>死锁：在使用互斥锁的同时，有可能会发生死锁，在前面有关于<a href="https://LiuZiQiao.github.io/2018/11/28/Linux下的死锁/">死锁问题</a>的文章,这里就不做赘述了</p></li><li><p>同步：保证对临界资源访问的时序性，即我们需要条件变量通知线程或等待线程，满足操作条件，才可以操作，不满足则需要等待，而条件满足就需要其它线程修改条件，并且通知一下等待的进程    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init<span class="comment">//初始化</span></span><br><span class="line">pthread_cond_destroy</span><br><span class="line">pthread_cond_broadcast  <span class="comment">//唤醒多个线程，广播唤醒</span></span><br><span class="line">pthread_cond_wait<span class="comment">//等待</span></span><br><span class="line">pthread_cond_timedwait</span><br><span class="line">pthread_cond_signal  <span class="comment">// 唤醒第一个等待的线程，通知一个线</span></span><br></pre></td></tr></table></figure></li></ul><p>下面演示一个互斥锁使用场景，抢票<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">yellow_cow</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//lock 阻塞加锁，trylock 非阻塞加锁，timedlock 限时阻塞加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"cow %d get ticket:%d\n"</span>, id, ticket);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在任何有可能退出的地方都必须在退出前解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">4</span>, i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  互斥锁变量的初始化</span></span><br><span class="line">    <span class="comment">//int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span></span><br><span class="line">    <span class="comment">//  const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line">    <span class="comment">//  这种初始化，在使用结束后必须要释放</span></span><br><span class="line">    <span class="comment">//  mutex:  互斥锁变量</span></span><br><span class="line">    <span class="comment">//  attr：  属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,yellow_cow,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line">    <span class="comment">//  销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;线程的概念&quot;&gt;&lt;a href=&quot;#线程的概念&quot; class=&quot;headerlink&quot; title=&quot;线程的概念&quot;&gt;&lt;/a&gt;线程的
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="thread" scheme="https://LiuZiQiao.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Vim中Ctrl+s问题</title>
    <link href="https://LiuZiQiao.github.io/2018/12/03/Ctrl-s%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2018/12/03/Ctrl-s问题/</id>
    <published>2018-12-03T15:50:20.000Z</published>
    <updated>2018-12-03T15:55:24.865Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20181203234814813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>习惯了在IDE环境下写代码而突然换到VIM中的人看过来，这是需要注意的坑，我们习惯在VIM中写完进行<code>CTRL + S</code>进行保存，然后就卡住不动了，你最有可能的操作就是关闭当前打开的VIM，但是关闭后我们的代码就没有了，哈哈，刚写的代码没了你是什么心情，我就是一遍一遍的踩到这个坑才研究了下<code>CTRL + S</code>在VIM中的作用，其实在VIM中<code>CTRL + S</code>是锁住的意思，锁住当前页面，我们用<code>CTRL + q</code>解除就可以了，这下你就不会在傻乎乎的关闭了。<br>q解除就可以了，这下你就不会在傻乎乎的关闭了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181203234814813.png?x-oss-pro
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串替换</title>
    <link href="https://LiuZiQiao.github.io/2018/12/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/"/>
    <id>https://LiuZiQiao.github.io/2018/12/02/字符串替换/</id>
    <published>2018-12-02T12:15:55.000Z</published>
    <updated>2018-12-02T12:16:27.748Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。</p><p>给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。</p><p>测试样例：</p><blockquote><p>“A%sC%sE”,7,[‘B’,’D’,’F’]<br>返回：”ABCDEF”</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：定义一个新的字符串来接收返回的字符串，接收过程中将%s去掉即可。话不多说，上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">formatString</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; arg, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">string</span> strRet;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;A.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'%'</span> &amp;&amp; A[i+<span class="number">1</span>] == <span class="string">'s'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               strRet += arg[index++];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                strRet += A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;m;++index)</span><br><span class="line">        &#123;</span><br><span class="line">            strRet += arg[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;实现
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>微信红包</title>
    <link href="https://LiuZiQiao.github.io/2018/12/02/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85/"/>
    <id>https://LiuZiQiao.github.io/2018/12/02/微信红包/</id>
    <published>2018-12-02T12:05:31.000Z</published>
    <updated>2018-12-02T12:05:56.977Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</p><p>给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。</p><p>若没有金额超过总数的一半，返回0。</p><p>测试样例：</p><blockquote><p>[1,2,3,2,2],5<br>返回：2</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方法一：C++中学过map的人可能做这个题会非常简单，利用map键值对的巧妙来对数据的处理。以下就是根据map<int,int>的第一个int用来存储被计数的值，右边来存放出现的个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[gifts[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second &gt; n/<span class="number">2</span>) <span class="comment">//second就是m的第二个参数，即第二个int</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> e.first;  <span class="comment">//同理，first是第一个int了</span></span><br><span class="line"></span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></int,int></p><p>方法二：当然，非常了解C++库中函数的人可能会想到一个非常简单的方法，利用STL中的算法count函数计数功能，三两行代码就能解决这个问题。利用出现次数超过总元素个数一半知道这个数一定会是中位数，当然，前提是这个数组有序。我们看下面的具体代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sort(gifts.begin(),gifts.end());</span><br><span class="line">        <span class="keyword">int</span> ret = count(gifts.begin(),gifts.end(),gifts[n/<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; n/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> gifts[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法三：在上面两种特殊方式做出的基础上，我们思考了用普通的算法来求解该问题，我们的思路是首先对数组里的数进行一个判断，找出出现次数最多的那个数，然后再对它进行计数判断。以下就是具体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gift = gifts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                gift = gifts[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;春节
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
