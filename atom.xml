<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuxiaoKun</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LiuZiQiao.github.io/"/>
  <updated>2019-02-13T09:01:35.509Z</updated>
  <id>https://LiuZiQiao.github.io/</id>
  
  <author>
    <name>LiuXiaoKun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>199.二叉树的右视图</title>
    <link href="https://LiuZiQiao.github.io/2019/02/13/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://LiuZiQiao.github.io/2019/02/13/199二叉树的右视图/</id>
    <published>2019-02-13T09:00:53.000Z</published>
    <updated>2019-02-13T09:01:35.509Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：与之前二叉树的层次遍历类似的，该问题需要用到队列,   </p><ul><li>建立一个queue</li><li>遍历每层的节点时，把下一层的节点都存入到queue中</li><li>每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://LiuZiQiao.github.io/categories/LeetCode/"/>
    
    
      <category term="二叉树" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>20.有效的括号</title>
    <link href="https://LiuZiQiao.github.io/2019/02/13/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://LiuZiQiao.github.io/2019/02/13/20-有效的括号/</id>
    <published>2019-02-13T08:17:18.000Z</published>
    <updated>2019-02-13T08:17:48.015Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。   </p><p>注意空字符串可被认为是有效字符串。 </p><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(]”<br> 输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: “([)]”<br>输出: false</p></blockquote><p>示例 5:</p><blockquote><p>输入: “{[]}”<br>输出: true</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; parentheses;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>||s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span>)</span><br><span class="line">                parentheses.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(parentheses.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>&amp;&amp; parentheses.top() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>&amp;&amp; parentheses.top() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>&amp;&amp; parentheses.top() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                parentheses.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parentheses.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://LiuZiQiao.github.io/categories/LeetCode/"/>
    
    
      <category term="stack" scheme="https://LiuZiQiao.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>网易2019实习模拟练习题</title>
    <link href="https://LiuZiQiao.github.io/2019/02/13/%E7%BD%91%E6%98%932019%E5%AE%9E%E4%B9%A0%E6%A8%A1%E6%8B%9F%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2019/02/13/网易2019实习模拟练习题/</id>
    <published>2019-02-13T07:43:21.000Z</published>
    <updated>2019-02-13T07:44:08.831Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="牛牛找工作"><a href="#牛牛找工作" class="headerlink" title="牛牛找工作"></a>牛牛找工作</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。</p><p>输入描述</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。<br>接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。<br>接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。<br>保证不存在两项工作的报酬相同。</p></blockquote><p>输出描述:   </p><blockquote><p>  对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。</p></blockquote><p>输入例子1:</p><blockquote><p>3 3<br>1 100<br>10 1000<br>1000000000 1001<br>9 10 1000000000   </p></blockquote><p>输出例子1:   </p><blockquote><p>   100<br>    1000<br>    1001</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">work</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> di;</span><br><span class="line">    <span class="keyword">int</span> pi;</span><br><span class="line">    work()</span><br><span class="line">    &#123;</span><br><span class="line">        di = <span class="number">0</span>;</span><br><span class="line">        pi = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ai;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    student()</span><br><span class="line">    &#123;</span><br><span class="line">        ai = <span class="number">0</span>;</span><br><span class="line">        id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortByPi</span><span class="params">(<span class="keyword">const</span> work &amp;w1, <span class="keyword">const</span> work &amp;w2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w1.di == w2.di)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w1.pi &gt; w2.pi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w1.di &lt; w2.di;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortByAi</span><span class="params">(<span class="keyword">const</span> student &amp;stu1, <span class="keyword">const</span> student &amp;stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stu1.ai &lt; stu2.ai;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;work&gt; vec_work(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; vec_student(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vec_work[i].di &gt;&gt; vec_work[i].pi;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec_work.begin(), vec_work.end(), sortByPi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vec_student[j].ai;</span><br><span class="line">        vec_student[j].id = j;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec_student.begin(), vec_student.end(), sortByAi);</span><br><span class="line">    <span class="keyword">int</span> worknum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_pi[<span class="number">101000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (worknum &lt; n &amp;&amp; vec_student[i].ai &gt;= vec_work[worknum].di)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(vec_work[worknum].pi, ans);</span><br><span class="line">            worknum++;</span><br><span class="line">        &#125;</span><br><span class="line">        max_pi[vec_student[i].id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_pi[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="被3整除"><a href="#被3整除" class="headerlink" title="被3整除"></a>被3整除</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。</p><p>并且小Q对于能否被3整除这个性质很感兴趣。</p><p>小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。</p><p>输入描述:</p><blockquote><p>输入包括两个整数l和r(1 &lt;= l &lt;= r &lt;= 1e9), 表示要求解的区间两端。</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数, 表示区间内能被3整除的数字个数。</p></blockquote><p>输入例子1:</p><blockquote><p>2 5</p></blockquote><p>输出例子1:</p><blockquote><p>3</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span>!=<span class="number">1</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安置路灯"><a href="#安置路灯" class="headerlink" title="安置路灯"></a>安置路灯</h3><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><p>小Q正在给一条长度为n的道路设计路灯安置方案。</p><p>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。</p><p>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。</p><p>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p><p>输入描述:</p><blockquote><p>输入的第一行包含一个正整数t(1 &lt;= t &lt;= 1000), 表示测试用例数<br>接下来每两行一个测试数据, 第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。<br>第二行一个字符串s表示道路的构造,只包含’.’和’X’。</p></blockquote><p>输出描述:</p><blockquote><p>对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。  </p></blockquote><p>输入例子1:</p><blockquote><p>2<br>3<br>.X.<br>11<br>…XX….XX   </p></blockquote><p>输出例子1:</p><blockquote><p>1<br> 3</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++num;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷路的牛牛"><a href="#迷路的牛牛" class="headerlink" title="迷路的牛牛"></a>迷路的牛牛</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。 </p><p>输入描述:</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含一个正整数，表示转方向的次数N(N&lt;=1000)。<br>接下来的一行包含一个长度为N的字符串，由L和R组成，L表示向左转，R表示向右转。   </p></blockquote><p>输出描述:</p><blockquote><p>输出牛牛最后面向的方向，N表示北，S表示南，E表示东，W表示西。</p></blockquote><p>输入例子1:</p><blockquote><p>3<br>LRR   </p></blockquote><p>输出例子1:</p><blockquote><p>E</p></blockquote><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> status = <span class="string">'N'</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">string</span> s=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = s[i];</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'N'</span>) &#123;status = <span class="string">'W'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'W'</span>) &#123;status = <span class="string">'S'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'S'</span>) &#123;status = <span class="string">'E'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'E'</span>) &#123;status = <span class="string">'N'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'N'</span>) &#123;status = <span class="string">'E'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'E'</span>) &#123;status = <span class="string">'S'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'S'</span>) &#123;status = <span class="string">'W'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'W'</span>) &#123;status = <span class="string">'N'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数对"><a href="#数对" class="headerlink" title="数对"></a>数对</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。</p><p>但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。<br>牛牛希望你能帮他计算一共有多少个可能的数对。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n*n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=k+<span class="number">1</span>;y&lt;=n;++y)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=n/y*(y-k);</span><br><span class="line">        <span class="keyword">if</span>(n%y&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=n%y-k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。</p><p>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。</p><p>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// square overlap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> left, right, up, down;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Square &amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> down &lt; x.down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leftto</span><span class="params">(Square a, Square b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.left &lt; b.left;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eraselower</span><span class="params">(<span class="built_in">vector</span>&lt;Square&gt; &amp;a, <span class="keyword">int</span> ybound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deln = <span class="number">0</span>, i = <span class="number">0</span>, n = a.size();</span><br><span class="line">    <span class="keyword">while</span>(i + deln &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].up&lt;=ybound)</span><br><span class="line">            swap(a[i], a[n-(++deln)]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.erase(a.end()-deln, a.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Square&gt; sqs(n), row;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].down;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].up;</span><br><span class="line">    sort(sqs.begin(), sqs.end());</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">0</span>, curdown = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sn&lt;n)</span><br><span class="line">   &#123;</span><br><span class="line">        curdown = sqs[sn].down;</span><br><span class="line">        <span class="keyword">while</span>(sn&lt;n &amp;&amp; sqs[sn].down == curdown)</span><br><span class="line">            row.push_back(sqs[sn++]);</span><br><span class="line">        eraselower(row, curdown);</span><br><span class="line">        sort(row.begin(), row.end(), leftto);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rights;</span><br><span class="line">        <span class="keyword">for</span>(Square x:row)</span><br><span class="line">        &#123;</span><br><span class="line">            rights.erase(rights.begin(), upper_bound(rights.begin(), rights.end(), x.left));</span><br><span class="line">            rights.insert(upper_bound(rights.begin(), rights.end(), x.right), x.right);</span><br><span class="line">            <span class="keyword">if</span>(res &lt; rights.size()) res = rights.size();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛牛的闹钟"><a href="#牛牛的闹钟" class="headerlink" title="牛牛的闹钟"></a>牛牛的闹钟</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床    </p><p>输入描述:</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N&lt;=100)。<br>接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0&lt;=A&lt;24)时Mi(0&lt;=B&lt;60)分。<br>接下来的一行包含一个整数，表示从起床算起他需要X(0&lt;=X&lt;=100)分钟到达教室。<br>接下来的一行包含两个整数，表示上课时间为A(0&lt;=A&lt;24)时B(0&lt;=B&lt;60)分。<br>数据保证至少有一个闹钟可以让牛牛及时到达教室。</p></blockquote><p>输出描述:</p><blockquote><p>输出两个整数表示牛牛最晚起床时间。</p></blockquote><p>输入例子1:</p><blockquote><p>3<br>5 0<br>6 0<br>7 0<br>59<br>6 59   </p></blockquote><p>输出例子1:</p><blockquote><p>6 0</p></blockquote><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> get[N];</span><br><span class="line">    <span class="keyword">int</span> hi,mi,x,goclass;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;hi&gt;&gt;mi;</span><br><span class="line">        get[i]=hi*<span class="number">60</span>+mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;hi&gt;&gt;mi;</span><br><span class="line">    goclass = hi * <span class="number">60</span> + mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (get[i] + x &lt;= goclass &amp;&amp; get[i] &gt; res)</span><br><span class="line">            res = get[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;res/<span class="number">60</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;res%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛牛的背包问题"><a href="#牛牛的背包问题" class="headerlink" title="牛牛的背包问题"></a>牛牛的背包问题</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p><p>输入描述:</p><blockquote><p>输入包括两行<br>第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量。<br>第二行n个正整数v<a href="0 &lt;= v[i] &lt;= 10^9">i</a>,表示每袋零食的体积。   </p></blockquote><p>输出描述:</p><blockquote><p>输出一个正整数, 表示牛牛一共有多少种零食放法。   </p></blockquote><p>输入例子1:</p><blockquote><p>3 10<br>1 2 4</p></blockquote><p>输出例子1:</p><blockquote><p>8</p></blockquote><p>例子说明1:</p><blockquote><p>三种零食总体积小于10,于是每种零食有放入和不放入两种情况，一共有2<em>2</em>2 = 8种情况。</p></blockquote><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nums = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> size , <span class="keyword">long</span> <span class="keyword">long</span> w, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        nums++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span> ; i &lt; size ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(<span class="built_in">array</span>,size,w,sum+<span class="built_in">array</span>[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n &gt;&gt; w;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; <span class="built_in">array</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i != n ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i];</span><br><span class="line">        total += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(total &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        nums = <span class="built_in">pow</span>(<span class="number">2</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sort(<span class="built_in">array</span>.begin(),<span class="built_in">array</span>.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i != n ; ++i)</span><br><span class="line">            DFS(<span class="built_in">array</span>, <span class="built_in">array</span>.size(), w, <span class="built_in">array</span>[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nums&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;牛牛找工作&quot;&gt;&lt;a href=&quot;#牛牛找工作&quot; class=&quot;headerlink&quot; title=&quot;牛牛找工作&quot;&gt;&lt;/a&gt;牛牛找
      
    
    </summary>
    
      <category term="模拟面试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="C++" scheme="https://LiuZiQiao.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>接雨水1</title>
    <link href="https://LiuZiQiao.github.io/2019/02/12/%E6%8E%A5%E9%9B%A8%E6%B0%B41/"/>
    <id>https://LiuZiQiao.github.io/2019/02/12/接雨水1/</id>
    <published>2019-02-12T15:41:12.000Z</published>
    <updated>2019-02-13T10:55:04.863Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。   </p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>,mx=<span class="number">0</span>,n = height.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = mx;</span><br><span class="line">            mx=max(mx,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i],mx);</span><br><span class="line">            mx = max(mx,height[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;height[i])</span><br><span class="line">                res += dp[i]-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,l=<span class="number">0</span>,r =height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = min(height[l],height[r]);</span><br><span class="line">            <span class="keyword">if</span>(mn == height[l])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp; height[l]&lt;mn)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += mn-height[l++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --r;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;height[r]&lt;mn)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += mn-height[r--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.size()<span class="number">-1</span>,level=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lower=height[(height[l]&lt;height[r])? l++:r--];</span><br><span class="line">            level = max(level,lower);</span><br><span class="line">            res+= level-lower;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>,n=height.size();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty()||height[i]&lt;=height[st.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(i++);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(st.empty()) <span class="keyword">continue</span>;</span><br><span class="line">                res+=(min(height[i],height[st.top()]) - height[t])*(i-st.top()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://LiuZiQiao.github.io/categories/LeetCode/"/>
    
    
      <category term="vector" scheme="https://LiuZiQiao.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>学学网络之Socket套接字</title>
    <link href="https://LiuZiQiao.github.io/2019/02/11/%E5%AD%A6%E5%AD%A6%E7%BD%91%E7%BB%9C%E4%B9%8BSocket%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://LiuZiQiao.github.io/2019/02/11/学学网络之Socket套接字/</id>
    <published>2019-02-11T14:37:56.000Z</published>
    <updated>2019-02-11T14:51:13.181Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。其本质为内核借助缓冲区形成的伪文件。因为我们常说，Linux下一切皆文件。<br>既然是文件，那么理所当然的，我们使用<code>文件描述符</code>引用套接字。与管道类似的，Linux系统将其封装成文件的<code>目的</code>是为了统一接口，使得读写套接字和读写文件的操作一致。<code>区别</code>是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。<br>套接字通信原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190211222541780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。<br>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。</p><p><img src="https://img-blog.csdnimg.cn/2019021122262628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2">   </p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。<br>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure><blockquote><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。<br>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p></blockquote><h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>早期：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure></p><pre><code>只能处理IPv4的ip地址不可重入函数注意参数是struct in_addr</code></pre><p>现在：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><pre><code>支持IPv4和IPv6可重入函数其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。因此函数接口是void *addrptr。</code></pre><h4 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h4><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="https://img-blog.csdnimg.cn/20190211222821652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family; <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>sudo grep -r &quot;struct sockaddr_in</code> {“  /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_sa_family_t</span> sin_family; <span class="comment">/* Address family */</span>  地址结构类型</span><br><span class="line">__be16 sin_port; <span class="comment">/* Port number */</span>端口号</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address */</span>IP地址</span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr'. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) -</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) - <span class="keyword">sizeof</span>(struct in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span><span class="comment">/* Internet address. */</span></span><br><span class="line">__be32 s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin6_family; <span class="comment">/* AF_INET6 */</span></span><br><span class="line">__be16 sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">__be32 sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 address */</span></span><br><span class="line">__u32 sin6_scope_id; <span class="comment">/* scope id (new in RFC2553) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__u8 u6_addr8[<span class="number">16</span>];</span><br><span class="line">__be16 u6_addr16[<span class="number">8</span>];</span><br><span class="line">__be32 u6_addr32[<span class="number">4</span>];</span><br><span class="line">&#125; in6_u;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr in6_u.u6_addr8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr16 in6_u.u6_addr16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr32 in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line"><span class="keyword">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock-addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void <em>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void </em>类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));<span class="comment">/* initialize servaddr */</span></span><br></pre></td></tr></table></figure></p><h3 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h3><p><img src="https://img-blog.csdnimg.cn/20190211222855352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p><h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domain:</span><br><span class="line">AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">传<span class="number">0</span> 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">成功：返回指向新创建的socket的文件描述符，失败：返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd：</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line"><span class="keyword">sizeof</span>(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>, 设置errno</span><br></pre></td></tr></table></figure><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。<br>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure></p><p>首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为==INADDR_ANY==，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p><h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">sockfd:</span><br><span class="line">socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">排队建立<span class="number">3</span>次握手队列和刚刚建立<span class="number">3</span>次握手队列的链接数和</span><br></pre></td></tr></table></figure><p>查看系统默认backlog</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入传出参数（值-结果）,传入<span class="keyword">sizeof</span>(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回一个新的socket文件描述符，用于和客户端通信，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。<br>我们的服务器程序结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">......</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p><h4 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入参数,传入<span class="keyword">sizeof</span>(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p><h3 id="C-S模型-TCP"><a href="#C-S模型-TCP" class="headerlink" title="C/S模型-TCP"></a>C/S模型-TCP</h3><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>下面通过最简单的客户端/服务器程序的实例来学习socket API。<br>server.c的作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(connfd, buf, n);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p>client.c的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">int</span> sockfd, n;</span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"usage: ./client message\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">str = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">write(sockfd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">n = read(sockfd, buf, MAXLINE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Response from server:\n"</span>);</span><br><span class="line">write(STDOUT_FILENO, buf, n);</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。注意，客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。<br>客户端和服务器启动后可以使用netstat命令查看链接情况：   </p><pre><code>netstat -apn|grep 6666</code></pre><h3 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h3><p>上面的例子不仅功能简单，而且简单到几乎没有什么错误处理，我们知道，系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。<br>为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块wrap.c：</p><h4 id="wrap-h"><a href="#wrap-h" class="headerlink" title="wrap.h"></a>wrap.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> my_read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr);</span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="wrap-c"><a href="#wrap-c" class="headerlink" title="wrap.c"></a>wrap.c</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(s);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ( (n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">nleft -= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read_ptr = read_buf;</span><br><span class="line">&#125;</span><br><span class="line">read_cnt--;</span><br><span class="line">*ptr = *read_ptr++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n, rc;</span><br><span class="line"><span class="keyword">char</span> c, *ptr;</span><br><span class="line">ptr = vptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">*ptr++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;套接字概念&quot;&gt;&lt;a href=&quot;#套接字概念&quot; class=&quot;headerlink&quot; title=&quot;套接字概念&quot;&gt;&lt;/a&gt;套接字
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="https://LiuZiQiao.github.io/2019/02/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>https://LiuZiQiao.github.io/2019/02/08/顺时针打印矩阵/</id>
    <published>2019-02-08T14:17:43.000Z</published>
    <updated>2019-02-09T14:15:52.604Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p><pre><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code></pre><p>则依次打印出数字</p><pre><code>1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> || col==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>,right = col<span class="number">-1</span>,bottom=row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top&lt;= bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i) </span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;++i) </span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span>(top != bottom)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=left;--i) </span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">            <span class="keyword">if</span>(left != right)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i= bottom<span class="number">-1</span>;i&gt;top;--i)</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">            left++,top++,right--,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://LiuZiQiao.github.io/2019/02/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://LiuZiQiao.github.io/2019/02/07/重建二叉树/</id>
    <published>2019-02-07T15:39:30.000Z</published>
    <updated>2019-02-07T15:40:08.321Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = vin.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left,pre_right, vin_left,vin_right;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[i+<span class="number">1</span>]);</span><br><span class="line">            vin_left.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-index<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[index+<span class="number">1</span>+i]);</span><br><span class="line">            vin_right.push_back(vin[index+<span class="number">1</span>+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        node-&gt;right = reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树的子结构</title>
    <link href="https://LiuZiQiao.github.io/2019/02/07/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>https://LiuZiQiao.github.io/2019/02/07/树的子结构/</id>
    <published>2019-02-07T15:32:17.000Z</published>
    <updated>2019-02-07T15:33:09.422Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = isSubtree(pRoot1,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>说说网络之名词解析</title>
    <link href="https://LiuZiQiao.github.io/2019/02/02/%E8%AF%B4%E8%AF%B4%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%90%8D%E8%AF%8D%E8%A7%A3%E6%9E%90/"/>
    <id>https://LiuZiQiao.github.io/2019/02/02/说说网络之名词解析/</id>
    <published>2019-02-02T14:49:29.000Z</published>
    <updated>2019-02-02T14:50:54.238Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>学习一些网络之后，发现存在对一些名词的含义还是记不住，因此作此文章来梳理网络中的一些关键名词。</p><h3 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a>网络名词术语解析</h3><h4 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a>路由(route)</h4><p>路由（名词）<br>数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。<br>路由（动词）<br>某个路由节点为数据包选择投递方向的选路过程。</p><h4 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h4><p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。   </p><p>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。   </p><p>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。   </p><p>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。   </p><p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</p><h3 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h3><p>路由表中的一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。</p><h3 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h3><p>路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。</p><h3 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a>路由节点</h3><p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p><h3 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。<br>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p><h3 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a>hub工作原理</h3><p>集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。<br>集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。其次是Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。<br>由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作：   </p><ul><li>第一步是将信息上传到上联设备；</li><li>第二步是上联设备再将该信息广播到所有端口上。<h3 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a>半双工/全双工</h3>Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。<br>Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3>DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。<br>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。<h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h3>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。</li></ul><ol><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</li><li>通信延迟时间短，可靠性较高</li><li>局域网可以支持多种传输介质<h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h3>wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。<br>覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。<br>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</li><li>适应大容量与突发性通信的要求；</li><li>适应综合业务服务的要求；</li><li>开放的设备接口与规范化的协议；</li><li>完善的通信服务与网络管理。<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3>逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li><li>端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。</li><li>客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</li><li>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。<br>我们应该在自定义端口时，避免使用well-known的端口。如：80、21等等。</li></ol><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU）<br>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。    </p><p>以下是一些协议的MTU：<br>FDDI协议：4352字节<br>以太网（Ethernet）协议：1500字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up/Modem）：576字节<br>Point-to-Point：4470字节   </p><h3 id="网络知识点的一些常见题"><a href="#网络知识点的一些常见题" class="headerlink" title="网络知识点的一些常见题"></a>网络知识点的一些常见题</h3><ol><li>TCP如何建立链接</li><li>TCP如何通信</li><li>TCP如何关闭链接</li><li>什么是滑动窗口</li><li>什么是半关闭</li><li>局域网内两台机器如何利用TCP/IP通信</li><li>internet上两台主机如何进行通信</li><li>如何在internet上识别唯一一个进程<br>答：通过“IP地址+端口号”来区分不同的服务</li><li>为什么说TCP是可靠的链接，UDP不可靠</li><li>路由器和交换机的区别</li><li>点到点，端到端</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;学习一些网络之后，发现存在对一些名词的含义还是记不住，因此作此文章来梳理网络中的一些关键名词。&lt;/p&gt;
&lt;h3 id=&quot;网络名词术语解析&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>再浅谈网络之“TCP协议”</title>
    <link href="https://LiuZiQiao.github.io/2019/01/31/%E5%86%8D%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9CTCP%E5%8D%8F%E8%AE%AE%E2%80%9D/"/>
    <id>https://LiuZiQiao.github.io/2019/01/31/再浅谈网络之“TCP协议”/</id>
    <published>2019-01-31T14:39:29.000Z</published>
    <updated>2019-02-02T11:47:44.528Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。<br><img src="https://img-blog.csdnimg.cn/20190202193733165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1">   </p><p>首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。   </p><h3 id="建立连接（三次握手）的过程："><a href="#建立连接（三次握手）的过程：" class="headerlink" title="建立连接（三次握手）的过程："></a>建立连接（三次握手）的过程：</h3><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。   </li><li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。   </li><li>客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为==三方握手（three-way-handshake）==。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</li></ol><h4 id="数据传输的过程："><a href="#数据传输的过程：" class="headerlink" title="数据传输的过程："></a>数据传输的过程：</h4><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据。</li><li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</li></ol><h3 id="关闭连接（四次挥手）的过程："><a href="#关闭连接（四次挥手）的过程：" class="headerlink" title="关闭连接（四次挥手）的过程："></a>关闭连接（四次挥手）的过程：</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端发出段7，FIN位表示关闭连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求。</li><li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</li><li>客户端发出段10，应答服务器的关闭连接请求。<br>建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</li></ol><h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口 (TCP流量控制)"></a>滑动窗口 (TCP流量控制)</h3><p>UDP传输的时候描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过<code>滑动窗口（Sliding Window)</code>机制解决这一问题。看下图的通讯过程：<br><img src="https://img-blog.csdnimg.cn/20190202193849279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ol><li>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li><li>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li><li>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</li><li>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li><li>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</li><li>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</li><li>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li><li>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</li><li>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。<br>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。<br>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。<h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3></li></ol><p><img src="https://img-blog.csdnimg.cn/20190202194033294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"><br><strong>CLOSED</strong>：表示初始状态。<br><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。<br><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。<br><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。<br><strong>ESTABLISHED</strong>：表示连接已经建立。<br><strong>FIN_WAIT_1</strong>:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：<br>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。<br>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。<br><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。<br><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。<br><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。<br><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure></p><p>使用close中止一个连接，它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。<br>shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 </li><li>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信，如果一个进程close(sfd)将不会影响到其它进程。</li></ol><h4 id="2MSL-Maximum-Segment-Lifetime"><a href="#2MSL-Maximum-Segment-Lifetime" class="headerlink" title="2MSL(Maximum Segment Lifetime)"></a>2MSL(Maximum Segment Lifetime)</h4><p> TIME_WAIT状态的存在有两个理由：   </p><ul><li>让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。   </li><li>防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</li></ul><h4 id="程序设计中出现的问题"><a href="#程序设计中出现的问题" class="headerlink" title="程序设计中出现的问题"></a>程序设计中出现的问题</h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure></p><p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">1</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       CLOSE_WAIT  <span class="number">3525</span>/client     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      FIN_WAIT2   -</span><br></pre></td></tr></table></figure><p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。<br>现在用Ctrl-C把client也终止掉，再观察现象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38104</span>      TIME_WAIT   -</span><br><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。==TCP协议规定==，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。<br>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。</p><h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:8888）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:8888），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。<br>在server代码的socket()和bind()调用之间插入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a>TCP异常断开</h3><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。<br><strong>Heart-Beat线程:</strong><br>这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。<br>该方法的==好处是通用==，但缺点就是==会改变现有的通讯协议==！大家一般都是使用业务层心跳来处理，主要是灵活可控。<br>UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p><h4 id="设置TCP属性"><a href="#设置TCP属性" class="headerlink" title="设置TCP属性"></a>设置TCP属性</h4><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持==存活探测分节==(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。&lt;br&gt;&lt;img src=&quot;https://img-b
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>再谈网络之“协议格式”</title>
    <link href="https://LiuZiQiao.github.io/2019/01/30/%E5%86%8D%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9C%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E2%80%9D/"/>
    <id>https://LiuZiQiao.github.io/2019/01/30/再谈网络之“协议格式”/</id>
    <published>2019-01-30T13:27:30.000Z</published>
    <updated>2019-01-30T13:28:02.614Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上一篇中是有关网络的设计模式和分层模型，这篇就来说说网络里面用到的几个重要协议的格式，用程序员来的话来说就是报头格式。当然，在进入主题之前，先了解下通信的过程。</p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p><strong>两台计算机通过TCP/IP协议通讯的过程如下所示：</strong><br><img src="https://img-blog.csdnimg.cn/2019013021170727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</strong><br><img src="https://img-blog.csdnimg.cn/20190130211750435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ul><li>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。   </li><li>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。   </li><li>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。   </li><li>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说 的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。   </li><li>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。   </li><li>那么目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211851391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></li><li>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</li><li>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</li></ul><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><h3 id="数据表封装"><a href="#数据表封装" class="headerlink" title="数据表封装"></a>数据表封装</h3><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（也就是我们常说的socket编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211956396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网的帧格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212040538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"></p><p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，<code>HWaddr 00:15:F2:14:9E:3F</code>部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行<code>分片</code>（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p><p><strong>上面说到的分片？为什么要分片？如何分片？</strong></p><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须==获得目的主机的硬件地址==。==ARP协议就起到这个作用==。例如：源主机发出ARP请求，询问“IP地址是<code>192.168.0.1</code>的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。<br>每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。<br><strong>为什么表项要有过期时间而不是一直有效？</strong></p><p>ARP数据报的格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212121578.png" alt="6"></p><p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为==1表示ARP请求==，op字段为==2表示ARP应答==。</p><p><strong>源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</strong></p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212157821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="6"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p><p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212215315.png" alt="8"></p><p>UDP首部：源端口号是客户端的端口号，目的端口号是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</p><h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212243418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="9"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小等。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，关于SYN、ACK、FIN、RST四个位，会在后面的文章里详细解释，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。</p><p>以上为网络协议的格式介绍，协议相关的具体内容将在后面的文章里介绍。欢迎大家关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;上一篇中是有关网络的设计模式和分层模型，这篇就来说说网络里面用到的几个重要协议的格式，用程序员来的话来说就是报头格式。当然，在进入主题之前
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>谈谈网络之设计模式与分层模型</title>
    <link href="https://LiuZiQiao.github.io/2019/01/30/%E8%B0%88%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://LiuZiQiao.github.io/2019/01/30/谈谈网络之设计模式与分层模型/</id>
    <published>2019-01-30T05:18:09.000Z</published>
    <updated>2019-01-30T05:18:36.214Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型</p><h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p><strong>优缺点：</strong> 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<code>提高数据传输效率。</code>且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所<code>采用的协议相对灵活。</code>可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。<br>    因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br>    C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。<code>工作量</code>将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<code>安全性</code>构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>    B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其<code>工作开发量较小</code>。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br>    B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<code>缓存数据不尽如人意</code>，从而<code>传输数据量受到限制</code>。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，<code>协议选择不灵活</code>。<br>    因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="https://img-blog.csdnimg.cn/20190130131007694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li><li>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li><li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li></ol><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190130131054219.png" alt="2"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。但也有一些自定义协议类型，只是在其之上进行一些修改完成需求功能即可的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型&lt;/p&gt;
&lt;h3 id=&quot;网络应用程序设计模式&quot;&gt;&lt;a href=&quot;#网络
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/二叉搜索树的第k个结点/</id>
    <published>2019-01-24T15:04:05.000Z</published>
    <updated>2019-01-24T15:05:40.441Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = KthNode(pRoot-&gt;left,k);</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            index++;  </span><br><span class="line">            <span class="keyword">if</span>(index == k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot-&gt;right,k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>“三次握手，四次挥手”你真的懂吗？</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/“三次握手，四次挥手”你真的懂吗？/</id>
    <published>2019-01-24T04:30:19.000Z</published>
    <updated>2019-01-24T04:31:02.327Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是”三次握手，四次挥手“"><a href="#什么是”三次握手，四次挥手“" class="headerlink" title="什么是”三次握手，四次挥手“"></a>什么是”三次握手，四次挥手“</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用3次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p><img src="https://img-blog.csdnimg.cn/20190124115039196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>三次握手和四次挥手的状态转换如下图<br><img src="https://img-blog.csdnimg.cn/20190124115225958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h4 id="“三次握手，四次挥手”是怎么完成的？"><a href="#“三次握手，四次挥手”是怎么完成的？" class="headerlink" title="“三次握手，四次挥手”是怎么完成的？"></a>“三次握手，四次挥手”是怎么完成的？</h4><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。<br><img src="https://img-blog.csdnimg.cn/20190124115513655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p><h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://img-blog.csdnimg.cn/20190124115650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p></li><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p></li></ol><h4 id="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h3 id="”三次握手，四次挥手“进阶"><a href="#”三次握手，四次挥手“进阶" class="headerlink" title="”三次握手，四次挥手“进阶"></a>”三次握手，四次挥手“进阶</h3><h4 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p><p>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h4 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h4><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h5 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h5><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h5 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h5><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h5><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。<br><img src="https://img-blog.csdnimg.cn/20190124122642462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"><br>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><p>查看是否有连接溢出 <code>netstat -s | grep LISTEN</code></p><h5 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h5><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><h5 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h5><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><code>netstat -s</code>命令</p><p>[root@server ~]# netstat -s | grep “listen|LISTEN” </p><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><p>[root@server ~]# netstat -s | grep TCPBacklogDrop </p><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><p>[root@server ~]# ss -lnt</p><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;什么是”三次握手，四次挥手“&quot;&gt;&lt;a href=&quot;#什么是”三次握手，四次挥手“&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="TCP" scheme="https://LiuZiQiao.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装更新git的正确打开方式</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0git%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7安装更新git的正确打开方式/</id>
    <published>2019-01-03T08:52:12.000Z</published>
    <updated>2019-01-03T08:54:13.402Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">1</a></p><p>安装centos7 之后一直用自带的git，在提交的时候总是出现下面这种情况，原因是git版本太低导致的，于是就想了办法去更新git，<br>百度看了很多教程，都是什么先卸载再重新安装，卸载之前还需要备份一份配置文件，看了很多感觉非常麻烦，于是就在Linux网站中看到了一个最正确的更新及安装方式。以下是记录我更新安装过程。</p><h3 id="配置存储库"><a href="#配置存储库" class="headerlink" title="配置存储库"></a>配置存储库</h3><p>在这之前，我们需要在root权限下才可以进一步操作。<br>1.启用Wandisco GIT存储库<br>启用存储库需要在/etc/yum.repos.d/目录中命名的新yum存储库配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/wandisco-git.repo</span><br></pre></td></tr></table></figure></p><p>添加以下字段，ESC，然后:输入wq保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><p>使用以下命名了导入存储库GPG密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>完成之后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p><p>输出<code>git version 2.18.0</code></p><h3 id="验证配置文件更改"><a href="#验证配置文件更改" class="headerlink" title="验证配置文件更改"></a>验证配置文件更改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Your Name</span><br><span class="line">user.email=youremail@yourdomain.com</span><br></pre></td></tr></table></figure></p><p>配置设置存储在~/.gitconfig文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = youremail@yourdomain.com</span><br></pre></td></tr></table></figure><p>要进一步更改Git配置，可以使用git config命令或~/.gitconfig手动编辑文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-proc
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="git centos" scheme="https://LiuZiQiao.github.io/tags/git-centos/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装vscode</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7环境下安装vscode/</id>
    <published>2019-01-02T16:00:47.000Z</published>
    <updated>2019-01-02T16:01:07.936Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了CentOS7下安装过程。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>环境参数：<br>操作系统版本：CentOS-7-x86_64-1511<br>软件版本：visual stdio code 1.2   </p><p>操作步骤：<br>1.下载 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode_x86_64.rpm</a><br>2.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>可能会报这样一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libXss.so.1()(64bit) is needed by code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libXss*  -y</span><br></pre></td></tr></table></figure></p><p>然后在重新安装rpm文件，没报错可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>然后打开应用程序可以看见vscode安装好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了Cen
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装Chrome</title>
    <link href="https://LiuZiQiao.github.io/2019/01/02/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Chrome/"/>
    <id>https://LiuZiQiao.github.io/2019/01/02/CentOS7环境下安装Chrome/</id>
    <published>2019-01-02T15:01:15.000Z</published>
    <updated>2019-01-02T15:38:50.065Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>下载Chrome浏览器的rpm包（<a href="https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）" target="_blank" rel="noopener">https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）</a><br>利用xshell连接好Linux，使用命令rz，弹出选择窗口，将下载好的包上传进去，然后进入包目录，使用rpm命令进行安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>当然，这里需要切换到root用户下才可以执行。<br>执行完命令后会出现错误<br><img src="https://img-blog.csdnimg.cn/20190102230011852.png" alt="1"></p><p>出现这个错误是因为少了redhat-lsb这个依赖</p><p>安装readhat-lsb依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  redhat-lsb</span><br></pre></td></tr></table></figure></p><p>安装完上面的lsb依赖后，再来执行chrome安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>至此Chrome就安装完毕了，打开 应用程序 》互联网 就会发现Chrome的图标了</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>在以上正常的安装方式中， 我安装失败了，原因是我的key无法更新，于是我就选择了另外一种在线安装。以下记录了在线安装的过程。仅供参考，大佬勿喷。   </p><h4 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h4><p>在/etc/yum.repos.d/目录下新建文件google-chrome.repo，向其中添加如下内容:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[google-chrome]</span><br><span class="line">name=google-chrome</span><br><span class="line">baseurl=http:<span class="comment">//dl.google.com/linux/chrome/rpm/stable/$basearch</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//dl-ssl.google.com/linux/linux_signing_key.pub</span></span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable</span><br></pre></td></tr></table></figure></p><p>注：Google官方源在国内可能无法正常访问，导致安装失败或安装后无法正常更新，可以尝试添加–nogpgcheck参数再安装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable --nogpgcheck</span><br></pre></td></tr></table></figure></p><p>或者可以尝试修改gpgcheck=0再安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Linux下静态链接库出现的问题</title>
    <link href="https://LiuZiQiao.github.io/2018/12/31/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2018/12/31/解决Linux下静态链接库出现的问题/</id>
    <published>2018-12-31T13:04:57.000Z</published>
    <updated>2018-12-31T13:05:49.081Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我们用Makefile工具时，在Makefile文件中写编译语句时，希望编译时用静态链接库来编译，例如语句如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o $@ $^ -<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>编译时链接静态库的方式有好几种，这里我使用static。问题出现的是，当我们make时，出现如下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test test.cpp -<span class="keyword">static</span></span><br><span class="line">/usr/bin/ld: cannot find -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lm</span><br><span class="line">/usr/bin/ld: cannot find -lc</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">make: *** [tcpClient] Error <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在我百度了很久之后CSDN未能解决如下问题，还是Stack Overflow解决了该问题。<br>用如下两条命令安装所需要的静态库即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libstdc++-<span class="keyword">static</span></span><br><span class="line">sudo yum install glibc-<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>安装了以上两个库之后，make一下，编译成功，使用<code>ll</code>查看你会发现编译之后的目标文件会非常大。这时就是成功的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的几款内存泄漏检测工具</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/Linux%E4%B8%8B%E7%9A%84%E5%87%A0%E6%AC%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/Linux下的几款内存泄漏检测工具/</id>
    <published>2018-12-24T13:31:00.000Z</published>
    <updated>2018-12-24T13:38:51.473Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme/article/details/51959654" target="_blank" rel="noopener">原文链接</a></p><p>Linux下编写C或者C++程序，有很多工具，但是主要编译器仍然是gcc和g++。最近用到STL中的List编程，为了检测写的代码是否会发现内存泄漏，了解了一下相关的知识。</p><p>所有使用动态内存分配(dynamic memory allocation)的程序都有机会遇上内存泄露(memory leakage)问题，在Linux里有三种常用工具来检测内存泄露的情況，包括：</p><p>参见 <a href="http://elinux.org/Memory_Debuggers" rel="nofollow" target="_blank">http://elinux.org/Memory_Debuggers</a> <br><br>偶然发现的<a href="http://blog.163.com/zhuang_qianxin/blog/static/29765138201051092529107/" rel="nofollow" target="_blank">内存泄露检测工具比较 </a></p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">工具</th><br>  <th align="center">描述</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#valgrind" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center">一个强大开源的程序检测工具</td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#mtrace" rel="nofollow" target="_blank">mtrace</a></td><br>  <td align="center">GNU扩展, 用来跟踪malloc, mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数</td><br></tr><br><tr><br>  <td align="center"><a href="" rel="nofollow" target="_blank">dmalloc</a></td><br>  <td align="center">用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存,以一个运行库的方式发布</td><br></tr><br><tr><br>  <td align="center">memwatch</td><br>  <td align="center">和dmalloc一样，它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域</td><br></tr><br><tr><br>  <td align="center"><a href="http://mpatrol.sourceforge.net/" rel="nofollow" target="_blank">mpatrol</a></td><br>  <td align="center"><a href="http://www.ibm.com/developerworks/cn/linux/l-mleak2/" rel="nofollow" target="_blank">一个跨平台的 C++ 内存泄漏检测器</a></td><br></tr><br><tr><br>  <td align="center"><a href="http://dbgmem.sourceforge.net/" rel="nofollow" target="_blank">dbgmem</a></td><br>  <td align="center"></td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Electric_Fence" rel="nofollow" target="_blank">Electric Fence</a></td><br>  <td align="center"></td><br></tr><br></tbody></table></div><h1 id="1-被测程序"><a name="t0"></a>1  被测程序</h1><hr><p class="cye-lm-tag">为了方便测试,,我们编写了一个简单的程序, 循环10次每次申请了一个100个字节的单元, 但是却不释放</p><h1 id="2-valgrind"><a name="t1"></a>2  valgrind</h1><hr><h2 id="21-valgrind介绍"><a name="t2"></a>2.1   valgrind介绍</h2><hr><p class="cye-lm-tag">是不是说没有一种内存检查工具能够在Linux使用呢，也不是，像开源的valgrind工具还是相当不错的</p><ul><br><li><p class="cye-lm-tag">Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p></li><br><li><p class="cye-lm-tag">Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p></li><br><li><p class="cye-lm-tag">Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p></li><br><li><p class="cye-lm-tag">Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p></li><br><li><p class="cye-lm-tag">Massif。它主要用来检查程序中堆栈使用中出现的问题。</p></li><br><li><p class="cye-lm-tag">Extension。可以利用core提供的功能，自己编写特定的内存调试工具</p></li><br></ul><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">主页</th><br>  <th align="center">下载</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://valgrind.org/" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center"><a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">downloads</a></td><br></tr><br></tbody></table></div><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719211251895" alt="valgrind介绍" title=""></p><blockquote><br>  <p class="cye-lm-tag">参照</p><br><br>  <p class="cye-lm-tag"><a href="http://www.cnblogs.com/sunyubo/archive/2010/05/05/2282170.html" rel="nofollow" target="_blank">Valgrind简单用法</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">Unix下C程序内存泄漏检测工具Valgrind安装与使用</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">valgrind 的使用简介</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" rel="nofollow" target="_blank">应用 Valgrind 发现 Linux 程序的内存问题</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.oschina.net/translate/valgrind-memcheck" rel="nofollow" target="_blank">如何使用Valgrind memcheck工具进行C/C++的内存泄漏检测</a></p><br></blockquote><h2 id="22-安装"><a name="t3"></a>2.2   安装</h2><hr><p class="cye-lm-tag"><strong>源码安装</strong></p><p class="cye-lm-tag">到<a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">下载地址</a>)下载最新版的valgrind,按照里面的README提示，安装后就可以使用这个工具来检测内存泄露和内存越界等</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">/configuremakesudo make install<p class="cye-lm-tag">当然也可以使用发行版的自带的源中安装</p>sudo apt install valgrind这是一个没有界面的内存检测工具，安装后，输入 valgrind ls -l 验证一下该工具是否工作正常（这是README里面的方法，实际上是验证一下对ls -l命令的内存检测），如果你看到一堆的信息说明你的工具可以使用了。<h2 id="23-使用说明"><a name="t4"></a>2.3   使用说明</h2><hr><p class="cye-lm-tag">Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif。</p><p class="cye-lm-tag"><strong>Memcheck</strong></p><p class="cye-lm-tag">最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，Memcheck 工具主要检查下面的程序错误</p><div class="table-box"><table><thead><tr>  <th align="center">内容</th>  <th align="center">描述</th></tr></thead><tbody><tr>  <td align="center">使用未初始化的内存</td>  <td align="center">Use of uninitialised memory</td></tr><tr>  <td align="center">使用已经释放了的内存</td>  <td align="center">Reading/writing memory after it has been free’d</td></tr><tr>  <td align="center">使用超过 malloc分配的内存空间</td>  <td align="center">Reading/writing off the end of malloc’d blocks</td></tr><tr>  <td align="center">对堆栈的非法访问</td>  <td align="center">Reading/writing inappropriate areas on the stack</td></tr><tr>  <td align="center">申请的空间是否有释放</td>  <td align="center">Memory leaks – where pointers to malloc’d blocks are lost forever</td></tr><tr>  <td align="center">malloc/free/new/delete申请和释放内存的匹配</td>  <td align="center">Mismatched use of malloc/new/new [] vs free/delete/delete []</td></tr><tr>  <td align="center">src和dst的重叠</td>  <td align="center">Overlapping src and dst pointers in memcpy() and related functions</td></tr></tbody></table></div><p class="cye-lm-tag">这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。 </p><p class="cye-lm-tag"><strong>Callgrind</strong></p><p class="cye-lm-tag">和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 </p><p class="cye-lm-tag"><strong>Cachegrind</strong></p><p class="cye-lm-tag">Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 </p><p class="cye-lm-tag"><strong>Helgrind</strong></p><p class="cye-lm-tag">它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 </p><p class="cye-lm-tag"><strong>Massif</strong></p><p class="cye-lm-tag">堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 </p><blockquote>  <p class="cye-lm-tag">此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具</p>  <p class="cye-lm-tag"><strong>注意</strong></p>  <p class="cye-lm-tag">Valgrind不检查静态分配数组的使用情况</p>  <p class="cye-lm-tag">Valgrind占用了更多的内存–可达两倍于你程序的正常使用量</p>  <p class="cye-lm-tag">如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试</p></blockquote><h2 id="24-使用说明"><a name="t5"></a>2.4   使用说明</h2><hr><p class="cye-lm-tag">编译程序</p>g++ -g -o leak leak.c <p class="cye-lm-tag">被检测程序加入 –g   -fno-inline 编译选项保留调试信息, 否则后面的valgrind不能显示到出错行号。</p>valgrind被设计成非侵入式的，它直接工作于可执行文件上，因此在检查前不需要重新编译、连接和修改你的程序。要检查一个程序很简单，只需要执行下面的命令就可以了。valgrind --tool=tool_name program_name比如我们要对ls -l命令做内存检查，只需要执行下面的命令就可以了<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck ls -l</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><blockquote><br>  <p class="cye-lm-tag">小提示 <br><br>  如果不知道有哪些参数, 可以先输入valgrind –tool=, 然后狂按两次tab, 会输出linux系统的只能提示, 同样,如果你输入了valgrind –tool=mem再狂按两次tab,linux系统会为你自动补全</p><br></blockquote><h2 id="25-使用valgrind检测memcheck"><a name="t6"></a>2.5   使用valgrind检测Memcheck</h2><hr><p class="cye-lm-tag">下面我们就可以用valgrind对我们的程序检测leak</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes    ./leak</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag">其中–leak-check=full 指的是完全检查内存泄漏，</p><p class="cye-lm-tag">–show-reachable=yes是显示内存泄漏的地点，</p><p class="cye-lm-tag">–trace-children=yes是跟入子进程。</p><p class="cye-lm-tag">当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理：</p><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719210756831" alt="输出内存泄漏的信息原" title=""></p><h1 id="3-mtrace检测内存泄露"><a name="t7"></a>3  mtrace检测内存泄露</h1><hr><h2 id="31-mtrace简介"><a name="t8"></a>3.1   mtrace简介</h2><hr><p class="cye-lm-tag">在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace. </p><p class="cye-lm-tag">mtrace其实是GNU扩展函数，用来跟踪malloc。</p><p class="cye-lm-tag">mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。 <br><br>在程序中，这些trace信息可以被用来发现内存泄漏和释放不是申请的内存。 <br><br>当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。 <br><br>如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。</p><p class="cye-lm-tag">详细说明可参考man page：man 3 mtrace</p><h2 id="32-mtrace使用"><a name="t9"></a>3.2   mtrace使用</h2><hr><p class="cye-lm-tag">mtrace能监测程序是否内存泄露</p><ul><br><li>在程序的起始处包含头文件</li></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-preprocessor cye-lm-tag">#include &lt;mcheck.h&gt;</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>更改环境变量：export   MALLOC_TRACE=”mtrace.out”可以加入如下代码</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">setenv(<span class="hljs-string cye-lm-tag">"MALLOC_TRACE"</span>, <span class="hljs-string cye-lm-tag">"mtrace.out"</span>, <span class="hljs-number cye-lm-tag">1</span>);</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>调用函数mtrace()</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace()</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>编译程序带上 -g 选项</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">gcc -g -c leak_mtrace.c -o leak_mtrace.o  -<span class="hljs-built_in cye-lm-tag">std</span>=gnu9x -Wall</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">./leak_mtrace </code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>mtrace a.out  mtrace.out查看内存监测情况</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace a.out  mtrace.out</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719214131721" alt="这里写图片描述" title=""></p><h1 id="4-dmalloc"><a name="t10"></a>4  dmalloc</h1><hr><p class="cye-lm-tag">dmalloc是一种用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存，并且能够精确指出在哪个源文件的第几行。</p><h1 id="5-linux内核的kmemleak"><a name="t11"></a>5  Linux内核的Kmemleak</h1><h2 id="51-kmemleak检测工具介绍"><a name="t12"></a>5.1   Kmemleak检测工具介绍</h2><hr><p class="cye-lm-tag">Kmemleak工作于内核态是内核自带的内核泄露检测工具, 其源代码位于<a href="http://lxr.free-electrons.com/source/mm/kmemleak.c?v4.7" rel="nofollow" target="_blank">mm/kmemleak.c</a></p><p class="cye-lm-tag">Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，其方法类似于跟踪内存收集器。当独立的对象没有被释放时，其报告记录在 /sys/kernel/debug/kmemleak中，Kmemcheck能够帮助定位大多数内存错误的上下文。</p><h2 id="52-kmemleak使用过程概述"><a name="t13"></a>5.2   Kmemleak使用过程概述</h2><ul><br><li><p class="cye-lm-tag">首先`CONFIG_DEBUG_KMEMLEAK在Kernel hacking中被使能.</p></li><br><li><p class="cye-lm-tag">查看内核打印信息详细过程如下：</p><br><br><ol><li>挂载debugfs文件系统 <br><br>mount -t debugfs nodev /sys/kernel/debug/</li><br><li>开启内核自动检测线程 <br><br>echo scan &gt; /sys/kernel/debug/kmemleak</li><br><li>查看打印信息 <br><br>cat /sys/kernel/debug/kmemleak</li><br><li>清除内核检测报告，新的内存泄露报告将重新写入/sys/kernel/debug/kmemleak <br><br>echo clear &gt; /sys/kernel/debug/kmemleak</li></ol></li><br></ul><p class="cye-lm-tag">内存扫描参数可以进行修改通过向/sys/kernel/debug/kmemleak 文件写入。 参数使用如下</p><pre class="prettyprint" name="code"><code class="language-cpp hljs  has-numbering">off 禁用kmemleak（不可逆）<span class="hljs-built_in cye-lm-tag">stack</span>=on 启用任务堆栈扫描(<span class="hljs-keyword cye-lm-tag">default</span>)<span class="hljs-built_in cye-lm-tag">stack</span>=off 禁用任务堆栈扫描scan=on 启动自动记忆扫描线程(<span class="hljs-keyword cye-lm-tag">default</span>)scan=off 停止自动记忆扫描线程scan=&lt;secs&gt; 设置n秒内自动记忆扫描scan 开启内核扫描clear 清除内存泄露报告dump=&lt;addr&gt; 转存信息对象在&lt;addr&gt;</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p class="cye-lm-tag">通过“kmemleak = OFF”，也可以在启动时禁用Kmemleak在内核命令行。在初始化kmemleak之前，内存的分配或释放这些动作被存储在一个前期日志缓冲区。这个缓冲区的大小通过配CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE设置。 </p><h2 id="53-kmemleak动态检测原理"><a name="t14"></a>5.3   Kmemleak动态检测原理</h2><hr><p class="cye-lm-tag">通过的kmalloc、vmalloc、kmem_cache_alloc等内存分配会跟踪其指针，连同其他的分配大小和堆栈跟踪信息，存储在PRIO搜索树。相应的释放函数调用跟踪和指针就会从kmemleak数据结构中移除。 <br><br>分配的内存块，被认为是独立的，如果没有指针指向它起始地址或块的内部的任何位置，可以发现扫描内存（包括已保存的寄存器）。这意味着，有可能没有办法为内核通过所分配的地址传递块到一个释放函数，因此，该块被认为是一个内存泄漏。</p><p class="cye-lm-tag">扫描算法步骤： <br><br>1.  标记的所有分配对象为白色（稍后将剩余的白色物体考虑独立的）</p><ol><br><li><p class="cye-lm-tag">扫描存储器与所述数据片段和栈开始，检查对地址的值存储在PRIO搜索树。如果一个白色的对象的指针被发现，该对象将被添加到灰名单</p></li><br><li><p class="cye-lm-tag">扫描的灰色对象匹配的地址（一些白色物体可以变成灰色，并添加结束时的灰名单），直到黑色集结束</p></li><br><li><p class="cye-lm-tag">剩下的白色物体被认为是独立儿，并报告写入/sys/kernel/debug/kmemleak。 <br><br>一些分配的内存块的指针在内核的内部数据结构和它们不能被检测为孤儿。对避免这种情况，kmemleak也可以存储的数量的值，指向一个内的块的地址范围内的地址，需要找到使块不被认为是泄漏.</p></li><br></ol><h2 id="54-kmem相关函数"><a name="t15"></a>5.4   kmem相关函数</h2><hr><p class="cye-lm-tag">从kernel源代码中的目录<code>include /linux/kmemleak.h</code>中可查看函数原型的头</p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">函数</th><br>  <th align="center">功能</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center">kmemleak_init</td><br>  <td align="center">初始化kmemleak</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc</td><br>  <td align="center">一个内存块分配的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_percpu</td><br>  <td align="center">通知的一个percpu的内存块分配</td><br></tr><br><tr><br>  <td align="center">kmemleak_free</td><br>  <td align="center">通知的内存块释放</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_part</td><br>  <td align="center">通知释放部分内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_percpu</td><br>  <td align="center">一个percpu内存块释放的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_not_leak</td><br>  <td align="center">当不是泄露时，标记对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_ignore</td><br>  <td align="center">当泄漏时不扫描或报告对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_scan_area</td><br>  <td align="center">添加扫描区域内的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_no_scan</td><br>  <td align="center">不扫描的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_erase</td><br>  <td align="center">删除一个指针变量的旧值</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_recursive</td><br>  <td align="center">为kmemleak_alloc，只检查递归</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_recursive</td><br>  <td align="center">为kmemleak_free，只检查递归</td><br></tr><br></tbody></table></div>            <br>                        <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"><br>                </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>window双系统Deepin安装及正确删除</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/window%E5%8F%8C%E7%B3%BB%E7%BB%9FDeepin%E5%AE%89%E8%A3%85%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/window双系统Deepin安装及正确删除/</id>
    <published>2018-12-24T13:18:34.000Z</published>
    <updated>2018-12-24T13:34:11.549Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://blog.csdn.net/qq_39478237/article/details/85239249" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39478237/article/details/85239249&quot; 
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>
