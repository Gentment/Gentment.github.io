<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuxiaoKun</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LiuZiQiao.github.io/"/>
  <updated>2019-04-22T09:45:39.038Z</updated>
  <id>https://LiuZiQiao.github.io/</id>
  
  <author>
    <name>LiuXiaoKun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【LeetCode】5.最长回文子串</title>
    <link href="https://LiuZiQiao.github.io/2019/04/22/%E3%80%90LeetCode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://LiuZiQiao.github.io/2019/04/22/【LeetCode】5-最长回文子串/</id>
    <published>2019-04-22T09:45:01.000Z</published>
    <updated>2019-04-22T09:45:39.038Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;</code></pre><p>注意: “aba” 也是一个有效答案。<br>示例 2：</p><pre><code>输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p><strong>常见错误</strong></p><p>有些人会忍不住提出一个快速的解决方案，不幸的是，这个解决方案有缺陷(但是可以很容易地纠正)：</p><pre><code>反转S，使之变成S′。找到S 和S′   之间最长的公共子串，这也必然是最长的回文子串。</code></pre><p>这似乎是可行的，让我们看看下面的一些例子。</p><pre><code>例如，S = “caba”, S&apos; = “abac”；S 以及S′之间的最长公共子串为“aba”，恰恰是答案。尝试一下这个例子：S= “abacdfgdcaba”,                S&apos; = “abacdgfdcaba”；S 以及 S′之间的最长公共子串为 “abacd” “abacd”，显然，这不是回文。</code></pre><p>当 SS 的其他部分中存在非回文子串的反向副本时，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这给我们提供了一个复杂度为 O(n^2) 动态规划解法，它将占用 O(n^2)的空间（可以改进为使用 O(n) 的空间）。    </p><h3 id="思路二-（动态规划）"><a href="#思路二-（动态规划）" class="headerlink" title="思路二 （动态规划）"></a>思路二 （动态规划）</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑<code>“ababa”</code> 这个示例。如果我们已经知道<code>“bab”</code>是回文，那么很明显，<code>“ababa”</code>一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j)P(i,j) 的定义如下：</p><p>如果子串是回文子串其他情况<br>$$f(i,j)=<br>\begin{cases}<br>true&amp; \text{如果子串Si…Sj是回文子串}\<br>false&amp; \text{其他情况}<br>\end{cases}$$</p><p>因此，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(i,j) = (P(i+1,j-1) and S_i==S_j)</span><br></pre></td></tr></table></figure></p><p>基本示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(i,j) = true; </span><br><span class="line"></span><br><span class="line">P(i,i+1) = (S_i == S_i+_1)</span><br></pre></td></tr></table></figure></p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><p>复杂度分析</p><p>时间复杂度：<code>O(n^2)</code>,这里给出我们的运行时间复杂度为 <code>O(n^2)</code>。</p><p>空间复杂度：<code>O(n^2)</code>，该方法使用<code>O(n^2)</code>的空间来存储表。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()][s.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[j][i] = (s[i] == s[j] &amp;&amp; (i-j&lt;<span class="number">2</span>) || dp[j+<span class="number">1</span>][i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i] &amp;&amp; len &lt; i-j+<span class="number">1</span>)&#123;</span><br><span class="line">                    len = i-j+<span class="number">1</span>;</span><br><span class="line">                    left = j;</span><br><span class="line">                    right = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(left,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://LiuZiQiao.github.io/categories/LeetCode/"/>
    
    
      <category term="dp" scheme="https://LiuZiQiao.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>【newcoder】最长公共子序列</title>
    <link href="https://LiuZiQiao.github.io/2019/04/21/day39-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://LiuZiQiao.github.io/2019/04/21/day39-最长公共子序列/</id>
    <published>2019-04-21T06:14:36.000Z</published>
    <updated>2019-04-21T07:25:36.903Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们有两个字符串m和n，如果它们的子串a和b内容相同，则称a和b是m和n的公共子序列。子串中的字符不一定在原字符串中连续。<br>例如字符串<code>“abcfbc”</code>和<code>“abfcab”</code>，其中<code>“abc”</code>同时出现在两个字符串中，因此<code>“abc”</code>是它们的公共子序列。此外，<code>“ab”</code>、<code>“af”</code>等都是它们的字串。<br>现在给你两个任意字符串（不包含空格），请帮忙计算它们的最长公共子序列的长度。</p><p>输入描述:   </p><pre><code>输入包含多组数据。</code></pre><p>每组数据包含两个字符串m和n，它们仅包含字母，并且长度不超过1024。</p><p>输出描述:   </p><pre><code>对应每组输入，输出最长公共子序列的长度。</code></pre><p>示例1<br>输入</p><pre><code>abcfbc abfcabprogramming contestabcd mnp</code></pre><p>输出</p><pre><code>420</code></pre><p><a href="https://www.nowcoder.com/questionTerminal/9ae56e5bdf4f480387df781671db5172" target="_blank" rel="noopener">原链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题是一个动态规划问题。对于动态规划求解问题，一般有两个特征：①最优子结构；②重叠子问题</p><p><strong>①最优子结构</strong>     </p><p>设X = (x1,x2,…xn)和Y = (y1,y2,…ym) 是两个序列，将X和Y的最长公共序列记为LCS(X,Y)  <br><br>找出LCS(X,Y)就是一个最优化问题。因为需要找到X和Y最长的公共子序列。而要找X和Y的LCS，就需要考虑X的最后一个元素和Y的最后一个元素。<br>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)</p><p>LCS(Xn-1，Ym-1)就是原问题的一个子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛….）</p><p>为什么是最优的子问题？因为我们要找的是Xn-1 和 Ym-1 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）</p><p>2）如果xn != ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。（都不相等了，怎么公共嘛）。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。</p><p>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。</p><p>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：</p><p>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p><strong>②重叠子问题</strong>   </p><p>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 </p><pre><code>❶LCS(Xn-1，Ym-1)   ❷LCS(Xn-1，Ym)   ❸LCS(Xn，Ym-1)</code></pre><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。   </p><p>由于像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。因为采用递归，它重复地求解了子问题啊。==注意，所有子问题加起来的个数 可是指数级的哦。。。==</p><p>这张DP表很是重要，从中我们可以窥见最长公共子序列的来源，同时可以根据这张表打印出最长公共子序列的构成路径<br><img src="https://images2018.cnblogs.com/blog/1358881/201807/1358881-20180724195351829-1792192564.png" alt="dp"></p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write your code here cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1,str2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;dp(len1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (str1[<span class="number">0</span>] == str2[<span class="number">0</span>])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (str1[i] == str2[<span class="number">0</span>])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>]  = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = (str1[<span class="number">0</span>] == str2[j])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][j]  = max(dp[<span class="number">0</span>][j<span class="number">-1</span>],dp[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(str1[i] == str2[j])&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[len1<span class="number">-1</span>][len2<span class="number">-1</span>] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="dp" scheme="https://LiuZiQiao.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>【nowcoder】错排问题</title>
    <link href="https://LiuZiQiao.github.io/2019/04/19/%E3%80%90nowcoder%E3%80%91%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2019/04/19/【nowcoder】错排问题/</id>
    <published>2019-04-19T02:09:42.000Z</published>
    <updated>2019-04-19T02:14:00.035Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？<br>即没有人收到属于自己的邮件。</p><p><a href="https://www.nowcoder.com/questionTerminal/95e35e7f6ad34821bc2958e37c08918b" target="_blank" rel="noopener">题目原地址</a><br>输入描述<br>    输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。</p><p>输出描述:</p><p>对应每一组数据，输出一个正整数，表示无人收到自己邮件的种数。<br>示例1<br>    输入  2 3<br>    输出  1 2</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.<br>第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；<br>第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；<br>综上得到<br>D(n) = (n-1) [D(n-2) + D(n-1)]<br>特殊地，D(1) = 0, D(2) = 1.<br>有了递推公式，一切就迎刃而解了。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write your code here cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> der[ <span class="number">21</span> ] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">3</span>; i &lt; <span class="number">21</span>; i++ )&#123;</span><br><span class="line">        der[ i ] = ( i - <span class="number">1</span> ) * ( der[ i - <span class="number">2</span>] + der[ i - <span class="number">1</span> ] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;n ) != EOF )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, der[ n ] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串区间的个数</title>
    <link href="https://LiuZiQiao.github.io/2019/04/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://LiuZiQiao.github.io/2019/04/15/字符串区间的个数/</id>
    <published>2019-04-15T12:37:39.000Z</published>
    <updated>2019-04-15T12:51:08.183Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>这个题是一道CVTE在线笔试题，题目是我回忆写的，答案是我自己的思路，如果哪位大神有更好的解决方案，希望可以留言或者私我交流。如有不明白请留言提出。 </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个数字字符串，长度为L，并给定一个K，请在字符串中找出区间大小为K，排序后的字符串是连续（相同为连续）的个数。输出这样的字符串的个数。</p><pre><code>示例：123456789  K=28  12,23,34,45,56,67,78,891345321898 K=34 345,453,321,898</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> L, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L - k; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = str.substr(i,  k);</span><br><span class="line"><span class="built_in">std</span>::sort(ret.begin(), ret.end());</span><br><span class="line"><span class="comment">//判断该区间是否连续</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ret[j+<span class="number">1</span>] - ret[j] == <span class="number">1</span>) &#123;</span><br><span class="line">n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当n = k-1时，说明上面的差判断了k-1次，就说明该串是连续的</span></span><br><span class="line"><span class="keyword">if</span> (n == k - <span class="number">1</span>) &#123;</span><br><span class="line">count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//string str = "123456789";  //K=2;  8</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"1345321898"</span>; <span class="comment">//K=3;  4</span></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">10</span>, K = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func(str,L,K) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个题是一道CVTE在线笔试题，题目是我回忆写的，答案是我自己的思路，如果哪位大神有更好的解决方案，希望可以留言或者私我交流。如有不明白请
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>树根</title>
    <link href="https://LiuZiQiao.github.io/2019/04/02/day25%E6%A0%91%E6%A0%B9/"/>
    <id>https://LiuZiQiao.github.io/2019/04/02/day25树根/</id>
    <published>2019-04-02T15:15:49.000Z</published>
    <updated>2019-04-02T15:16:53.693Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；如果结果是两位数或者包括更多位的数字，那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。<br>比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。<br>再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。<br>现在给你一个正整数，输出它的数根。</p><p>输入描述:   </p><pre><code>输入包含多组数据。每组数据数据包含一个正整数n（1≤n≤10E1000）。</code></pre><p>输出描述:   </p><pre><code>对应每一组数据，输出该正整数的数根。</code></pre><p>示例1   </p><p>输入</p><pre><code>2439</code></pre><p>输出</p><pre><code>63</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：</p><pre><code>36-&gt;9 98-&gt;17-&gt;81. 接收字符串得到各个数字2. 对每个数字进行求数根操作1. 计算数字字符串长度2. 对每个字节数据减去 ‘0’求和3. 对数字求根    1. 循环每次只获取数字个位数后删除个位数    98 % 10 = 8 ；98 / 10 = 9； 8 + 9 = 17；    17 % 10 = 7； 17 / 10 = 1； 7 + 1 = 8；</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRoot</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nroot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nroot += num % <span class="number">10</span>;<span class="comment">/*每次只获取个位数字*/</span></span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nroot &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        nroot = numRoot(nroot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nroot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> origin;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; origin) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origin.length(); i++) &#123;</span><br><span class="line">        sum += origin[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; numRoot(sum) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟面试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>【剑指offer】变态跳台阶</title>
    <link href="https://LiuZiQiao.github.io/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://LiuZiQiao.github.io/2019/03/31/【剑指offer】变态跳台阶/</id>
    <published>2019-03-31T13:34:02.000Z</published>
    <updated>2019-03-31T13:34:55.775Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：接上一个跳台阶问题思路继续分析，上个问题中，青蛙只能跳1级或者2级。 则最后一跳只有两种可能，所以F(n) = F(n-1) + F(n-2)//现在青蛙可以跳n级。 假设台阶为n级，则青蛙可以 跳一次或者多次。 一次： 直接跳n级，这是一种方法。 多次： 青蛙跳到 1到n-1级 任一级（不管怎样跳，跳几次）后再跳一次到n级。//或者这样分析，青蛙最后一跳，有可能是从起点直接跳到终点，或者从起点跳了若干步后(到达 1到n-1级中间任一级 )再跳到n级。//所以总的方法数为：青蛙 跳到 1级到n-1级 每级可能的方法数（再跳到n级） + 1（直接跳到n级）</p><pre><code>f(n) = f(n-1)+f(n-2) + … +f(1)f(n-1) = f(n-2)+f(n-3)+ … f(1)综上：f(n) = 2*f(n-1)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * jumpFloorII(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>【剑指offer】丑数</title>
    <link href="https://LiuZiQiao.github.io/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E4%B8%91%E6%95%B0/"/>
    <id>https://LiuZiQiao.github.io/2019/03/31/【剑指offer】丑数/</id>
    <published>2019-03-31T13:28:44.000Z</published>
    <updated>2019-03-31T13:29:37.872Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-一一遍历：时间复杂度高"><a href="#1-一一遍历：时间复杂度高" class="headerlink" title="1.一一遍历：时间复杂度高"></a>1.一一遍历：时间复杂度高</h4><p>一次遍历求出第<code>index</code>个丑数，从1开始，如果是丑数则<code>count++</code>，直到<code>count = index</code>为止。判断丑数依据题目意思，丑数只有2,3,5三个因子，因此就用这个数除以这个3个因子</p><pre><code>1.如果一个数能够被2整除，那么就让他继续除以22.如果一个数能够被3整除，那么就让他继续除以33.如果一个数能够被5整除，那么就让他继续除以54.如果这个数最终变成了1，那么这个数就是丑数</code></pre><p>根据以上定义实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> uglyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyCount &lt; index)</span><br><span class="line">        &#123;</span><br><span class="line">            number++;</span><br><span class="line">            <span class="keyword">if</span>(IsUgly(number))</span><br><span class="line">            &#123;</span><br><span class="line">                uglyCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsUgly</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number==<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该算法非常直观，他通不过，主要问题在于对每个数都需要计算，即使一个数不是丑数，还是需要对它做余数和除法操作，因此效率很低。</p><h4 id="空间换时间：提高效率"><a href="#空间换时间：提高效率" class="headerlink" title="空间换时间：提高效率"></a>空间换时间：提高效率</h4><html><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据丑数的定义，我们可以知道丑数可以由另外一个丑数乘以2，3或者5得到。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2，3或者5得到的。<br><br>　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们把得到的第一个丑数乘以2以后得到的大于M的结果记为M2。同样，我们把已有的每一个丑数乘以3和5，能得到第一个大于M的结果M3和M5。那么M后面的那一个丑数应该是M2,M3和M5当中的最小值：Min(M2,M3,M5)。比如将丑数数组中的数字按从小到大乘以2，直到得到第一个大于M的数为止，那么应该是2<em>2=4&lt;M，3</em>2=6&gt;M，所以M2=6。同理，M3=6，M5=10。所以下一个丑数应该是6。<br><br>　　根据以上思路实现代码如下：<br></html><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> uglyNumbers[index];</span><br><span class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply5 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nextUglyIndex &lt; index)</span><br><span class="line">        &#123;</span><br><span class="line">            min = Min(uglyNumbers[mutiply2]*<span class="number">2</span>,uglyNumbers[mutiply3]*<span class="number">3</span>,uglyNumbers[mutiply5]*<span class="number">5</span>);</span><br><span class="line">            uglyNumbers[nextUglyIndex] = min;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply2]*<span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply3]*<span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply5]*<span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply5++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextUglyIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = uglyNumbers[index<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> num3)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> min = num1&lt;num2?num1:num2;</span><br><span class="line">            min = min&lt;num3?min:num3;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="空间换时间" scheme="https://LiuZiQiao.github.io/tags/%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>【剑指offer】平衡二叉树</title>
    <link href="https://LiuZiQiao.github.io/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://LiuZiQiao.github.io/2019/03/30/【剑指offer】平衡二叉树/</id>
    <published>2019-03-30T15:29:38.000Z</published>
    <updated>2019-03-30T15:29:59.715Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=4&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目地址</a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(getDepth(pRoot-&gt;left) - getDepth(pRoot-&gt;right)) &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(getDepth(pRoot-&gt;left),getDepth(pRoot-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>【剑指offer】第一次出现一次的字符</title>
    <link href="https://LiuZiQiao.github.io/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://LiuZiQiao.github.io/2019/03/30/【剑指offer】第一次出现一次的字符/</id>
    <published>2019-03-30T15:25:36.000Z</published>
    <updated>2019-03-30T15:26:12.173Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashtable[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">            hashtable[e]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">            <span class="keyword">if</span>(hashtable[e] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)str.find(e);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>字符流中第一个不重复的字符</title>
    <link href="https://LiuZiQiao.github.io/2019/03/29/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://LiuZiQiao.github.io/2019/03/29/字符流中第一个不重复的字符/</id>
    <published>2019-03-29T15:17:05.000Z</published>
    <updated>2019-03-29T15:18:00.325Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>输出描述:</p><pre><code>如果当前字符流没有存在出现一次的字符，返回#字符。</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         hashtable[ch]++;</span><br><span class="line">         s = s+ch;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c :s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable[c]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hashtable[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="hashtable" scheme="https://LiuZiQiao.github.io/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://LiuZiQiao.github.io/2019/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://LiuZiQiao.github.io/2019/03/27/单例模式/</id>
    <published>2019-03-27T14:50:33.000Z</published>
    <updated>2019-03-27T14:51:03.710Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>一个类只能创建一个对象，该模式可以保证系统中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><h4 id="单例模式的要点有三个："><a href="#单例模式的要点有三个：" class="headerlink" title="单例模式的要点有三个："></a>单例模式的要点有三个：</h4><ol><li>单例类只能有一个实例 </li><li>它必须自行创建这个实例 </li><li>它必须自行向整个系统提供提供这个实例</li></ol><h4 id="具体实现角度来说-就是以下三点"><a href="#具体实现角度来说-就是以下三点" class="headerlink" title="具体实现角度来说,就是以下三点:"></a>具体实现角度来说,就是以下三点:</h4><ol><li>单例模式的类只提供私有的构造函数</li><li>类定义中含有一个该类的静态私有对象 </li><li>该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象</li></ol><h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点:"></a>单例模式的优点:</h4><ol><li>在内存中只有一个对象,节省内存空间</li><li>避免频繁的创建销毁对象,可以提高性能</li><li>避免对共享资源的多重占用</li><li>可以全局访问</li></ol><h4 id="单例模式的适用场景"><a href="#单例模式的适用场景" class="headerlink" title="单例模式的适用场景:"></a>单例模式的适用场景:</h4><ol><li>需要频繁实例化然后销毁的对象</li><li>创建对象耗时过多或者耗资源过多,但又经常用到的对象</li><li>有状态的工具类对象</li><li>频繁访问数据库或文件的对象</li><li>以及其他要求只有一个对象的场景</li></ol><h3 id="单例模式的两种实现方式"><a href="#单例模式的两种实现方式" class="headerlink" title="单例模式的两种实现方式"></a>单例模式的两种实现方式</h3><p><strong>饿汉式</strong>：就是说不管将来用不用，程序启动时就创建一个唯一的实例对象。<br>（如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    <span class="comment">// C++98 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">//</span></span><br></pre></td></tr></table></figure><p> 在程序入口之前就完成单例对象的初始化</p><p><strong>懒汉式</strong>：如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉</span></span><br><span class="line"><span class="comment">// 优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</span></span><br><span class="line"><span class="comment">// 缺点：复杂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">        m_mtx.lock();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        m_mtx.unlock();  </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~CGarbo()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">    <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    <span class="comment">// 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_pInstance; <span class="comment">// 单例对象指针</span></span><br><span class="line">    <span class="keyword">static</span> mutex m_mtx; <span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line">    Singleton* Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    Singleton::CGarbo Garbo;</span><br><span class="line">    mutex Singleton::m_mtx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多线程环境下演示上面GetInstance()加锁和不加锁的区别。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">10</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;单例模式：&quot;&gt;&lt;a href=&quot;#单例模式：&quot; class=&quot;headerlink&quot; title=&quot;单例模式：&quot;&gt;&lt;/a&gt;单例模
      
    
    </summary>
    
      <category term="C/C++" scheme="https://LiuZiQiao.github.io/categories/C-C/"/>
    
    
      <category term="设计模式" scheme="https://LiuZiQiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串通配符</title>
    <link href="https://LiuZiQiao.github.io/2019/03/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://LiuZiQiao.github.io/2019/03/24/字符串通配符/</id>
    <published>2019-03-24T14:27:40.000Z</published>
    <updated>2019-03-24T14:28:41.556Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。   </p><p><strong>要求：</strong><br>实现如下2个通配符：<br>*：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同）<br>？：匹配1个字符</p><p><strong>输入</strong>：<br>通配符表达式；<br>一组字符串。</p><p><strong>输出</strong>：<br>返回匹配的结果，正确输出true，错误输出false</p><p><strong>输入描述: </strong><br>先输入一个带有通配符的字符串，再输入一个需要匹配的字符串</p><p><strong>输出描述：</strong><br>返回匹配的结果，正确输出true，错误输出false</p><p><strong>示例1 </strong><br>输入</p><pre><code>te?t*.*txt12.xls</code></pre><p>输出</p><pre><code>false</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pattern,<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pattern== <span class="string">'\0'</span> &amp;&amp; *str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pattern== <span class="string">'\0'</span>||*str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pattern ==<span class="string">'?'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pattern ==<span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str) || match(pattern+<span class="number">1</span>,str+<span class="number">1</span>)||match(pattern,str+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pattern == *str)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pattern,str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pattern&gt;&gt;str)&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = match(pattern.c_str(),str.c_str());</span><br><span class="line">        <span class="keyword">if</span>(ret)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>超长正整数相加</title>
    <link href="https://LiuZiQiao.github.io/2019/03/22/%E8%B6%85%E9%95%BF%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://LiuZiQiao.github.io/2019/03/22/超长正整数相加/</id>
    <published>2019-03-22T14:44:30.000Z</published>
    <updated>2019-03-22T14:45:35.320Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个算法完成两个超长正整数的加法。</p><p>接口说明</p><pre><code>/*请设计一个算法完成两个超长正整数的加法。输入参数：String addend：加数String augend：被加数返回值：加法结果*/public String AddLongInteger(String addend, String augend){    /*在这里实现功能*/ return null;     }</code></pre><p>输入描述:<br>输入两个字符串数字</p><p>输出描述:<br>输出相加后的结果，string型</p><p>示例1<br>输入</p><pre><code>999999999999999999999999999999999999999999999999991</code></pre><p>输出</p><pre><code>100000000000000000000000000000000000000000000000000</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AddLongInteger</span><span class="params">(<span class="built_in">string</span> &amp;str1, <span class="built_in">string</span> &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = str1.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m = str2.size() - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> result = <span class="string">""</span>; <span class="comment">//存放结果字符串</span></span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 记录是否进位</span></span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span> || m &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">carry += str1[n] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">carry += str2[m] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result += (<span class="keyword">char</span>)(carry % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">carry /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">n--;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否进位</span></span><br><span class="line"><span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">result += <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br><span class="line">reverse(result.begin(), result.end());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; AddLongInteger(str1, str2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>完美数计算</title>
    <link href="https://LiuZiQiao.github.io/2019/03/21/%E5%AE%8C%E7%BE%8E%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
    <id>https://LiuZiQiao.github.io/2019/03/21/完美数计算/</id>
    <published>2019-03-21T15:07:51.000Z</published>
    <updated>2019-03-22T14:45:59.504Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。</p><p>它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。</p><p>例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。</p><p>给定函数count(int n),用于计算n以内(含n)完全数的个数。计算范围, 0 &lt; n &lt;= 500000</p><p>返回n以内完全数的个数。 异常情况返回-1</p><pre><code>/** *  *  完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。 *  它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。 *  例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。 *  *  给定函数count(int n),用于计算n以内(含n)完全数的个数 * @param n  计算范围, 0 &lt; n &lt;= 500000 * @return n 以内完全数的个数, 异常情况返回-1 *  */    public   static   int  count( int  n)</code></pre><p>输入描述:</p><pre><code>输入一个数字</code></pre><p>输出描述:</p><pre><code>输出完全数的个数</code></pre><p>示例1<br>输入</p><pre><code>1000</code></pre><p>输出</p><pre><code>3</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    约数计算可以遍历sqrt(n)的范围</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> | num&gt; <span class="number">500000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历范围</span></span><br><span class="line">            <span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=sq;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果j^2 = i,说明两个约数相同，只加一个</span></span><br><span class="line">                    <span class="keyword">if</span>(i/j==j)</span><br><span class="line">                        sum +=j;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//否则，两个不同的约数都要相加</span></span><br><span class="line">                        sum += j+(i/j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum +<span class="number">1</span> == i)</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count(num)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>公共字符串计算</title>
    <link href="https://LiuZiQiao.github.io/2019/03/20/%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E7%AE%97/"/>
    <id>https://LiuZiQiao.github.io/2019/03/20/公共字符串计算/</id>
    <published>2019-03-20T13:22:03.000Z</published>
    <updated>2019-03-22T14:46:07.127Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目标题：</p><p>计算两个字符串的最大公共字串的长度，字符不区分大小写</p><p>详细描述：</p><p>接口说明</p><p>原型：<br><code>int getCommonStrLength(char * pFirstStr, char * pSecondStr);</code></p><p>输入参数：</p><pre><code>char * pFirstStr //第一个字符串char * pSecondStr//第二个字符串</code></pre><p>输入描述:</p><pre><code>输入两个字符串</code></pre><p>输出描述:</p><pre><code>输出一个整数</code></pre><p>示例1   </p><p>输入</p><pre><code>asdfas werasdfaswer</code></pre><p>输出</p><pre><code>6</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">//max初值.</span></span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.size();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.size();</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//所有值初始化为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//计算dp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果当前结尾的字符相等，则在dp[i-1][j-1]的基础上加1</span></span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//dp[i][0] or dp[0][j]</span></span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新最大值</span></span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; max)</span><br><span class="line">max = dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>507.完美数</title>
    <link href="https://LiuZiQiao.github.io/2019/03/20/507-%E5%AE%8C%E7%BE%8E%E6%95%B0/"/>
    <id>https://LiuZiQiao.github.io/2019/03/20/507-完美数/</id>
    <published>2019-03-20T13:00:45.000Z</published>
    <updated>2019-03-20T13:01:08.670Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</p><p>给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False</p><p>示例：</p><pre><code>输入: 28输出: True解释: 28 = 1 + 2 + 4 + 7 + 14</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">                result += i;</span><br><span class="line">                <span class="keyword">if</span>(i*i != num)&#123;</span><br><span class="line">                    result += num / i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">1</span> &amp;&amp; result == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://LiuZiQiao.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://LiuZiQiao.github.io/2019/03/20/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://LiuZiQiao.github.io/2019/03/20/二进制中1的个数/</id>
    <published>2019-03-20T12:59:34.000Z</published>
    <updated>2019-03-20T12:59:56.958Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中指针常量与常量指针的区别</title>
    <link href="https://LiuZiQiao.github.io/2019/03/19/C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://LiuZiQiao.github.io/2019/03/19/C-中指针常量与常量指针的区别/</id>
    <published>2019-03-19T08:35:58.000Z</published>
    <updated>2019-03-19T08:36:42.043Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在C++学习过程使用中，每个人都不可避免的会把指针错误理解或在不理解，尤其是对指针常量和常量指针的理解，特别容易把概念搞混淆。本文就针对该问题简单的说说指针常量和常量指针的区别。</p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>   本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ul><li>是个常量。</li><li>指针锁保存的地址可以改变，但指针指向的值不能改变。</li><li>指针本身是常量，指向的地址不可以变，但指向的地址所对应的内容可以变。</li></ul><p>形式如下：</p><pre><code>int* const p;</code></pre><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>常量指针又叫常指针，可以理解为常量的指针，也就是这个是指针，但指向的是常量，这个常量是指针的值（地址），并不是地址指向的值。</p><h4 id="特征：-1"><a href="#特征：-1" class="headerlink" title="特征："></a>特征：</h4><ul><li>常量指针指向的对象不能通过这个指针来修改，可以通过原来的声明修改。</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，就是限制了通过这个指针修改变量的值。</li><li>指针还可以指向别处，因为指针本身只是一个变量，可以指向任意地址。</li></ul><p>形式如下：</p><pre><code>int const* p;const int* p;</code></pre><h3 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h3><p>指向常量的指针常量是一个常量，且所指向的对象也是一个常量。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>一个指针常量，指向的是一个指针对象；</li><li>它所指向的指针对象且是一个常量，即指向的对象不能变。</li></ul><p>形式如下：</p><pre><code>const int* const p;</code></pre><p>如何区别这些呢？</p><h3 id="区分宝典"><a href="#区分宝典" class="headerlink" title="区分宝典"></a>区分宝典</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>看*和const的排列顺序，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="comment">//const* 常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;  <span class="comment">//const* 常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;  <span class="comment">//*const 指针常量</span></span><br></pre></td></tr></table></figure></p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>看const离谁近，即从右往左看，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cont* p;  <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p; <span class="comment">//和上面一样</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p; <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改</span></span><br></pre></td></tr></table></figure></p><p>看一个实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p><pre><code>size_t strlen(const char* src); //常量指针，src的值不可改变；char a[] = &quot;hello&quot;;char b[] = &quot;world&quot;;size_t a1 = strlen(a);size_t b1 = strlen(b);</code></pre><p>虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在C++学习过程使用中，每个人都不可避免的会把指针错误理解或在不理解，尤其是对指针常量和常量指针的理解，特别容易把概念搞混淆。本文就针对该
      
    
    </summary>
    
      <category term="C/C++" scheme="https://LiuZiQiao.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>格子走法</title>
    <link href="https://LiuZiQiao.github.io/2019/03/17/%E6%A0%BC%E5%AD%90%E8%B5%B0%E6%B3%95/"/>
    <id>https://LiuZiQiao.github.io/2019/03/17/格子走法/</id>
    <published>2019-03-17T13:44:48.000Z</published>
    <updated>2019-03-22T14:46:46.087Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。</p><p>输入描述:<br>输入两个正整数</p><p>输出描述:<br>返回结果</p><p>示例1<br>输入</p><pre><code>22</code></pre><p>输出</p><pre><code>6</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>-------------| 1 | 2 | 3 |-------------| 4 | 5 | 6 |-------------| 7 | 8 | 9 |-------------1. 对于上面的n*m(3*3)的格子，有两种情况a. 如果n或者m为1，则只有一行或者一列，从左上角走到右下角的路径数为n + m比如： 1 * 1格子，可以先向下走，再向右走，到达右下角；或者先向右走，再向下走，到达右下角，共两条，即 1 + 1 = 2，对于1 * m和 n * m的情况同学们自己画一下b. 如果n,m都大于1，那么走到[n][m]格子的右下角只有两条路径，&lt;1&gt;: 从[n - 1][m]格子的右下角向下走，到达&lt;2&gt;: 从[n][m - 1]格子的右下角向右走，到达所以走到[n][m]格子的右下角的数量为[n-1][m] + [n][m - 1],可以通过递归 实现，情况a为递归的终止条件。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;y&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(x,y<span class="number">-1</span>)+sum(x<span class="number">-1</span>,y);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((x&gt;=<span class="number">1</span> &amp;&amp; y==<span class="number">1</span>)|| (x==<span class="number">1</span>)&amp;&amp;(y&gt;=<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col,row;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;col&gt;&gt;row)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum(row,col)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>进制转换</title>
    <link href="https://LiuZiQiao.github.io/2019/03/17/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>https://LiuZiQiao.github.io/2019/03/17/进制转换/</id>
    <published>2019-03-17T13:43:53.000Z</published>
    <updated>2019-03-22T14:46:51.522Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数</p><p>输入描述:<br>输入为一行，M(32位整数)、N(2 ≤ N ≤ 16)，以空格隔开。   </p><p>输出描述:   </p><p>为每个测试实例输出转换后的数，每个输出占一行。如果N大于9，则对应的数字规则参考16进制（比如，10用A表示，等等）</p><p>示例1<br>输入</p><pre><code>7 2</code></pre><p>输出</p><pre><code>111</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> tables = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">0</span>,N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(M&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            M = -M;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = tables[M%N]+s;</span><br><span class="line">        M /=N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="模拟笔试题集" scheme="https://LiuZiQiao.github.io/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    
    
  </entry>
  
</feed>
