<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuxiaoKun</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LiuZiQiao.github.io/"/>
  <updated>2019-01-30T05:18:36.214Z</updated>
  <id>https://LiuZiQiao.github.io/</id>
  
  <author>
    <name>LiuXiaoKun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈网络之设计模式与分层模型</title>
    <link href="https://LiuZiQiao.github.io/2019/01/30/%E8%B0%88%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://LiuZiQiao.github.io/2019/01/30/谈谈网络之设计模式与分层模型/</id>
    <published>2019-01-30T05:18:09.000Z</published>
    <updated>2019-01-30T05:18:36.214Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型</p><h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p><strong>优缺点：</strong> 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<code>提高数据传输效率。</code>且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所<code>采用的协议相对灵活。</code>可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。<br>    因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br>    C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。<code>工作量</code>将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<code>安全性</code>构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>    B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其<code>工作开发量较小</code>。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br>    B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<code>缓存数据不尽如人意</code>，从而<code>传输数据量受到限制</code>。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，<code>协议选择不灵活</code>。<br>    因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="https://img-blog.csdnimg.cn/20190130131007694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li><li>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li><li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li></ol><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190130131054219.png" alt="2"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。但也有一些自定义协议类型，只是在其之上进行一些修改完成需求功能即可的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型&lt;/p&gt;
&lt;h3 id=&quot;网络应用程序设计模式&quot;&gt;&lt;a href=&quot;#网络
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="NET" scheme="https://LiuZiQiao.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第k个结点</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/二叉搜索树的第k个结点/</id>
    <published>2019-01-24T15:04:05.000Z</published>
    <updated>2019-01-24T15:05:40.441Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = KthNode(pRoot-&gt;left,k);</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            index++;  </span><br><span class="line">            <span class="keyword">if</span>(index == k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot-&gt;right,k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://LiuZiQiao.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>“三次握手，四次挥手”你真的懂吗？</title>
    <link href="https://LiuZiQiao.github.io/2019/01/24/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/24/“三次握手，四次挥手”你真的懂吗？/</id>
    <published>2019-01-24T04:30:19.000Z</published>
    <updated>2019-01-24T04:31:02.327Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是”三次握手，四次挥手“"><a href="#什么是”三次握手，四次挥手“" class="headerlink" title="什么是”三次握手，四次挥手“"></a>什么是”三次握手，四次挥手“</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用3次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p><img src="https://img-blog.csdnimg.cn/20190124115039196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>三次握手和四次挥手的状态转换如下图<br><img src="https://img-blog.csdnimg.cn/20190124115225958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h4 id="“三次握手，四次挥手”是怎么完成的？"><a href="#“三次握手，四次挥手”是怎么完成的？" class="headerlink" title="“三次握手，四次挥手”是怎么完成的？"></a>“三次握手，四次挥手”是怎么完成的？</h4><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。<br><img src="https://img-blog.csdnimg.cn/20190124115513655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p><h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://img-blog.csdnimg.cn/20190124115650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p></li><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p></li></ol><h4 id="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h3 id="”三次握手，四次挥手“进阶"><a href="#”三次握手，四次挥手“进阶" class="headerlink" title="”三次握手，四次挥手“进阶"></a>”三次握手，四次挥手“进阶</h3><h4 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p><p>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h4 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h4><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h5 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h5><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h5 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h5><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h5><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。<br><img src="https://img-blog.csdnimg.cn/20190124122642462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"><br>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><p>查看是否有连接溢出 <code>netstat -s | grep LISTEN</code></p><h5 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h5><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><h5 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h5><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><code>netstat -s</code>命令</p><p>[root@server ~]# netstat -s | grep “listen|LISTEN” </p><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><p>[root@server ~]# netstat -s | grep TCPBacklogDrop </p><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><p>[root@server ~]# ss -lnt</p><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;什么是”三次握手，四次挥手“&quot;&gt;&lt;a href=&quot;#什么是”三次握手，四次挥手“&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="TCP" scheme="https://LiuZiQiao.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装更新git的正确打开方式</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0git%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7安装更新git的正确打开方式/</id>
    <published>2019-01-03T08:52:12.000Z</published>
    <updated>2019-01-03T08:54:13.402Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">1</a></p><p>安装centos7 之后一直用自带的git，在提交的时候总是出现下面这种情况，原因是git版本太低导致的，于是就想了办法去更新git，<br>百度看了很多教程，都是什么先卸载再重新安装，卸载之前还需要备份一份配置文件，看了很多感觉非常麻烦，于是就在Linux网站中看到了一个最正确的更新及安装方式。以下是记录我更新安装过程。</p><h3 id="配置存储库"><a href="#配置存储库" class="headerlink" title="配置存储库"></a>配置存储库</h3><p>在这之前，我们需要在root权限下才可以进一步操作。<br>1.启用Wandisco GIT存储库<br>启用存储库需要在/etc/yum.repos.d/目录中命名的新yum存储库配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/wandisco-git.repo</span><br></pre></td></tr></table></figure></p><p>添加以下字段，ESC，然后:输入wq保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><p>使用以下命名了导入存储库GPG密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>完成之后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p><p>输出<code>git version 2.18.0</code></p><h3 id="验证配置文件更改"><a href="#验证配置文件更改" class="headerlink" title="验证配置文件更改"></a>验证配置文件更改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Your Name</span><br><span class="line">user.email=youremail@yourdomain.com</span><br></pre></td></tr></table></figure></p><p>配置设置存储在~/.gitconfig文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = youremail@yourdomain.com</span><br></pre></td></tr></table></figure><p>要进一步更改Git配置，可以使用git config命令或~/.gitconfig手动编辑文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-proc
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="git centos" scheme="https://LiuZiQiao.github.io/tags/git-centos/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装vscode</title>
    <link href="https://LiuZiQiao.github.io/2019/01/03/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/"/>
    <id>https://LiuZiQiao.github.io/2019/01/03/CentOS7环境下安装vscode/</id>
    <published>2019-01-02T16:00:47.000Z</published>
    <updated>2019-01-02T16:01:07.936Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了CentOS7下安装过程。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>环境参数：<br>操作系统版本：CentOS-7-x86_64-1511<br>软件版本：visual stdio code 1.2   </p><p>操作步骤：<br>1.下载 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode_x86_64.rpm</a><br>2.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>可能会报这样一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libXss.so.1()(64bit) is needed by code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libXss*  -y</span><br></pre></td></tr></table></figure></p><p>然后在重新安装rpm文件，没报错可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>然后打开应用程序可以看见vscode安装好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了Cen
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS7环境下安装Chrome</title>
    <link href="https://LiuZiQiao.github.io/2019/01/02/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Chrome/"/>
    <id>https://LiuZiQiao.github.io/2019/01/02/CentOS7环境下安装Chrome/</id>
    <published>2019-01-02T15:01:15.000Z</published>
    <updated>2019-01-02T15:38:50.065Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>下载Chrome浏览器的rpm包（<a href="https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）" target="_blank" rel="noopener">https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）</a><br>利用xshell连接好Linux，使用命令rz，弹出选择窗口，将下载好的包上传进去，然后进入包目录，使用rpm命令进行安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>当然，这里需要切换到root用户下才可以执行。<br>执行完命令后会出现错误<br><img src="https://img-blog.csdnimg.cn/20190102230011852.png" alt="1"></p><p>出现这个错误是因为少了redhat-lsb这个依赖</p><p>安装readhat-lsb依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  redhat-lsb</span><br></pre></td></tr></table></figure></p><p>安装完上面的lsb依赖后，再来执行chrome安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>至此Chrome就安装完毕了，打开 应用程序 》互联网 就会发现Chrome的图标了</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>在以上正常的安装方式中， 我安装失败了，原因是我的key无法更新，于是我就选择了另外一种在线安装。以下记录了在线安装的过程。仅供参考，大佬勿喷。   </p><h4 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h4><p>在/etc/yum.repos.d/目录下新建文件google-chrome.repo，向其中添加如下内容:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[google-chrome]</span><br><span class="line">name=google-chrome</span><br><span class="line">baseurl=http:<span class="comment">//dl.google.com/linux/chrome/rpm/stable/$basearch</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//dl-ssl.google.com/linux/linux_signing_key.pub</span></span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable</span><br></pre></td></tr></table></figure></p><p>注：Google官方源在国内可能无法正常访问，导致安装失败或安装后无法正常更新，可以尝试添加–nogpgcheck参数再安装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable --nogpgcheck</span><br></pre></td></tr></table></figure></p><p>或者可以尝试修改gpgcheck=0再安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Linux下静态链接库出现的问题</title>
    <link href="https://LiuZiQiao.github.io/2018/12/31/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2018/12/31/解决Linux下静态链接库出现的问题/</id>
    <published>2018-12-31T13:04:57.000Z</published>
    <updated>2018-12-31T13:05:49.081Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我们用Makefile工具时，在Makefile文件中写编译语句时，希望编译时用静态链接库来编译，例如语句如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o $@ $^ -<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>编译时链接静态库的方式有好几种，这里我使用static。问题出现的是，当我们make时，出现如下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test test.cpp -<span class="keyword">static</span></span><br><span class="line">/usr/bin/ld: cannot find -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lm</span><br><span class="line">/usr/bin/ld: cannot find -lc</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">make: *** [tcpClient] Error <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在我百度了很久之后CSDN未能解决如下问题，还是Stack Overflow解决了该问题。<br>用如下两条命令安装所需要的静态库即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libstdc++-<span class="keyword">static</span></span><br><span class="line">sudo yum install glibc-<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>安装了以上两个库之后，make一下，编译成功，使用<code>ll</code>查看你会发现编译之后的目标文件会非常大。这时就是成功的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的几款内存泄漏检测工具</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/Linux%E4%B8%8B%E7%9A%84%E5%87%A0%E6%AC%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/Linux下的几款内存泄漏检测工具/</id>
    <published>2018-12-24T13:31:00.000Z</published>
    <updated>2018-12-24T13:38:51.473Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme/article/details/51959654" target="_blank" rel="noopener">原文链接</a></p><p>Linux下编写C或者C++程序，有很多工具，但是主要编译器仍然是gcc和g++。最近用到STL中的List编程，为了检测写的代码是否会发现内存泄漏，了解了一下相关的知识。</p><p>所有使用动态内存分配(dynamic memory allocation)的程序都有机会遇上内存泄露(memory leakage)问题，在Linux里有三种常用工具来检测内存泄露的情況，包括：</p><p>参见 <a href="http://elinux.org/Memory_Debuggers" rel="nofollow" target="_blank">http://elinux.org/Memory_Debuggers</a> <br><br>偶然发现的<a href="http://blog.163.com/zhuang_qianxin/blog/static/29765138201051092529107/" rel="nofollow" target="_blank">内存泄露检测工具比较 </a></p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">工具</th><br>  <th align="center">描述</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#valgrind" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center">一个强大开源的程序检测工具</td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#mtrace" rel="nofollow" target="_blank">mtrace</a></td><br>  <td align="center">GNU扩展, 用来跟踪malloc, mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数</td><br></tr><br><tr><br>  <td align="center"><a href="" rel="nofollow" target="_blank">dmalloc</a></td><br>  <td align="center">用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存,以一个运行库的方式发布</td><br></tr><br><tr><br>  <td align="center">memwatch</td><br>  <td align="center">和dmalloc一样，它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域</td><br></tr><br><tr><br>  <td align="center"><a href="http://mpatrol.sourceforge.net/" rel="nofollow" target="_blank">mpatrol</a></td><br>  <td align="center"><a href="http://www.ibm.com/developerworks/cn/linux/l-mleak2/" rel="nofollow" target="_blank">一个跨平台的 C++ 内存泄漏检测器</a></td><br></tr><br><tr><br>  <td align="center"><a href="http://dbgmem.sourceforge.net/" rel="nofollow" target="_blank">dbgmem</a></td><br>  <td align="center"></td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Electric_Fence" rel="nofollow" target="_blank">Electric Fence</a></td><br>  <td align="center"></td><br></tr><br></tbody></table></div><h1 id="1-被测程序"><a name="t0"></a>1  被测程序</h1><hr><p class="cye-lm-tag">为了方便测试,,我们编写了一个简单的程序, 循环10次每次申请了一个100个字节的单元, 但是却不释放</p><h1 id="2-valgrind"><a name="t1"></a>2  valgrind</h1><hr><h2 id="21-valgrind介绍"><a name="t2"></a>2.1   valgrind介绍</h2><hr><p class="cye-lm-tag">是不是说没有一种内存检查工具能够在Linux使用呢，也不是，像开源的valgrind工具还是相当不错的</p><ul><br><li><p class="cye-lm-tag">Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p></li><br><li><p class="cye-lm-tag">Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p></li><br><li><p class="cye-lm-tag">Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p></li><br><li><p class="cye-lm-tag">Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p></li><br><li><p class="cye-lm-tag">Massif。它主要用来检查程序中堆栈使用中出现的问题。</p></li><br><li><p class="cye-lm-tag">Extension。可以利用core提供的功能，自己编写特定的内存调试工具</p></li><br></ul><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">主页</th><br>  <th align="center">下载</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://valgrind.org/" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center"><a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">downloads</a></td><br></tr><br></tbody></table></div><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719211251895" alt="valgrind介绍" title=""></p><blockquote><br>  <p class="cye-lm-tag">参照</p><br><br>  <p class="cye-lm-tag"><a href="http://www.cnblogs.com/sunyubo/archive/2010/05/05/2282170.html" rel="nofollow" target="_blank">Valgrind简单用法</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">Unix下C程序内存泄漏检测工具Valgrind安装与使用</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">valgrind 的使用简介</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" rel="nofollow" target="_blank">应用 Valgrind 发现 Linux 程序的内存问题</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.oschina.net/translate/valgrind-memcheck" rel="nofollow" target="_blank">如何使用Valgrind memcheck工具进行C/C++的内存泄漏检测</a></p><br></blockquote><h2 id="22-安装"><a name="t3"></a>2.2   安装</h2><hr><p class="cye-lm-tag"><strong>源码安装</strong></p><p class="cye-lm-tag">到<a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">下载地址</a>)下载最新版的valgrind,按照里面的README提示，安装后就可以使用这个工具来检测内存泄露和内存越界等</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">/configuremakesudo make install<p class="cye-lm-tag">当然也可以使用发行版的自带的源中安装</p>sudo apt install valgrind这是一个没有界面的内存检测工具，安装后，输入 valgrind ls -l 验证一下该工具是否工作正常（这是README里面的方法，实际上是验证一下对ls -l命令的内存检测），如果你看到一堆的信息说明你的工具可以使用了。<h2 id="23-使用说明"><a name="t4"></a>2.3   使用说明</h2><hr><p class="cye-lm-tag">Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif。</p><p class="cye-lm-tag"><strong>Memcheck</strong></p><p class="cye-lm-tag">最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，Memcheck 工具主要检查下面的程序错误</p><div class="table-box"><table><thead><tr>  <th align="center">内容</th>  <th align="center">描述</th></tr></thead><tbody><tr>  <td align="center">使用未初始化的内存</td>  <td align="center">Use of uninitialised memory</td></tr><tr>  <td align="center">使用已经释放了的内存</td>  <td align="center">Reading/writing memory after it has been free’d</td></tr><tr>  <td align="center">使用超过 malloc分配的内存空间</td>  <td align="center">Reading/writing off the end of malloc’d blocks</td></tr><tr>  <td align="center">对堆栈的非法访问</td>  <td align="center">Reading/writing inappropriate areas on the stack</td></tr><tr>  <td align="center">申请的空间是否有释放</td>  <td align="center">Memory leaks – where pointers to malloc’d blocks are lost forever</td></tr><tr>  <td align="center">malloc/free/new/delete申请和释放内存的匹配</td>  <td align="center">Mismatched use of malloc/new/new [] vs free/delete/delete []</td></tr><tr>  <td align="center">src和dst的重叠</td>  <td align="center">Overlapping src and dst pointers in memcpy() and related functions</td></tr></tbody></table></div><p class="cye-lm-tag">这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。 </p><p class="cye-lm-tag"><strong>Callgrind</strong></p><p class="cye-lm-tag">和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 </p><p class="cye-lm-tag"><strong>Cachegrind</strong></p><p class="cye-lm-tag">Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 </p><p class="cye-lm-tag"><strong>Helgrind</strong></p><p class="cye-lm-tag">它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 </p><p class="cye-lm-tag"><strong>Massif</strong></p><p class="cye-lm-tag">堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 </p><blockquote>  <p class="cye-lm-tag">此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具</p>  <p class="cye-lm-tag"><strong>注意</strong></p>  <p class="cye-lm-tag">Valgrind不检查静态分配数组的使用情况</p>  <p class="cye-lm-tag">Valgrind占用了更多的内存–可达两倍于你程序的正常使用量</p>  <p class="cye-lm-tag">如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试</p></blockquote><h2 id="24-使用说明"><a name="t5"></a>2.4   使用说明</h2><hr><p class="cye-lm-tag">编译程序</p>g++ -g -o leak leak.c <p class="cye-lm-tag">被检测程序加入 –g   -fno-inline 编译选项保留调试信息, 否则后面的valgrind不能显示到出错行号。</p>valgrind被设计成非侵入式的，它直接工作于可执行文件上，因此在检查前不需要重新编译、连接和修改你的程序。要检查一个程序很简单，只需要执行下面的命令就可以了。valgrind --tool=tool_name program_name比如我们要对ls -l命令做内存检查，只需要执行下面的命令就可以了<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck ls -l</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><blockquote><br>  <p class="cye-lm-tag">小提示 <br><br>  如果不知道有哪些参数, 可以先输入valgrind –tool=, 然后狂按两次tab, 会输出linux系统的只能提示, 同样,如果你输入了valgrind –tool=mem再狂按两次tab,linux系统会为你自动补全</p><br></blockquote><h2 id="25-使用valgrind检测memcheck"><a name="t6"></a>2.5   使用valgrind检测Memcheck</h2><hr><p class="cye-lm-tag">下面我们就可以用valgrind对我们的程序检测leak</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes    ./leak</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag">其中–leak-check=full 指的是完全检查内存泄漏，</p><p class="cye-lm-tag">–show-reachable=yes是显示内存泄漏的地点，</p><p class="cye-lm-tag">–trace-children=yes是跟入子进程。</p><p class="cye-lm-tag">当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理：</p><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719210756831" alt="输出内存泄漏的信息原" title=""></p><h1 id="3-mtrace检测内存泄露"><a name="t7"></a>3  mtrace检测内存泄露</h1><hr><h2 id="31-mtrace简介"><a name="t8"></a>3.1   mtrace简介</h2><hr><p class="cye-lm-tag">在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace. </p><p class="cye-lm-tag">mtrace其实是GNU扩展函数，用来跟踪malloc。</p><p class="cye-lm-tag">mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。 <br><br>在程序中，这些trace信息可以被用来发现内存泄漏和释放不是申请的内存。 <br><br>当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。 <br><br>如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。</p><p class="cye-lm-tag">详细说明可参考man page：man 3 mtrace</p><h2 id="32-mtrace使用"><a name="t9"></a>3.2   mtrace使用</h2><hr><p class="cye-lm-tag">mtrace能监测程序是否内存泄露</p><ul><br><li>在程序的起始处包含头文件</li></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-preprocessor cye-lm-tag">#include &lt;mcheck.h&gt;</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>更改环境变量：export   MALLOC_TRACE=”mtrace.out”可以加入如下代码</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">setenv(<span class="hljs-string cye-lm-tag">"MALLOC_TRACE"</span>, <span class="hljs-string cye-lm-tag">"mtrace.out"</span>, <span class="hljs-number cye-lm-tag">1</span>);</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>调用函数mtrace()</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace()</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>编译程序带上 -g 选项</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">gcc -g -c leak_mtrace.c -o leak_mtrace.o  -<span class="hljs-built_in cye-lm-tag">std</span>=gnu9x -Wall</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">./leak_mtrace </code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>mtrace a.out  mtrace.out查看内存监测情况</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace a.out  mtrace.out</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719214131721" alt="这里写图片描述" title=""></p><h1 id="4-dmalloc"><a name="t10"></a>4  dmalloc</h1><hr><p class="cye-lm-tag">dmalloc是一种用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存，并且能够精确指出在哪个源文件的第几行。</p><h1 id="5-linux内核的kmemleak"><a name="t11"></a>5  Linux内核的Kmemleak</h1><h2 id="51-kmemleak检测工具介绍"><a name="t12"></a>5.1   Kmemleak检测工具介绍</h2><hr><p class="cye-lm-tag">Kmemleak工作于内核态是内核自带的内核泄露检测工具, 其源代码位于<a href="http://lxr.free-electrons.com/source/mm/kmemleak.c?v4.7" rel="nofollow" target="_blank">mm/kmemleak.c</a></p><p class="cye-lm-tag">Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，其方法类似于跟踪内存收集器。当独立的对象没有被释放时，其报告记录在 /sys/kernel/debug/kmemleak中，Kmemcheck能够帮助定位大多数内存错误的上下文。</p><h2 id="52-kmemleak使用过程概述"><a name="t13"></a>5.2   Kmemleak使用过程概述</h2><ul><br><li><p class="cye-lm-tag">首先`CONFIG_DEBUG_KMEMLEAK在Kernel hacking中被使能.</p></li><br><li><p class="cye-lm-tag">查看内核打印信息详细过程如下：</p><br><br><ol><li>挂载debugfs文件系统 <br><br>mount -t debugfs nodev /sys/kernel/debug/</li><br><li>开启内核自动检测线程 <br><br>echo scan &gt; /sys/kernel/debug/kmemleak</li><br><li>查看打印信息 <br><br>cat /sys/kernel/debug/kmemleak</li><br><li>清除内核检测报告，新的内存泄露报告将重新写入/sys/kernel/debug/kmemleak <br><br>echo clear &gt; /sys/kernel/debug/kmemleak</li></ol></li><br></ul><p class="cye-lm-tag">内存扫描参数可以进行修改通过向/sys/kernel/debug/kmemleak 文件写入。 参数使用如下</p><pre class="prettyprint" name="code"><code class="language-cpp hljs  has-numbering">off 禁用kmemleak（不可逆）<span class="hljs-built_in cye-lm-tag">stack</span>=on 启用任务堆栈扫描(<span class="hljs-keyword cye-lm-tag">default</span>)<span class="hljs-built_in cye-lm-tag">stack</span>=off 禁用任务堆栈扫描scan=on 启动自动记忆扫描线程(<span class="hljs-keyword cye-lm-tag">default</span>)scan=off 停止自动记忆扫描线程scan=&lt;secs&gt; 设置n秒内自动记忆扫描scan 开启内核扫描clear 清除内存泄露报告dump=&lt;addr&gt; 转存信息对象在&lt;addr&gt;</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p class="cye-lm-tag">通过“kmemleak = OFF”，也可以在启动时禁用Kmemleak在内核命令行。在初始化kmemleak之前，内存的分配或释放这些动作被存储在一个前期日志缓冲区。这个缓冲区的大小通过配CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE设置。 </p><h2 id="53-kmemleak动态检测原理"><a name="t14"></a>5.3   Kmemleak动态检测原理</h2><hr><p class="cye-lm-tag">通过的kmalloc、vmalloc、kmem_cache_alloc等内存分配会跟踪其指针，连同其他的分配大小和堆栈跟踪信息，存储在PRIO搜索树。相应的释放函数调用跟踪和指针就会从kmemleak数据结构中移除。 <br><br>分配的内存块，被认为是独立的，如果没有指针指向它起始地址或块的内部的任何位置，可以发现扫描内存（包括已保存的寄存器）。这意味着，有可能没有办法为内核通过所分配的地址传递块到一个释放函数，因此，该块被认为是一个内存泄漏。</p><p class="cye-lm-tag">扫描算法步骤： <br><br>1.  标记的所有分配对象为白色（稍后将剩余的白色物体考虑独立的）</p><ol><br><li><p class="cye-lm-tag">扫描存储器与所述数据片段和栈开始，检查对地址的值存储在PRIO搜索树。如果一个白色的对象的指针被发现，该对象将被添加到灰名单</p></li><br><li><p class="cye-lm-tag">扫描的灰色对象匹配的地址（一些白色物体可以变成灰色，并添加结束时的灰名单），直到黑色集结束</p></li><br><li><p class="cye-lm-tag">剩下的白色物体被认为是独立儿，并报告写入/sys/kernel/debug/kmemleak。 <br><br>一些分配的内存块的指针在内核的内部数据结构和它们不能被检测为孤儿。对避免这种情况，kmemleak也可以存储的数量的值，指向一个内的块的地址范围内的地址，需要找到使块不被认为是泄漏.</p></li><br></ol><h2 id="54-kmem相关函数"><a name="t15"></a>5.4   kmem相关函数</h2><hr><p class="cye-lm-tag">从kernel源代码中的目录<code>include /linux/kmemleak.h</code>中可查看函数原型的头</p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">函数</th><br>  <th align="center">功能</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center">kmemleak_init</td><br>  <td align="center">初始化kmemleak</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc</td><br>  <td align="center">一个内存块分配的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_percpu</td><br>  <td align="center">通知的一个percpu的内存块分配</td><br></tr><br><tr><br>  <td align="center">kmemleak_free</td><br>  <td align="center">通知的内存块释放</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_part</td><br>  <td align="center">通知释放部分内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_percpu</td><br>  <td align="center">一个percpu内存块释放的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_not_leak</td><br>  <td align="center">当不是泄露时，标记对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_ignore</td><br>  <td align="center">当泄漏时不扫描或报告对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_scan_area</td><br>  <td align="center">添加扫描区域内的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_no_scan</td><br>  <td align="center">不扫描的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_erase</td><br>  <td align="center">删除一个指针变量的旧值</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_recursive</td><br>  <td align="center">为kmemleak_alloc，只检查递归</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_recursive</td><br>  <td align="center">为kmemleak_free，只检查递归</td><br></tr><br></tbody></table></div>            <br>                        <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"><br>                </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>window双系统Deepin安装及正确删除</title>
    <link href="https://LiuZiQiao.github.io/2018/12/24/window%E5%8F%8C%E7%B3%BB%E7%BB%9FDeepin%E5%AE%89%E8%A3%85%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4/"/>
    <id>https://LiuZiQiao.github.io/2018/12/24/window双系统Deepin安装及正确删除/</id>
    <published>2018-12-24T13:18:34.000Z</published>
    <updated>2018-12-24T13:34:11.549Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://blog.csdn.net/qq_39478237/article/details/85239249" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39478237/article/details/85239249&quot; 
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="https://LiuZiQiao.github.io/2018/12/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://LiuZiQiao.github.io/2018/12/10/滑动窗口的最大值/</id>
    <published>2018-12-10T14:54:59.000Z</published>
    <updated>2018-12-10T15:00:41.932Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>暴力破解法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || num.size() &lt; size || num.size() &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> end = size;   <span class="comment">//定义end为窗口数组的大小</span></span><br><span class="line"><span class="keyword">while</span> (end &lt;= num.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = num[end-size];    <span class="comment">//默认窗口中第一个元素为最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = end - size+<span class="number">1</span>; i &lt; end; ++i)         <span class="comment">//从第二个元素开始进行窗口元素遍历，找到窗口中最大的元素，存入v中，end后移</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; num[i])</span><br><span class="line">&#123;</span><br><span class="line">max = num[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br><span class="line">v.push_back(max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><strong>Thinking</strong> 。。。</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux编程之进程间通信</title>
    <link href="https://LiuZiQiao.github.io/2018/12/08/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://LiuZiQiao.github.io/2018/12/08/Linux编程之进程间通信/</id>
    <published>2018-12-08T14:00:40.000Z</published>
    <updated>2018-12-08T14:01:29.334Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程,在这个过程中，伴随着资源的分配和释放。那么释放的资源可能是其他进程需要的，然而进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。</p><h3 id="进程通信应用场景"><a href="#进程通信应用场景" class="headerlink" title="进程通信应用场景"></a>进程通信应用场景</h3><ul><li><p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p></li><li><p>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p></li><li><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p></li><li><p>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p></li><li><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p></li></ul><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h4><p><img src="https://img-blog.csdnimg.cn/20181208215636614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>管道实现细节</strong><br>在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图<br><img src="https://img-blog.csdnimg.cn/20181208215019885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><p>仅仅适用于具有亲缘关系的进程间通信，因为匿名管道其它进程根本找不到，因此也就没有办法通信，所以只能通过子进程复制父进程的方法，让子进程能够访问相同的管道，来实现通信。<br>（管道的操作：io操作—文件描述符）</p><h5 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5><p>有名字：体现在文件系统可见性，因为其它进程都能看见这个管道文件，因此都能打开可以用于任意（本机）进程间通信<br>（单向通信）所以一个管道使用的时候就必须确定数据流向，但是不能一创建就确 定，因为我们不确定谁读谁写。   因此，操作系统提供两个描述符来供<br>使用，一个读一个写，这样的确定方向就是将对应的一段关闭掉就可以，这样操作系统就把方向的控制权交给用户了<br>接口：pipe（int fd[2]）fd[0]— 读  fd[1]—写</p><h4 id="信号量（semophore）"><a href="#信号量（semophore）" class="headerlink" title="信号量（semophore）"></a>信号量（semophore）</h4><p>信号量并不是用来数据传输的，而是用来进程控制，是解决进程间同步与互斥问题<br>是一个具有等待队列的计数器<br>释放资源+1，<br>获取资源-1，<br>当计数器的值不大于0，意味着没有资源，想要获取信号量资源（计数器-1）的就需要等待<br>同步：如果现在没有资源，等待，等待别人释放资源，别人释放资源后会通知等待的人<br>互斥：一元信号量实现互斥（计数器是0或 1）   </p><h4 id="消息队列（message-queue）"><a href="#消息队列（message-queue）" class="headerlink" title="消息队列（message queue）"></a>消息队列（message queue）</h4><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   它通常在内核中创建一个消息队列，其它的所有进程都可以通过相同的<code>IPC_KEY</code> 打开消息队列<br>这时候既可以向消息队列中放数据，也可以从中拿数据，但是这样的数据就有可能拿错了，拿到的不是自己的数据，因此消息队列中能够放的数据是有类型的数据块，并且读写的时候只能按消息块来发送/接收。</p><h4 id="信号（sinal）"><a href="#信号（sinal）" class="headerlink" title="信号（sinal）"></a>信号（sinal）</h4><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>它是通过软中断的方式来进行的，信号产生之后第一时间也不是直接处理，而是先存储下来，处理信号<br>为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去准备处理事件，事件处理完毕后进程回到原先运行的位置继续运行   </p><p><strong>信号的产生-&gt;信号的注册-&gt;注销信号-&gt;信号的处理</strong><br>Linux下有62种信号，kill -l查看<br>信号分两类：普通信号（不可靠信号1~31)(非实时信号)<br>可靠信号（34~64）(实时信号)</p><p><strong>信号的产生：</strong>   </p><ul><li>1.硬件中断产生  Ctrl+C</li><li>2.程序异常   SIGFPE   SIGSEGV  </li><li>3.软件条件产生<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line">kill(getpid(),SIGINT);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">()</span></span>;   </span><br><span class="line">raise(SIGTERM);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">sigqueue</span><br><span class="line">alarm(<span class="number">3</span>); <span class="comment">// 在3秒后向进程发送SIGALRM信号，返回值会取消上一次的定时器，并且返回上一次定时器剩余时间</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心转储（core dump）</strong>：<br>保存当前程序运行的数据以及调用栈信息，用于错误原因定位调试。如果程序运行出现错误，可以直接通过core文件来gdb调试（有些错误可能偶然发生）  coredump默认关闭：隐私安全/资源占用   </p><p><strong>信号的注册：</strong><br>pcb中有一个信号结构体,信号注册/进程发送信号，就是修改这个进程pcb中关于信号的pending位图，将相应的信号为置1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">sigset_t</span> pending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号的阻塞</strong>：暂时不处理信号（阻止信号的递达），并不是不接收信号,<br>pcb中还有一个信号位图block，要阻止一个信号就是修改pcb中关于信号的<code>block</code>位图，将相应的信号位置1，这个位置就像是一个备注说明如果接收到这<br>个信号暂时不处理   </p><p>信号未决：这是一种状态，信号从注册成功到信号递达之间   </p><p><strong>信号的注销：</strong><br>就是从<code>pending</code>集合中将即将处理的信号相应位置0（从pcb的<code>pending</code>集合中移除）<br>非可靠信号注册就是将相应pending位图置1，然后添加一个<code>sigqueue</code>结构到链表中，之后如果有相应信号到来，一看位图已经            置1那么就不做任何操作，意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了！！！   </p><blockquote><p>可靠信号就是不管有没有注册都要置1，并且添加结点到链表中，所以不会丢信号。<br>非可靠注销就是删除链表结点，相应位图置0.<br>可靠信号删除结点，判断是否有相同信号结点，如果没有则位图置0，如果有则置1；</p></blockquote><p><strong>信号的递达（信号的处理）：</strong>  </p><ul><li>默认操作——安装操作系统中对信号事件的既定处理方式   </li><li>忽略操作——直接将信号丢掉   </li><li><p>自定义处理—–用户自定义事件处理方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signal接口</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    signum：信号的编号</span><br><span class="line">    handler：处理方式</span><br><span class="line">    SIG_IGN 忽略</span><br><span class="line">    SIG_DFL 默认</span><br></pre></td></tr></table></figure></li></ul><p><strong>信号的捕捉流程：</strong><br> 信号并不是立即处理，而是选择一个合适的时机处理，合适的时机就是当前程序从==内核态==切换到==用户态==的时候<br>程序如何从内核态切换到用户态：发起系统调用，程序异常，中断时<br>信号是当我们发起系统调用/程序异常/中断当前程序从用户态切换到内核态，去处理这些事情，处理完毕后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有，就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕后再次返回内核态，判断如果没有信号要处理了就调用<code>sys_sigreturn</code>返回用户态（我们程序之前的运行位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigaddset</span><br><span class="line">sigdelst</span><br><span class="line">sigfillset</span><br><span class="line">sigprocmask信号阻塞接口，阻塞函数，向block添加信号</span><br><span class="line">sigismember </span><br><span class="line">sigpending</span><br></pre></td></tr></table></figure><p>struct sigqueue</p><p>操作系统如何通知父进程说子进程退出了？<br>信号：SIGCHLD -17号信号<br>用户自定义信号：SIGCHLD -17处理方式，相当于提前告诉进程，当接收到这个信号时使用waitpid，这样就不用一直等待 </p><h4 id="共享内存（shared-memory）"><a href="#共享内存（shared-memory）" class="headerlink" title="共享内存（shared memory）"></a>共享内存（shared memory）</h4><p>是进程间通信速度最快的方式<br>其它的进程间通信方式，都会涉及到将用户空间的数据拷贝到内核空间（因为公共缓冲区都在内核空间），这是两步操作（拷入和拷出）<br>而共享内存的原理是多个进程将同一块物理内存映射到自己的虚拟地址空间，以这种方式实现数据共享，操作这个虚拟地址就是操作这个物理内存，相较于其它通信方式，少了两步用户空间和内核空间的拷贝过程，因此速度最快<br>共享内存操作步骤：    共享内存的生命周期随内核<br>1.创建/打开一块共享内存<br>2.将这块共享空间映射到自己的虚拟地址空间<br>3.各种内存操作<br>4.解除映射关系<br>5.删除共享内存  </p><h4 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h4><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。因此被广泛应用于网络通信中。</p><h3 id="进程间通信的实现"><a href="#进程间通信的实现" class="headerlink" title="进程间通信的实现"></a>进程间通信的实现</h3><h4 id="匿名管道通信"><a href="#匿名管道通信" class="headerlink" title="匿名管道通信"></a>匿名管道通信</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个匿名管道的demo</span></span><br><span class="line"><span class="comment"> *      匿名管道操作：</span></span><br><span class="line"><span class="comment"> *          创建：pipe</span></span><br><span class="line"><span class="comment"> *          读写：read write</span></span><br><span class="line"><span class="comment"> *      匿名管道仅能用于具有亲缘关系的进程间通信</span></span><br><span class="line"><span class="comment"> *      创建匿名管道必须在创建子进程之前，否则子进程将无法复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程 读</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程 写</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *ptr = <span class="string">"hello world"</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名管道通信"><a href="#命名管道通信" class="headerlink" title="命名管道通信"></a>命名管道通信</h4><p>这是一个命名管道的实现实例，实现两个进程聊天功能<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(file, <span class="number">0664</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fifo exist!!\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open fifo success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0x00</span>, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = read(fd, buff, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer say:%s\n"</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="管道符实现命令"><a href="#管道符实现命令" class="headerlink" title="管道符实现命令"></a>管道符实现命令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个实现管道符的demo</span></span><br><span class="line"><span class="comment"> *  命令：ps -ef |grep ssh</span></span><br><span class="line"><span class="comment"> *  一个进程运行ps程序，一个进程运行grep程序</span></span><br><span class="line"><span class="comment"> *  ps程序就需要将结果通过匿名管道传递给grep程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程运行grep程序处理ps的结果（从管道读数据）</span></span><br><span class="line">        dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/grep"</span>, <span class="string">"grep"</span>, <span class="string">"ssh"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程运行ps程序，将结果写入管道</span></span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/ps"</span>, <span class="string">"ps"</span>, <span class="string">"-ef"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一块共享内存的demo，共享数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x01234567</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int shmget(key_t key, size_t size, int shmflg);</span></span><br><span class="line">    <span class="comment">//  key：共享内存在系统中的标识啊</span></span><br><span class="line">    <span class="comment">//      ftok这个接口可以通过一个文件计算出一个key值</span></span><br><span class="line">    <span class="comment">//  size：共享内存大小</span></span><br><span class="line">    <span class="comment">//  shmflg：IPC_CREAT 创建|权限</span></span><br><span class="line">    <span class="comment">//  返回值：共享内存的操作句柄</span></span><br><span class="line">    shmid = shmget(IPC_KEY, <span class="number">32</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmget error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建的这个共享内存无法直接操作，因为我们只能操作虚拟地址空间</span></span><br><span class="line">    <span class="comment">//中的地址，因此第二步就是将共享内存映射到虚拟地址空间，让我们</span></span><br><span class="line">    <span class="comment">//能够通过虚拟地址来访问这块内存</span></span><br><span class="line">    <span class="comment">//void *shmat(int shmid, const void *shmaddr, int shmflg);</span></span><br><span class="line">    <span class="comment">//  shmid:  共享内存句柄</span></span><br><span class="line">    <span class="comment">//  shmaddr：映射首地址（通常置空）</span></span><br><span class="line">    <span class="comment">//  shmflg：</span></span><br><span class="line">    <span class="comment">//      SHM_RDONLY  只读 否则可读可写</span></span><br><span class="line">    <span class="comment">//  返回：映射到虚拟地址空间的首地址 失败：(void*)-1</span></span><br><span class="line">    <span class="keyword">void</span> *shm_start = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmat error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while(1) &#123;</span></span><br><span class="line"><span class="comment">        sprintf(shm_start, "%s---%d\n", "吃什么呢??", i++);</span></span><br><span class="line"><span class="comment">        sleep(1);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//int shmdt(const void *shmaddr);</span></span><br><span class="line">    <span class="comment">//  解除共享内存在虚拟地址空间中的映射关系</span></span><br><span class="line">    <span class="comment">//  shmaddr: 映射的首地址</span></span><br><span class="line">    <span class="comment">//  返回值 成功：0  失败：-1</span></span><br><span class="line">    shmdt(shm_start);</span><br><span class="line">    <span class="comment">//int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span></span><br><span class="line">    <span class="comment">//  cmd:</span></span><br><span class="line">    <span class="comment">//      IPC_RMID    删除共享内存</span></span><br><span class="line">    <span class="comment">//  buf：存放获取到的共享内存信息</span></span><br><span class="line">    <span class="comment">//  删除共享内存（并不会立即删除，会判断映射链接数是否为0）</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个演示signal接口修改信号处理方式的demo</span></span><br><span class="line"><span class="comment"> *  信号的处理方式有三种：</span></span><br><span class="line"><span class="comment"> *      忽略</span></span><br><span class="line"><span class="comment"> *      默认</span></span><br><span class="line"><span class="comment"> *      自定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    b++;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv signo:%d--%d\n"</span>, signo, c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line">    <span class="comment">//  signum: 信号的编号</span></span><br><span class="line">    <span class="comment">//  handler：   处理方式</span></span><br><span class="line">    <span class="comment">//      SIG_IGN 忽略</span></span><br><span class="line">    <span class="comment">//      SIG_DFL 默认</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGINT, sigcb);</span><br><span class="line">    signal(SIGQUIT, sigcb);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        printf("-----------\n");</span></span><br><span class="line"><span class="comment">        kill(getpid(), SIGINT);</span></span><br><span class="line"><span class="comment">        if (++i == 3) &#123;</span></span><br><span class="line"><span class="comment">            signal(SIGINT, SIG_DFL);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sigcb(SIGQUIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="僵尸进程的避免"><a href="#僵尸进程的避免" class="headerlink" title="僵尸进程的避免"></a>僵尸进程的避免</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*僵尸进程的避免：</span></span><br><span class="line"><span class="comment"> *  僵尸进程是子进程先于父进程退出，操作系统会通知父进程说你的子进</span></span><br><span class="line"><span class="comment"> *  程挂了，你去收尸吧，但是父进程没有管，所以子进程死不瞑目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  操作系统如何通知父进程说子进程退出呢？</span></span><br><span class="line"><span class="comment"> *      信号：SIGCHLD -17号信号</span></span><br><span class="line"><span class="comment"> *  以前因为没有学信号，因此我们避免产生僵尸进程，只能让父进程一直</span></span><br><span class="line"><span class="comment"> *  等待子进程的退出（因为实在是不知道子进程到底什么时候退出，），</span></span><br><span class="line"><span class="comment"> *  浪费了父进程资源，</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  现在学了信号完全可以这样做：</span></span><br><span class="line"><span class="comment"> *      自定义信号：SIGCHLD的处理方式，相当于提前告诉进程，当接收到</span></span><br><span class="line"><span class="comment"> *      这个信号的时候使用waitpid，这样就不用一直等了；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用非阻塞的循环来处理SIGCHLD信号</span></span><br><span class="line">    <span class="comment">//因为SIGCHLD信号不是可靠信号，有可能丢失</span></span><br><span class="line">    <span class="comment">//因此就有可能漏掉僵尸子进程没有处理，</span></span><br><span class="line">    <span class="comment">//所以一旦接收到信号就处理到不能处理为止</span></span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"have child exit!!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGCHLD, sigcb);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;进程通信概念&quot;&gt;&lt;a href=&quot;#进程通信概念&quot; class=&quot;headerlink&quot; title=&quot;进程通信概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="signal" scheme="https://LiuZiQiao.github.io/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://LiuZiQiao.github.io/2018/12/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://LiuZiQiao.github.io/2018/12/08/旋转数组的最小数字/</id>
    <published>2018-12-08T05:40:23.000Z</published>
    <updated>2018-12-08T05:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>咋眼一看这题，很简单啊，就一次遍历找到最小值就可以了啊，那答案就很简单。如下给出一般解决方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;rotateArray.size()<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i] &gt; rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这个题目时我们应该更加进一步去思考该题，这个题难道就这么简单？其实不然，当我们控制其时间复杂度时，我们可以思考另外一种方式来解决，如下给出思路：   </p><p>我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。<br> 我们试着用<strong>二分查找法</strong>的思路在寻找这个最小的元素。<br>首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。<br>接着我们得到处在数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。<br>我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。<br>我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的两个指针，去得到和比较新的中间元素，循环下去。<br>按照上述的思路，我们的第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最后第一个指针将指向前面子数组的最后一个元素，而第二个指针会指向后面子数组的第一个元素。<br>也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rotateArray.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[begin]&lt;rotateArray[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">                middle = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[middle] &gt;= rotateArray[begin])</span><br><span class="line">            &#123;</span><br><span class="line">                begin = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[middle] &lt;= rotateArray[begin])&#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> rotateArray[middle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二分" scheme="https://LiuZiQiao.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程之线程</title>
    <link href="https://LiuZiQiao.github.io/2018/12/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>https://LiuZiQiao.github.io/2018/12/05/Linux系统编程之线程/</id>
    <published>2018-12-05T14:32:12.000Z</published>
    <updated>2018-12-05T14:53:35.938Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p><strong>回顾进程</strong><br>在介绍线程之前，我们先来回顾下进程，进程的定义就是指一个具有独立功能的程序在某个数据集上的一次动态执行的过程，是系统进程资源分配和调度的基本单元。 一次任务的运行可以并发激活多个进程，这些进程相互合作完成该任务的一个最终目标。 操作系统对进程的描述：PCB（进程控制块）Linux下的进程描述——task_struct。   </p><p><strong>那么线程是什么呢？</strong>   </p><ul><li>线程是进程中的一条执行流，Linux下的线程是用进程的PCB模拟的，所以Linux下的线程也叫轻量级进程。 <strong>进程是资源分配的基本单位,</strong> 那么<strong>线程就是CPU调度的基本单位。</strong> </li><li>一个进程至少有一个线程，因此我们的进程其实就是线程组。进程id = 线程组id，所以才说Linux下的进程是线程组，资源分配的基本单位，并且进程中的线程共享大部分进程的资源。</li><li>Linux下的线程共用进程的虚拟地址空间，与进程内的其他线程共享进程的资源,共享代码段，数据段。</li><li>文件描述符表，信号处理方式，工作目录用户id</li><li>线程不仅共享进程的这些资源，并且还独自有一些资源：栈，上下文数据。</li></ul><p><strong>有了进程为什么还要线程呢？</strong><br>线程的优缺点正好说明了我们操作系统为什么还要线程。   </p><blockquote><p>优点：</p><ul><li>线程的创建和销毁成本更低。</li><li>线程的调度切换成本也会更低</li><li>线程间通信更加方便</li><li>线程执行的力度更加细致<br>缺点 </li><li>缺乏访问控制：进程是访问的基本粒度，在一个线程中调用可能会对整个进程造成影响</li><li>多个线程对临界资源进行操作时会造成数据混乱</li><li>性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享一个处理器。如果密集型线程数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加额外的同步和调度开销，而可用的资源不变。</li><li>调试难度大大提高：编写与调试一个多线程程序比单线程程序困难的多。</li></ul></blockquote><p>即便是线程有一些缺点，但它的作用依然非常强大，任然引用与一些项目中。</p><p>进程的一些特征：<br>我们知道，进程有进程的标识符pid，那么线程也有自己的标识符tid</p><h3 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h3><p>1.pthread_create函数<br>功能：创建线程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line">    函数参数解释：</span><br><span class="line">      <span class="keyword">pthread_t</span> *tid：一个进程内的各个线程是由线程ID标识的，如果新线程创建成功，返回tid指针。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr：每个线程有多个属性，包括优先级、初始栈大小、是否是一个守护线程等等。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *)：线程启动函数，线程从调用这个函数开始，或显示结束（调用pthread_exit()），或隐式结束（让该函数返回）。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *arg：线程执行func函数的传递参数。</span><br></pre></td></tr></table></figure></p><p>2.pthread_join函数 功能：等待一个线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line">      <span class="keyword">void</span> **status：二级指针，如果status指针非空，那么所等待线程的返回值将存放在status指向的位置。</span><br></pre></td></tr></table></figure></p><p>3.pthread_self函数  功能：返回线程ID<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      跟进程比较，相当于getpid。</span><br></pre></td></tr></table></figure></p><p>4.pthread_detach函数 功能：线程分离<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;　　</span><br><span class="line">      线程或者是可汇合的（joinable），或者是脱离的（detach）。当可汇合的线程终止时，线程ID和退出状态将保留，知道另外一个线程调用pthread_join。脱离的线程终止时，释放所有的资源，因此我们不能等待它终止。若要一个线程知道另一个线程的终止时间，我们就要保留第二个线程的可汇合性。</span><br></pre></td></tr></table></figure></p><p>5.pthread_exit函数  功能：线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> **status)</span></span>;　　</span><br><span class="line">      若线程未脱离，那么它的线程ID和退出状态将保留到另外一个线程调用pthread_join为止。</span><br></pre></td></tr></table></figure></p><p>下面我们演示一个线程的创建<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> *tid = (<span class="keyword">pthread_t</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child~~~%p\n"</span>, *tid);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//void pthread_exit(void *retval);</span></span><br><span class="line">        <span class="comment">//用于退出自己，可以返回一个数据</span></span><br><span class="line">        <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//演示多个线程的并行</span></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="comment">//int pthread_create(pthread_t *thread, pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//  void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">    <span class="comment">//  thread: 用于获取线程id（用户态的线程id）</span></span><br><span class="line">    <span class="comment">//  attr：  设置线程属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//  start_routine：线程入口函数，线程所运行的代码</span></span><br><span class="line">    <span class="comment">//  arg：   线程入口函数的参数</span></span><br><span class="line">    <span class="comment">//  返回值：成功：0     失败：非0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)&amp;tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid);  <span class="comment">//用于取消标识符为tid线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//pthread_t pthread_self(void);</span></span><br><span class="line">        <span class="comment">//获取线程自身的线程id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am main~~~~!%d---%p\n"</span>, pid, pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个线程分离演示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int pthread_detach(pthread_t thread);</span></span><br><span class="line">    <span class="comment">//  分离指定的线程，被分离的线程退出时自动被回收资源</span></span><br><span class="line">    <span class="comment">//  因为资源立即被回收，所以不会保存返回值，也就无法被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定要分离的线程id</span></span><br><span class="line">    <span class="comment">//pthread_t pthread_self(void)</span></span><br><span class="line">    <span class="comment">//  获取自身线程 id</span></span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">"laozaotai!!\n"</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line">    <span class="comment">//这是一个阻塞函数，如果线程没有退出就一直等待</span></span><br><span class="line">    <span class="comment">//这里等待的线程必须是处于joinable属性才可以被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定等待的线程id</span></span><br><span class="line">    <span class="comment">//  retval：获取线程的退出返回值</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="keyword">if</span> (err == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread is detached!!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child thread:%s\n"</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个线程的作用不大，但是一堆线程能干大事，了解王者荣耀的人可能会知道，王者荣耀采用了多线程开发技术，多线程模式，这个模式的作用可以让玩家在团战中帧率更高，打起来更加的流畅，这就是多线程的一个好处。   </p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>因为线程是CPU调度的基本单位，因此多个线程就有可能同时争抢临界资源，那么这种情况就有可能导致数据的二义性。打个比方：当两个线程同时向一个文件修改数据时，那么这个文件的数据到底让那个线程修改？这就是一个线程安全问题。</p><p>为了解决线程安全问题，我们引入了线程的同步与互斥   </p><ul><li><p>互斥：保证数据同一时间唯一的访问，那么我们就可以用一个锁来锁住当前线程，不让其它线程进行访问，即互斥锁   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init  <span class="comment">//初始化   </span></span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock   </span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock </span><br><span class="line">pthread_mutex_timedlock <span class="comment">//指定一段时间内获取锁</span></span><br></pre></td></tr></table></figure></li><li><p>死锁：在使用互斥锁的同时，有可能会发生死锁，在前面有关于<a href="https://LiuZiQiao.github.io/2018/11/28/Linux下的死锁/">死锁问题</a>的文章,这里就不做赘述了</p></li><li><p>同步：保证对临界资源访问的时序性，即我们需要条件变量通知线程或等待线程，满足操作条件，才可以操作，不满足则需要等待，而条件满足就需要其它线程修改条件，并且通知一下等待的进程    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init<span class="comment">//初始化</span></span><br><span class="line">pthread_cond_destroy</span><br><span class="line">pthread_cond_broadcast  <span class="comment">//唤醒多个线程，广播唤醒</span></span><br><span class="line">pthread_cond_wait<span class="comment">//等待</span></span><br><span class="line">pthread_cond_timedwait</span><br><span class="line">pthread_cond_signal  <span class="comment">// 唤醒第一个等待的线程，通知一个线</span></span><br></pre></td></tr></table></figure></li></ul><p>下面演示一个互斥锁使用场景，抢票<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">yellow_cow</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//lock 阻塞加锁，trylock 非阻塞加锁，timedlock 限时阻塞加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"cow %d get ticket:%d\n"</span>, id, ticket);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在任何有可能退出的地方都必须在退出前解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">4</span>, i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  互斥锁变量的初始化</span></span><br><span class="line">    <span class="comment">//int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span></span><br><span class="line">    <span class="comment">//  const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line">    <span class="comment">//  这种初始化，在使用结束后必须要释放</span></span><br><span class="line">    <span class="comment">//  mutex:  互斥锁变量</span></span><br><span class="line">    <span class="comment">//  attr：  属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,yellow_cow,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line">    <span class="comment">//  销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;线程的概念&quot;&gt;&lt;a href=&quot;#线程的概念&quot; class=&quot;headerlink&quot; title=&quot;线程的概念&quot;&gt;&lt;/a&gt;线程的
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
      <category term="thread" scheme="https://LiuZiQiao.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Vim中Ctrl+s问题</title>
    <link href="https://LiuZiQiao.github.io/2018/12/03/Ctrl-s%E9%97%AE%E9%A2%98/"/>
    <id>https://LiuZiQiao.github.io/2018/12/03/Ctrl-s问题/</id>
    <published>2018-12-03T15:50:20.000Z</published>
    <updated>2018-12-03T15:55:24.865Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20181203234814813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>习惯了在IDE环境下写代码而突然换到VIM中的人看过来，这是需要注意的坑，我们习惯在VIM中写完进行<code>CTRL + S</code>进行保存，然后就卡住不动了，你最有可能的操作就是关闭当前打开的VIM，但是关闭后我们的代码就没有了，哈哈，刚写的代码没了你是什么心情，我就是一遍一遍的踩到这个坑才研究了下<code>CTRL + S</code>在VIM中的作用，其实在VIM中<code>CTRL + S</code>是锁住的意思，锁住当前页面，我们用<code>CTRL + q</code>解除就可以了，这下你就不会在傻乎乎的关闭了。<br>q解除就可以了，这下你就不会在傻乎乎的关闭了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181203234814813.png?x-oss-pro
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串替换</title>
    <link href="https://LiuZiQiao.github.io/2018/12/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/"/>
    <id>https://LiuZiQiao.github.io/2018/12/02/字符串替换/</id>
    <published>2018-12-02T12:15:55.000Z</published>
    <updated>2018-12-02T12:16:27.748Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。</p><p>给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。</p><p>测试样例：</p><blockquote><p>“A%sC%sE”,7,[‘B’,’D’,’F’]<br>返回：”ABCDEF”</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：定义一个新的字符串来接收返回的字符串，接收过程中将%s去掉即可。话不多说，上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">formatString</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; arg, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">string</span> strRet;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;A.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'%'</span> &amp;&amp; A[i+<span class="number">1</span>] == <span class="string">'s'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               strRet += arg[index++];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                strRet += A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;m;++index)</span><br><span class="line">        &#123;</span><br><span class="line">            strRet += arg[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;实现
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>微信红包</title>
    <link href="https://LiuZiQiao.github.io/2018/12/02/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85/"/>
    <id>https://LiuZiQiao.github.io/2018/12/02/微信红包/</id>
    <published>2018-12-02T12:05:31.000Z</published>
    <updated>2018-12-02T12:05:56.977Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</p><p>给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。</p><p>若没有金额超过总数的一半，返回0。</p><p>测试样例：</p><blockquote><p>[1,2,3,2,2],5<br>返回：2</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方法一：C++中学过map的人可能做这个题会非常简单，利用map键值对的巧妙来对数据的处理。以下就是根据map<int,int>的第一个int用来存储被计数的值，右边来存放出现的个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[gifts[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second &gt; n/<span class="number">2</span>) <span class="comment">//second就是m的第二个参数，即第二个int</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> e.first;  <span class="comment">//同理，first是第一个int了</span></span><br><span class="line"></span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></int,int></p><p>方法二：当然，非常了解C++库中函数的人可能会想到一个非常简单的方法，利用STL中的算法count函数计数功能，三两行代码就能解决这个问题。利用出现次数超过总元素个数一半知道这个数一定会是中位数，当然，前提是这个数组有序。我们看下面的具体代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sort(gifts.begin(),gifts.end());</span><br><span class="line">        <span class="keyword">int</span> ret = count(gifts.begin(),gifts.end(),gifts[n/<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; n/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> gifts[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法三：在上面两种特殊方式做出的基础上，我们思考了用普通的算法来求解该问题，我们的思路是首先对数组里的数进行一个判断，找出出现次数最多的那个数，然后再对它进行计数判断。以下就是具体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gift = gifts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                gift = gifts[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;春节
      
    
    </summary>
    
      <category term="每日一题" scheme="https://LiuZiQiao.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下死锁的产生，预防，避免，检测及解除</title>
    <link href="https://LiuZiQiao.github.io/2018/11/28/Linux%E4%B8%8B%E7%9A%84%E6%AD%BB%E9%94%81/"/>
    <id>https://LiuZiQiao.github.io/2018/11/28/Linux下的死锁/</id>
    <published>2018-11-28T13:54:25.000Z</published>
    <updated>2018-11-28T14:00:08.235Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h3><p><img src="https://img-blog.csdnimg.cn/2018112821520271.png" alt="1"><br>所谓死锁就是指在多道程序系统中，一组进程中的每个进程都无期限的等待被该组进程中的另一个进程所占有且永远不会被释放的资源，这种现象称系统处于死锁状态，简称死锁。处于死锁状态的进程成为死锁进程。 如上面的图。    </p><p>　　系统发生死锁会大量浪费系统资源甚至会导致整个系统崩溃</p><h4 id="死锁的产生的原因"><a href="#死锁的产生的原因" class="headerlink" title="死锁的产生的原因"></a>死锁的产生的原因</h4><p>产生死锁的原因主要有两个：一是竞争资源，系统提供的资源有限，不能满足每个进程的需求；二是多道程序运行时，进程的推进顺序不合理。<br><strong>这里的资源我们作如下解释</strong><br>系统资源分为两类：<strong>永久性资源</strong>(可重生资源)，是指那些可供进程重复利用，长期存在的资源，如内存，CPU等硬件资源，以及数据集文件，共享程序代码等软件资源。<strong>临时性资源</strong>(消耗性资源)，是指由某个进程产生，只为另一个进程使用一次，或经过短暂时间后便不可再使用资源，如I/O和时钟中断，消息等。<br>    <strong>两种资源都可能导致死锁。</strong></p><h4 id="死锁的产生必要条件"><a href="#死锁的产生必要条件" class="headerlink" title="死锁的产生必要条件"></a>死锁的产生必要条件</h4><p>对于永久性资源，产生死锁有以下四个必要条件：<br>1.互斥条件:进程独占所分配的资源且排斥其他进程使用。进程互斥使用资源，即任意时刻一个进程被进程使用，其他进程申请一个正在被占有的资源时，申请者要等待直至资源被占有者释放。<br>2.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由使用者自愿释放。<br>3.请求与保持：进程已经得到至少一个资源时，又提出新的资源请求，而该资源又被其他进程所占有，此时进程会等待直至得到所需资源，在等待期间会继续占有已经得到的资源。<br>4.循环等待条件：在发生死锁时，必然存在一个进程等待队列p1,p2,p3,…,pn，其中p1等待p2占有的资源，p2等待p3占有的资源，…， pn等待p1占有的资源，形成一个进程等待环路。环路中每个进程已占有的资源同时被另一个进程所申请，即前一个进程占有后一个进程所申请的资源。</p><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>解决死锁方法可分为两中：一是不让死锁发生；二是等死锁发生后再解决，具体有以下四种方法</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>通过破坏产生死锁的必要条件（除第一个互斥条件外的其他条件）来防止死锁发生。此方法会导致系统资源利用率过低。</p><p>1.破坏“不可剥夺”条件<br>在允许进程动态申请资源的前提下做出如下规定：一个进程在申请新资源的要求不能立即得到满足，该进程进入等待状态。而处于等待状态下的进程的全部资源可以被他人剥夺，被剥夺的资源重新放到资源表中。</p><p>　　该方法适合那些状态是容易保存和恢复的资源，例如，CPU、内存等。但此方法实现起来较为复杂，且代价很大。因为一个资源在使用一段时间后被强制剥夺会造成前阶段工作失效，甚至可能出现某个进程反复申请和释放资源的情况，使得进程执行无限期推迟，还增加了系统开销，延长了进程的周转时间，降低了系统的吞吐量和性能。    </p><p>2.破坏“请求和保持”条件<br>实现这一操作可以用两种方法。<br>方法一：每个进程在执行前必须申请它所需的全部资源，仅当系统能满足进程的资源申请并把资源一次性分配给进程后，进程才能执行。这是静态资源分配策略。这种方法的缺点是会严重浪费系统资源，降低资源利用率。</p><p>方法二：仅当进程没有占有资源时才允许他去申请资源，如果进程已占用了某些资源而又要申请新的资源，那他必须先归还所占有的资源再申请新的资源。   </p><p>3.破坏“循环等待”条件<br>　采用资源有序分配策略，基本思想是将系统中所有的资源顺序编号，一般原则是紧缺、稀有的资源编号较大。进程申请资源时，必须严格按照编号顺序进行，否则不予分配。即一个进程只有得到编号较小的资源后，才能申请编号较大的资源。释放资源时应先释放编号较大的资源。<br>　　此方法硬性规定申请资源，会给用户编程带来限制，增加了资源使用者的不便；此外如何合理的编号也是一件让人头疼的事。如有进程违反了规定也会造成死锁。 </p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>上述几种死锁预防策略增加了较强的限制条件，从而实现较为简单，但严重影响了系统性能，所以在实际应用中这几种方法使用少之又少，更好地方法是死锁避免。</p><p>　　死锁避免的基本思想：系统对进程发出的每个系统能满足的资源申请进行动态检测，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，反之予以分配。</p><ol><li>安全与不安全状态<br>　　由于避免死锁策略中允许进程动态地申请资源，所以系统要提供某种方法，在分配资源前，先分析资源分配的安全性。当估计到可能有死锁发生时及时设法避免。<br>　　如果操作系统能保证所有进程能在有限时间内获得需要的全部资源，则称系统处于“安全状态”，否则就是不安全的。<br>　　所谓的安全状态是指，如果系统的所有进程构成了一个安全序列，则系统处于安全状态。那么什么又是安全序列呢？如果一个进程序列：p1,p2,…,pnp1,p2,…,pn，对于其中每个进程 pi(1&lt;=i&lt;=n)pi(1&lt;=i&lt;=n)，它以后尚需的资源总量不超过系统当前剩余资源量与所有进程当前占有资源总量之和，那么这个进程序列便称为安全序列。</li></ol><p>2.银行家算法<br>　　银行家算法是最经典的死锁避免算法之一。把系统比作银行家，系统资源比作周转资金，申请资源的进程比作向银行家带款的客户。那么银行家就要保证两件事：一是银行家能贷款给若干客户，满足客户对资金的需求；二是银行家可以安全地收回其全部贷款而不至于破产。为此，银行家做出如下规定：</p><p>当一个客户对资金的最大需求量不超过银行家现有资金总量时才可以接纳该客户。</p><p>客户可以分期贷款，但贷款总量不能超过该客户对资金的最大需求量。</p><p>当银行家现有资金不能满足客户尚需的贷款额度时，对客户的贷款可延迟支付，但必须保证客户在有限的时间内得到贷款。</p><p>当客户得到所需的全部资金后，必须在有限的时间内归还所有资金。</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>上述的死锁避免和死锁预防都是以牺牲系统效率和浪费资源为代价，不符合我国传统勤俭节约的美德，我们要采取更好地方法——系统为进程分配资源时，不采取任何限制措施来保证系统不进入死锁状态，即允许死锁发生，但系统会不断监督进程的进展路径，判断死锁是否真的发生，一旦判断发生死锁，则采取专门的措施解决死锁，并以最小的代价使整个系统恢复正常，这就是死锁检测和解除。</p><p>　　死锁检测的实质是确定是否存在“循环等待”条件，检测算法确定死锁发生并识别出与死锁有关的进程和资源。下面介绍一种检测机制：</p><p>为每个进程和资源指定唯一编号。<br>设置一张资源分配表，表中包含“资源号”和占有该资源的“进程号”两项。资源分配表记录了每个资源正在被那进程占有。<br>设置一张进程等待表，表中包含“进程号”和该进程所等待的“资源号”两项。<br>死锁检测算法：当任一进程申请一个已被其他进程占有的资源时，通过反复查找资源分配表和进程等待表 ，来确定该进程对这个资源的申请是否会导致环路，若是，便确定出现死锁。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>要解除死锁就要剥夺资源，那就要考虑如下几个问题：</p><p>选择牺牲一个进程，即要剥夺哪个进程的哪些资源？</p><p>被牺牲的进程重新运行或回退到某一点继续运行。</p><p>如何保证不发生“饿死现象”，即如何保证不会总是剥夺同一个进程的资源，从而导致该进程处于“饥饿状态”。</p><p>“最小代价”，即最经济合算的算法，使得进程回退带来的开销最小。要考虑到如下几个因素：</p><ul><li>进程优先级</li><li>进程运行了多久？距离完成任务还要多久？</li><li>该进程使用的资源的种类和数目，这些资源剥夺难度如何？</li><li>为完成该进程还需要多少资源？<br>有多少进程要被撤销？</li><li>该进程被重新启动的次数？</li></ul><p>死锁解除法归为两大类。</p><ul><li>剥夺资源。<br>　　使用挂起/激活机制挂起一些进程，剥夺他们的资源给死锁进程，用来解除死锁，等死锁解除后再激活被挂起的资源。剥夺的顺序以花费最小资源数为依据。每次剥夺后需再次调用死锁检测算法。被重新激活的挂起进程必须重新申请资源。为安全的释放资源，该进程必须返回到分配资源前的某一点。常用方法有：</li></ul><p>还原算法，恢复计算结果和状态。<br>设置检查点，用来恢复分配前的状态。</p><ul><li>撤销进程。（简单粗暴）<br>　　撤销死锁进程，把它们占有的资源分配给死锁进程，直至死锁结束。可以撤销所有死锁进程或逐个撤销死锁进程，每撤销就检测死锁是否存在，若不存在就停止撤销。</li></ul><p>衡量撤销代价的标准： </p><ol><li>被撤销进程的优先数 </li><li>不同类型的进程的撤销代价 </li><li>重启进程并运行到当前撤销点所需的代价</li></ol><p>　　由于衡量标准过多，为了简化，把系统的资源分成四个等级，对于不同级别下出现的死锁，采取不同的方法。</p><p>内部资源：由操作系统使用，PCB表等——利用资源编号预防死锁。</p><p>内存：由用户使用——采用抢占式预防。</p><p>作业资源：可分配的设备和文件——可采用死锁避免措施。</p><p>对换空间：每个用户作业在辅助存储器上的空间——采用预先分配方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;死锁的定义&quot;&gt;&lt;a href=&quot;#死锁的定义&quot; class=&quot;headerlink&quot; title=&quot;死锁的定义&quot;&gt;&lt;/a&gt;死锁的
      
    
    </summary>
    
      <category term="Linux" scheme="https://LiuZiQiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>基于MVC用java实现的通用系统后端</title>
    <link href="https://LiuZiQiao.github.io/2018/11/25/%E5%9F%BA%E4%BA%8EMVC%E7%94%A8java%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%9A%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF/"/>
    <id>https://LiuZiQiao.github.io/2018/11/25/基于MVC用java实现的通用系统后端/</id>
    <published>2018-11-25T15:30:49.000Z</published>
    <updated>2018-11-25T15:31:53.265Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://LiuZiQiao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL安装教程</title>
    <link href="https://LiuZiQiao.github.io/2018/11/15/mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://LiuZiQiao.github.io/2018/11/15/mysql安装教程/</id>
    <published>2018-11-15T04:43:07.000Z</published>
    <updated>2018-11-15T05:10:37.584Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>MySQL安装有两种方式，一种是免安装直接下载安装包解压配置即可使用，另外一种就是下载安装</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">MySQL下载地址</a><br><a href="https://pan.baidu.com/s/13KGXf1UwLSfxs_-x7UGdqA" target="_blank" rel="noopener">连接工具下载</a>    <strong>提取码：fquf</strong> </p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>具体安装见<br><a href="https://blog.csdn.net/qq_39478237/article/details/84102513" target="_blank" rel="noopener">https://blog.csdn.net/qq_39478237/article/details/84102513</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;MySQL安装有两种方式，一种是免安装直接下载安装包解压配置即可使用，另外一种就是下载安装&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="MySQL" scheme="https://LiuZiQiao.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>解决MySQL第一次连接失败</title>
    <link href="https://LiuZiQiao.github.io/2018/11/15/%E8%A7%A3%E5%86%B3MySQL%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>https://LiuZiQiao.github.io/2018/11/15/解决MySQL第一次连接失败/</id>
    <published>2018-11-14T16:01:00.000Z</published>
    <updated>2018-11-15T04:42:24.852Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上一篇讲了MySQL数据库的安装，安装之后我们用Navicat工具连接时可能会出现以下这种情况，就这种情况给出了解决办法</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>Navicat for MySQL 连接数据库时报错 client dose not support authentication protocol requested by server;consider</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><img src="https://img-blog.csdnimg.cn/20181115123652200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/20181115123816493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><p><strong>命令如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、use mysql;</span><br><span class="line">2、alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;********&apos;;</span><br><span class="line">3、flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;上一篇讲了MySQL数据库的安装，安装之后我们用Navicat工具连接时可能会出现以下这种情况，就这种情况给出了解决办法&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="工具" scheme="https://LiuZiQiao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
