<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LeetCode】5.最长回文子串</title>
      <link href="/2019/04/22/%E3%80%90LeetCode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/04/22/%E3%80%90LeetCode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;</code></pre><p>注意: “aba” 也是一个有效答案。<br>示例 2：</p><pre><code>输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p><strong>常见错误</strong></p><p>有些人会忍不住提出一个快速的解决方案，不幸的是，这个解决方案有缺陷(但是可以很容易地纠正)：</p><pre><code>反转S，使之变成S′。找到S 和S′   之间最长的公共子串，这也必然是最长的回文子串。</code></pre><p>这似乎是可行的，让我们看看下面的一些例子。</p><pre><code>例如，S = “caba”, S&apos; = “abac”；S 以及S′之间的最长公共子串为“aba”，恰恰是答案。尝试一下这个例子：S= “abacdfgdcaba”,                S&apos; = “abacdgfdcaba”；S 以及 S′之间的最长公共子串为 “abacd” “abacd”，显然，这不是回文。</code></pre><p>当 SS 的其他部分中存在非回文子串的反向副本时，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这给我们提供了一个复杂度为 O(n^2) 动态规划解法，它将占用 O(n^2)的空间（可以改进为使用 O(n) 的空间）。    </p><h3 id="思路二-（动态规划）"><a href="#思路二-（动态规划）" class="headerlink" title="思路二 （动态规划）"></a>思路二 （动态规划）</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑<code>“ababa”</code> 这个示例。如果我们已经知道<code>“bab”</code>是回文，那么很明显，<code>“ababa”</code>一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j)P(i,j) 的定义如下：</p><p>如果子串是回文子串其他情况<br>$$f(i,j)=<br>\begin{cases}<br>true&amp; \text{如果子串Si…Sj是回文子串}\<br>false&amp; \text{其他情况}<br>\end{cases}$$</p><p>因此，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(i,j) = (P(i+1,j-1) and S_i==S_j)</span><br></pre></td></tr></table></figure></p><p>基本示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(i,j) = true; </span><br><span class="line"></span><br><span class="line">P(i,i+1) = (S_i == S_i+_1)</span><br></pre></td></tr></table></figure></p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><p>复杂度分析</p><p>时间复杂度：<code>O(n^2)</code>,这里给出我们的运行时间复杂度为 <code>O(n^2)</code>。</p><p>空间复杂度：<code>O(n^2)</code>，该方法使用<code>O(n^2)</code>的空间来存储表。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()][s.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[j][i] = (s[i] == s[j] &amp;&amp; (i-j&lt;<span class="number">2</span>) || dp[j+<span class="number">1</span>][i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i] &amp;&amp; len &lt; i-j+<span class="number">1</span>)&#123;</span><br><span class="line">                    len = i-j+<span class="number">1</span>;</span><br><span class="line">                    left = j;</span><br><span class="line">                    right = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(left,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【newcoder】最长公共子序列</title>
      <link href="/2019/04/21/day39-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2019/04/21/day39-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们有两个字符串m和n，如果它们的子串a和b内容相同，则称a和b是m和n的公共子序列。子串中的字符不一定在原字符串中连续。<br>例如字符串<code>“abcfbc”</code>和<code>“abfcab”</code>，其中<code>“abc”</code>同时出现在两个字符串中，因此<code>“abc”</code>是它们的公共子序列。此外，<code>“ab”</code>、<code>“af”</code>等都是它们的字串。<br>现在给你两个任意字符串（不包含空格），请帮忙计算它们的最长公共子序列的长度。</p><p>输入描述:   </p><pre><code>输入包含多组数据。</code></pre><p>每组数据包含两个字符串m和n，它们仅包含字母，并且长度不超过1024。</p><p>输出描述:   </p><pre><code>对应每组输入，输出最长公共子序列的长度。</code></pre><p>示例1<br>输入</p><pre><code>abcfbc abfcabprogramming contestabcd mnp</code></pre><p>输出</p><pre><code>420</code></pre><p><a href="https://www.nowcoder.com/questionTerminal/9ae56e5bdf4f480387df781671db5172" target="_blank" rel="noopener">原链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题是一个动态规划问题。对于动态规划求解问题，一般有两个特征：①最优子结构；②重叠子问题</p><p><strong>①最优子结构</strong>     </p><p>设X = (x1,x2,…xn)和Y = (y1,y2,…ym) 是两个序列，将X和Y的最长公共序列记为LCS(X,Y)  <br><br>找出LCS(X,Y)就是一个最优化问题。因为需要找到X和Y最长的公共子序列。而要找X和Y的LCS，就需要考虑X的最后一个元素和Y的最后一个元素。<br>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)</p><p>LCS(Xn-1，Ym-1)就是原问题的一个子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛….）</p><p>为什么是最优的子问题？因为我们要找的是Xn-1 和 Ym-1 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）</p><p>2）如果xn != ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。（都不相等了，怎么公共嘛）。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。</p><p>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。</p><p>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：</p><p>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p><strong>②重叠子问题</strong>   </p><p>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 </p><pre><code>❶LCS(Xn-1，Ym-1)   ❷LCS(Xn-1，Ym)   ❸LCS(Xn，Ym-1)</code></pre><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。   </p><p>由于像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。因为采用递归，它重复地求解了子问题啊。==注意，所有子问题加起来的个数 可是指数级的哦。。。==</p><p>这张DP表很是重要，从中我们可以窥见最长公共子序列的来源，同时可以根据这张表打印出最长公共子序列的构成路径<br><img src="https://images2018.cnblogs.com/blog/1358881/201807/1358881-20180724195351829-1792192564.png" alt="dp"></p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write your code here cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1,str2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;dp(len1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (str1[<span class="number">0</span>] == str2[<span class="number">0</span>])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (str1[i] == str2[<span class="number">0</span>])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>]  = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = (str1[<span class="number">0</span>] == str2[j])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][j]  = max(dp[<span class="number">0</span>][j<span class="number">-1</span>],dp[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(str1[i] == str2[j])&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[len1<span class="number">-1</span>][len2<span class="number">-1</span>] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【nowcoder】错排问题</title>
      <link href="/2019/04/19/%E3%80%90nowcoder%E3%80%91%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/19/%E3%80%90nowcoder%E3%80%91%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？<br>即没有人收到属于自己的邮件。</p><p><a href="https://www.nowcoder.com/questionTerminal/95e35e7f6ad34821bc2958e37c08918b" target="_blank" rel="noopener">题目原地址</a><br>输入描述<br>    输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。</p><p>输出描述:</p><p>对应每一组数据，输出一个正整数，表示无人收到自己邮件的种数。<br>示例1<br>    输入  2 3<br>    输出  1 2</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.<br>第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；<br>第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；<br>综上得到<br>D(n) = (n-1) [D(n-2) + D(n-1)]<br>特殊地，D(1) = 0, D(2) = 1.<br>有了递推公式，一切就迎刃而解了。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write your code here cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> der[ <span class="number">21</span> ] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">3</span>; i &lt; <span class="number">21</span>; i++ )&#123;</span><br><span class="line">        der[ i ] = ( i - <span class="number">1</span> ) * ( der[ i - <span class="number">2</span>] + der[ i - <span class="number">1</span> ] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span>( <span class="string">"%d"</span>, &amp;n ) != EOF )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, der[ n ] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串区间的个数</title>
      <link href="/2019/04/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/04/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>这个题是一道CVTE在线笔试题，题目是我回忆写的，答案是我自己的思路，如果哪位大神有更好的解决方案，希望可以留言或者私我交流。如有不明白请留言提出。 </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个数字字符串，长度为L，并给定一个K，请在字符串中找出区间大小为K，排序后的字符串是连续（相同为连续）的个数。输出这样的字符串的个数。</p><pre><code>示例：123456789  K=28  12,23,34,45,56,67,78,891345321898 K=34 345,453,321,898</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> L, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L - k; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = str.substr(i,  k);</span><br><span class="line"><span class="built_in">std</span>::sort(ret.begin(), ret.end());</span><br><span class="line"><span class="comment">//判断该区间是否连续</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ret[j+<span class="number">1</span>] - ret[j] == <span class="number">1</span>) &#123;</span><br><span class="line">n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当n = k-1时，说明上面的差判断了k-1次，就说明该串是连续的</span></span><br><span class="line"><span class="keyword">if</span> (n == k - <span class="number">1</span>) &#123;</span><br><span class="line">count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//string str = "123456789";  //K=2;  8</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"1345321898"</span>; <span class="comment">//K=3;  4</span></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">10</span>, K = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func(str,L,K) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树根</title>
      <link href="/2019/04/02/day25%E6%A0%91%E6%A0%B9/"/>
      <url>/2019/04/02/day25%E6%A0%91%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；如果结果是两位数或者包括更多位的数字，那么再把这些数字加起来。如此进行下去，直到得到是一位数为止。<br>比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。<br>再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。<br>现在给你一个正整数，输出它的数根。</p><p>输入描述:   </p><pre><code>输入包含多组数据。每组数据数据包含一个正整数n（1≤n≤10E1000）。</code></pre><p>输出描述:   </p><pre><code>对应每一组数据，输出该正整数的数根。</code></pre><p>示例1   </p><p>输入</p><pre><code>2439</code></pre><p>输出</p><pre><code>63</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：</p><pre><code>36-&gt;9 98-&gt;17-&gt;81. 接收字符串得到各个数字2. 对每个数字进行求数根操作1. 计算数字字符串长度2. 对每个字节数据减去 ‘0’求和3. 对数字求根    1. 循环每次只获取数字个位数后删除个位数    98 % 10 = 8 ；98 / 10 = 9； 8 + 9 = 17；    17 % 10 = 7； 17 / 10 = 1； 7 + 1 = 8；</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRoot</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nroot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nroot += num % <span class="number">10</span>;<span class="comment">/*每次只获取个位数字*/</span></span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nroot &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        nroot = numRoot(nroot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nroot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> origin;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; origin) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origin.length(); i++) &#123;</span><br><span class="line">        sum += origin[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; numRoot(sum) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟面试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】变态跳台阶</title>
      <link href="/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：接上一个跳台阶问题思路继续分析，上个问题中，青蛙只能跳1级或者2级。 则最后一跳只有两种可能，所以F(n) = F(n-1) + F(n-2)//现在青蛙可以跳n级。 假设台阶为n级，则青蛙可以 跳一次或者多次。 一次： 直接跳n级，这是一种方法。 多次： 青蛙跳到 1到n-1级 任一级（不管怎样跳，跳几次）后再跳一次到n级。//或者这样分析，青蛙最后一跳，有可能是从起点直接跳到终点，或者从起点跳了若干步后(到达 1到n-1级中间任一级 )再跳到n级。//所以总的方法数为：青蛙 跳到 1级到n-1级 每级可能的方法数（再跳到n级） + 1（直接跳到n级）</p><pre><code>f(n) = f(n-1)+f(n-2) + … +f(1)f(n-1) = f(n-2)+f(n-3)+ … f(1)综上：f(n) = 2*f(n-1)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * jumpFloorII(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】丑数</title>
      <link href="/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E4%B8%91%E6%95%B0/"/>
      <url>/2019/03/31/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-一一遍历：时间复杂度高"><a href="#1-一一遍历：时间复杂度高" class="headerlink" title="1.一一遍历：时间复杂度高"></a>1.一一遍历：时间复杂度高</h4><p>一次遍历求出第<code>index</code>个丑数，从1开始，如果是丑数则<code>count++</code>，直到<code>count = index</code>为止。判断丑数依据题目意思，丑数只有2,3,5三个因子，因此就用这个数除以这个3个因子</p><pre><code>1.如果一个数能够被2整除，那么就让他继续除以22.如果一个数能够被3整除，那么就让他继续除以33.如果一个数能够被5整除，那么就让他继续除以54.如果这个数最终变成了1，那么这个数就是丑数</code></pre><p>根据以上定义实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> uglyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyCount &lt; index)</span><br><span class="line">        &#123;</span><br><span class="line">            number++;</span><br><span class="line">            <span class="keyword">if</span>(IsUgly(number))</span><br><span class="line">            &#123;</span><br><span class="line">                uglyCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsUgly</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number %<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            number /=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number==<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该算法非常直观，他通不过，主要问题在于对每个数都需要计算，即使一个数不是丑数，还是需要对它做余数和除法操作，因此效率很低。</p><h4 id="空间换时间：提高效率"><a href="#空间换时间：提高效率" class="headerlink" title="空间换时间：提高效率"></a>空间换时间：提高效率</h4><html><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据丑数的定义，我们可以知道丑数可以由另外一个丑数乘以2，3或者5得到。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2，3或者5得到的。<br><br>　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们把得到的第一个丑数乘以2以后得到的大于M的结果记为M2。同样，我们把已有的每一个丑数乘以3和5，能得到第一个大于M的结果M3和M5。那么M后面的那一个丑数应该是M2,M3和M5当中的最小值：Min(M2,M3,M5)。比如将丑数数组中的数字按从小到大乘以2，直到得到第一个大于M的数为止，那么应该是2<em>2=4&lt;M，3</em>2=6&gt;M，所以M2=6。同理，M3=6，M5=10。所以下一个丑数应该是6。<br><br>　　根据以上思路实现代码如下：<br></html><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> uglyNumbers[index];</span><br><span class="line">        uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mutiply5 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nextUglyIndex &lt; index)</span><br><span class="line">        &#123;</span><br><span class="line">            min = Min(uglyNumbers[mutiply2]*<span class="number">2</span>,uglyNumbers[mutiply3]*<span class="number">3</span>,uglyNumbers[mutiply5]*<span class="number">5</span>);</span><br><span class="line">            uglyNumbers[nextUglyIndex] = min;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply2]*<span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply3]*<span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(uglyNumbers[mutiply5]*<span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                mutiply5++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextUglyIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = uglyNumbers[index<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> num3)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> min = num1&lt;num2?num1:num2;</span><br><span class="line">            min = min&lt;num3?min:num3;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间换时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】平衡二叉树</title>
      <link href="/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=4&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目地址</a></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(getDepth(pRoot-&gt;left) - getDepth(pRoot-&gt;right)) &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(getDepth(pRoot-&gt;left),getDepth(pRoot-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】第一次出现一次的字符</title>
      <link href="/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/03/30/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashtable[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">            hashtable[e]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">            <span class="keyword">if</span>(hashtable[e] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)str.find(e);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符流中第一个不重复的字符</title>
      <link href="/2019/03/29/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/03/29/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>输出描述:</p><pre><code>如果当前字符流没有存在出现一次的字符，返回#字符。</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         hashtable[ch]++;</span><br><span class="line">         s = s+ch;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c :s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable[c]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hashtable[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>一个类只能创建一个对象，该模式可以保证系统中只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><h4 id="单例模式的要点有三个："><a href="#单例模式的要点有三个：" class="headerlink" title="单例模式的要点有三个："></a>单例模式的要点有三个：</h4><ol><li>单例类只能有一个实例 </li><li>它必须自行创建这个实例 </li><li>它必须自行向整个系统提供提供这个实例</li></ol><h4 id="具体实现角度来说-就是以下三点"><a href="#具体实现角度来说-就是以下三点" class="headerlink" title="具体实现角度来说,就是以下三点:"></a>具体实现角度来说,就是以下三点:</h4><ol><li>单例模式的类只提供私有的构造函数</li><li>类定义中含有一个该类的静态私有对象 </li><li>该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象</li></ol><h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点:"></a>单例模式的优点:</h4><ol><li>在内存中只有一个对象,节省内存空间</li><li>避免频繁的创建销毁对象,可以提高性能</li><li>避免对共享资源的多重占用</li><li>可以全局访问</li></ol><h4 id="单例模式的适用场景"><a href="#单例模式的适用场景" class="headerlink" title="单例模式的适用场景:"></a>单例模式的适用场景:</h4><ol><li>需要频繁实例化然后销毁的对象</li><li>创建对象耗时过多或者耗资源过多,但又经常用到的对象</li><li>有状态的工具类对象</li><li>频繁访问数据库或文件的对象</li><li>以及其他要求只有一个对象的场景</li></ol><h3 id="单例模式的两种实现方式"><a href="#单例模式的两种实现方式" class="headerlink" title="单例模式的两种实现方式"></a>单例模式的两种实现方式</h3><p><strong>饿汉式</strong>：就是说不管将来用不用，程序启动时就创建一个唯一的实例对象。<br>（如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    <span class="comment">// C++98 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">//</span></span><br></pre></td></tr></table></figure><p> 在程序入口之前就完成单例对象的初始化</p><p><strong>懒汉式</strong>：如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉</span></span><br><span class="line"><span class="comment">// 优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</span></span><br><span class="line"><span class="comment">// 缺点：复杂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">        m_mtx.lock();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        m_mtx.unlock();  </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~CGarbo()&#123;</span><br><span class="line">    <span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">    <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton()&#123;&#125;;</span><br><span class="line">    <span class="comment">// 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_pInstance; <span class="comment">// 单例对象指针</span></span><br><span class="line">    <span class="keyword">static</span> mutex m_mtx; <span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line">    Singleton* Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    Singleton::CGarbo Garbo;</span><br><span class="line">    mutex Singleton::m_mtx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多线程环境下演示上面GetInstance()加锁和不加锁的区别。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">10</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Singleton::GetInstance() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串通配符</title>
      <link href="/2019/03/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2019/03/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。   </p><p><strong>要求：</strong><br>实现如下2个通配符：<br>*：匹配0个或以上的字符（字符由英文字母和数字0-9组成，不区分大小写。下同）<br>？：匹配1个字符</p><p><strong>输入</strong>：<br>通配符表达式；<br>一组字符串。</p><p><strong>输出</strong>：<br>返回匹配的结果，正确输出true，错误输出false</p><p><strong>输入描述: </strong><br>先输入一个带有通配符的字符串，再输入一个需要匹配的字符串</p><p><strong>输出描述：</strong><br>返回匹配的结果，正确输出true，错误输出false</p><p><strong>示例1 </strong><br>输入</p><pre><code>te?t*.*txt12.xls</code></pre><p>输出</p><pre><code>false</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pattern,<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pattern== <span class="string">'\0'</span> &amp;&amp; *str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pattern== <span class="string">'\0'</span>||*str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pattern ==<span class="string">'?'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pattern ==<span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str) || match(pattern+<span class="number">1</span>,str+<span class="number">1</span>)||match(pattern,str+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pattern == *str)&#123;</span><br><span class="line">        <span class="keyword">return</span> match(pattern+<span class="number">1</span>,str+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pattern,str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pattern&gt;&gt;str)&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = match(pattern.c_str(),str.c_str());</span><br><span class="line">        <span class="keyword">if</span>(ret)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>超长正整数相加</title>
      <link href="/2019/03/22/%E8%B6%85%E9%95%BF%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/03/22/%E8%B6%85%E9%95%BF%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个算法完成两个超长正整数的加法。</p><p>接口说明</p><pre><code>/*请设计一个算法完成两个超长正整数的加法。输入参数：String addend：加数String augend：被加数返回值：加法结果*/public String AddLongInteger(String addend, String augend){    /*在这里实现功能*/ return null;     }</code></pre><p>输入描述:<br>输入两个字符串数字</p><p>输出描述:<br>输出相加后的结果，string型</p><p>示例1<br>输入</p><pre><code>999999999999999999999999999999999999999999999999991</code></pre><p>输出</p><pre><code>100000000000000000000000000000000000000000000000000</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AddLongInteger</span><span class="params">(<span class="built_in">string</span> &amp;str1, <span class="built_in">string</span> &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = str1.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m = str2.size() - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> result = <span class="string">""</span>; <span class="comment">//存放结果字符串</span></span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 记录是否进位</span></span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span> || m &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">carry += str1[n] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">carry += str2[m] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result += (<span class="keyword">char</span>)(carry % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">carry /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">n--;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否进位</span></span><br><span class="line"><span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">result += <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br><span class="line">reverse(result.begin(), result.end());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; AddLongInteger(str1, str2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>完美数计算</title>
      <link href="/2019/03/21/%E5%AE%8C%E7%BE%8E%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/03/21/%E5%AE%8C%E7%BE%8E%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。</p><p>它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。</p><p>例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。</p><p>给定函数count(int n),用于计算n以内(含n)完全数的个数。计算范围, 0 &lt; n &lt;= 500000</p><p>返回n以内完全数的个数。 异常情况返回-1</p><pre><code>/** *  *  完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。 *  它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。 *  例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。 *  *  给定函数count(int n),用于计算n以内(含n)完全数的个数 * @param n  计算范围, 0 &lt; n &lt;= 500000 * @return n 以内完全数的个数, 异常情况返回-1 *  */    public   static   int  count( int  n)</code></pre><p>输入描述:</p><pre><code>输入一个数字</code></pre><p>输出描述:</p><pre><code>输出完全数的个数</code></pre><p>示例1<br>输入</p><pre><code>1000</code></pre><p>输出</p><pre><code>3</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    约数计算可以遍历sqrt(n)的范围</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span> | num&gt; <span class="number">500000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历范围</span></span><br><span class="line">            <span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=sq;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果j^2 = i,说明两个约数相同，只加一个</span></span><br><span class="line">                    <span class="keyword">if</span>(i/j==j)</span><br><span class="line">                        sum +=j;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//否则，两个不同的约数都要相加</span></span><br><span class="line">                        sum += j+(i/j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum +<span class="number">1</span> == i)</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;num)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count(num)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公共字符串计算</title>
      <link href="/2019/03/20/%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/03/20/%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目标题：</p><p>计算两个字符串的最大公共字串的长度，字符不区分大小写</p><p>详细描述：</p><p>接口说明</p><p>原型：<br><code>int getCommonStrLength(char * pFirstStr, char * pSecondStr);</code></p><p>输入参数：</p><pre><code>char * pFirstStr //第一个字符串char * pSecondStr//第二个字符串</code></pre><p>输入描述:</p><pre><code>输入两个字符串</code></pre><p>输出描述:</p><pre><code>输出一个整数</code></pre><p>示例1   </p><p>输入</p><pre><code>asdfas werasdfaswer</code></pre><p>输出</p><pre><code>6</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">//max初值.</span></span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.size();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.size();</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//所有值初始化为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//计算dp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果当前结尾的字符相等，则在dp[i-1][j-1]的基础上加1</span></span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span>)</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//dp[i][0] or dp[0][j]</span></span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新最大值</span></span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; max)</span><br><span class="line">max = dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>507.完美数</title>
      <link href="/2019/03/20/507-%E5%AE%8C%E7%BE%8E%E6%95%B0/"/>
      <url>/2019/03/20/507-%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</p><p>给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False</p><p>示例：</p><pre><code>输入: 28输出: True解释: 28 = 1 + 2 + 4 + 7 + 14</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">                result += i;</span><br><span class="line">                <span class="keyword">if</span>(i*i != num)&#123;</span><br><span class="line">                    result += num / i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">1</span> &amp;&amp; result == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数</title>
      <link href="/2019/03/20/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/03/20/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中指针常量与常量指针的区别</title>
      <link href="/2019/03/19/C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/03/19/C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在C++学习过程使用中，每个人都不可避免的会把指针错误理解或在不理解，尤其是对指针常量和常量指针的理解，特别容易把概念搞混淆。本文就针对该问题简单的说说指针常量和常量指针的区别。</p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>   本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ul><li>是个常量。</li><li>指针锁保存的地址可以改变，但指针指向的值不能改变。</li><li>指针本身是常量，指向的地址不可以变，但指向的地址所对应的内容可以变。</li></ul><p>形式如下：</p><pre><code>int* const p;</code></pre><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>常量指针又叫常指针，可以理解为常量的指针，也就是这个是指针，但指向的是常量，这个常量是指针的值（地址），并不是地址指向的值。</p><h4 id="特征：-1"><a href="#特征：-1" class="headerlink" title="特征："></a>特征：</h4><ul><li>常量指针指向的对象不能通过这个指针来修改，可以通过原来的声明修改。</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，就是限制了通过这个指针修改变量的值。</li><li>指针还可以指向别处，因为指针本身只是一个变量，可以指向任意地址。</li></ul><p>形式如下：</p><pre><code>int const* p;const int* p;</code></pre><h3 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h3><p>指向常量的指针常量是一个常量，且所指向的对象也是一个常量。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>一个指针常量，指向的是一个指针对象；</li><li>它所指向的指针对象且是一个常量，即指向的对象不能变。</li></ul><p>形式如下：</p><pre><code>const int* const p;</code></pre><p>如何区别这些呢？</p><h3 id="区分宝典"><a href="#区分宝典" class="headerlink" title="区分宝典"></a>区分宝典</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>看*和const的排列顺序，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="comment">//const* 常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;  <span class="comment">//const* 常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;  <span class="comment">//*const 指针常量</span></span><br></pre></td></tr></table></figure></p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>看const离谁近，即从右往左看，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cont* p;  <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p; <span class="comment">//和上面一样</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p; <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改</span></span><br></pre></td></tr></table></figure></p><p>看一个实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p><pre><code>size_t strlen(const char* src); //常量指针，src的值不可改变；char a[] = &quot;hello&quot;;char b[] = &quot;world&quot;;size_t a1 = strlen(a);size_t b1 = strlen(b);</code></pre><p>虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格子走法</title>
      <link href="/2019/03/17/%E6%A0%BC%E5%AD%90%E8%B5%B0%E6%B3%95/"/>
      <url>/2019/03/17/%E6%A0%BC%E5%AD%90%E8%B5%B0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。</p><p>输入描述:<br>输入两个正整数</p><p>输出描述:<br>返回结果</p><p>示例1<br>输入</p><pre><code>22</code></pre><p>输出</p><pre><code>6</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>-------------| 1 | 2 | 3 |-------------| 4 | 5 | 6 |-------------| 7 | 8 | 9 |-------------1. 对于上面的n*m(3*3)的格子，有两种情况a. 如果n或者m为1，则只有一行或者一列，从左上角走到右下角的路径数为n + m比如： 1 * 1格子，可以先向下走，再向右走，到达右下角；或者先向右走，再向下走，到达右下角，共两条，即 1 + 1 = 2，对于1 * m和 n * m的情况同学们自己画一下b. 如果n,m都大于1，那么走到[n][m]格子的右下角只有两条路径，&lt;1&gt;: 从[n - 1][m]格子的右下角向下走，到达&lt;2&gt;: 从[n][m - 1]格子的右下角向右走，到达所以走到[n][m]格子的右下角的数量为[n-1][m] + [n][m - 1],可以通过递归 实现，情况a为递归的终止条件。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;y&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(x,y<span class="number">-1</span>)+sum(x<span class="number">-1</span>,y);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((x&gt;=<span class="number">1</span> &amp;&amp; y==<span class="number">1</span>)|| (x==<span class="number">1</span>)&amp;&amp;(y&gt;=<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col,row;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;col&gt;&gt;row)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum(row,col)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2019/03/17/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/03/17/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数</p><p>输入描述:<br>输入为一行，M(32位整数)、N(2 ≤ N ≤ 16)，以空格隔开。   </p><p>输出描述:   </p><p>为每个测试实例输出转换后的数，每个输出占一行。如果N大于9，则对应的数字规则参考16进制（比如，10用A表示，等等）</p><p>示例1<br>输入</p><pre><code>7 2</code></pre><p>输出</p><pre><code>111</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> tables = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">    <span class="keyword">int</span> M=<span class="number">0</span>,N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(M&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            M = -M;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = tables[M%N]+s;</span><br><span class="line">        M /=N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>统计回文</title>
      <link href="/2019/03/17/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87/"/>
      <url>/2019/03/17/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。花花非常喜欢这种拥有对称美的回文串，生日的时候她得到两个礼物分别是字符串A和字符串B。现在她非常好奇有没有办法将字符串B插入字符串A使产生的字符串是一个回文串。你接受花花的请求，帮助她寻找有多少种插入办法可以使新串是一个回文串。如果字符串B插入的位置不同就考虑为不一样的办法。</p><p>例如：<br>A = “aba”，B = “b”。这里有4种把B插入A的办法：</p><ul><li>在A的第一个字母之前: “baba” 不是回文 </li><li>在第一个字母‘a’之后: “abba” 是回文 </li><li>在字母‘b’之后: “abba” 是回文 </li><li>在第二个字母’a’之后 “abab” 不是回文<br>所以满足条件的答案为2   </li></ul><p>输入描述:</p><pre><code>每组输入数据共两行。第一行为字符串A第二行为字符串B字符串长度均小于100且只包含小写字母</code></pre><p>输出描述:</p><pre><code>输出一个数字，表示把字符串B插入字符串A之后构成一个回文串的方法数</code></pre><p>示例1<br>输入</p><pre><code>abab</code></pre><p>输出</p><pre><code>2</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> end = s.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[begin] != s[end])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1,str2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while(cin&gt;&gt;str1&gt;&gt;str2)&#123;&#125;</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, str1);</span><br><span class="line">getline(<span class="built_in">cin</span>, str2);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=str1.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = str1;</span><br><span class="line">        str.insert(i,str2);</span><br><span class="line">       <span class="keyword">if</span>(CheckStr(str))</span><br><span class="line">       &#123;</span><br><span class="line">           ++count;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/2019/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>题目描述</p><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p>解决方案</p><p>/<em><br>struct TreeNode {<br>    int val;<br>    struct TreeNode </em>left;<br>    struct TreeNode <em>right;<br>    TreeNode(int x) :<br>            val(x), left(NULL), right(NULL) {<br>    }<br>};</em>/</p><p>class Solution {<br>public:<br>    vector<vector<int>&gt; vec;<br>    vector<int> v;<br>    vector<vector<int> &gt; FindPath(TreeNode* root,int expectNumber)<br>    {<br>        if(root == NULL) return vec;<br>        v.push_back(root-&gt;val);<br>        if( (expectNumber-root-&gt;val == 0) &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL )<br>        {<br>            vec.push_back(v);<br>        }<br>        FindPath(root-&gt;left,expectNumber-root-&gt;val);<br>        FindPath(root-&gt;right,expectNumber-root-&gt;val);<br>        if(v.size() != 0)<br>            v.pop_back();<br>    return vec;<br>    }<br>};</vector<int></int></vector<int></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++之继承</title>
      <link href="/2019/03/15/C-%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/03/15/C-%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>继承是面向对象程序设计中的一个重要概念，继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了<strong>重用代码功能和提高执行时间的效果</strong>。</p><p>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p><p>在继承体系中，有单继承，多继承等。以下是具体解释。</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>直接上一段代码来解释单继承。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(<span class="number">5</span>);</span><br><span class="line">   Rect.setHeight(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total area: "</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>当上面的代码被编译和执行时，它会产生下列结果：Total area: 35</code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><pre><code>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…{&lt;派生类类体&gt;};</code></pre><p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。下面直接上一段代码来演示一个实例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(<span class="number">5</span>);</span><br><span class="line">   Rect.setHeight(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.getArea();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total area: "</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total paint cost: $"</span> &lt;&lt; Rect.getCost(area) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre><code>Total area: 35Total paint cost: $2450</code></pre><h3 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h3><p>什么是钻石继承，看到这个你获取会懵，但是看到下面这个图你就会豁然明了。   </p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALEAAACgCAIAAADMwRqsAAAIS0lEQVR4Ae2b%0A6ZIlKQiFuybm/V+55lRQQTOoud0UAbk/MkwlFQ6fWy9f39/ff+pXCggF/hHl%0AKpYCPwoUE8WBVqCY0IrUezFRDGgFigmtSL3/m1WCr68vs9CS3d3SMgEgbFJl%0ACZ8N5bV32OgcaZRiIlK2bHwtJmx0jjRKMREpWza+FhMdnfMdGztBjquKiV9t%0ARhyM6seShm8pJn5TiItrm37U2FxoXXGU+c8npNAq391Mt5Vtjewza3kXJpBd%0AOelVuc2uYggG+/CxCxMq6xIRmWxiRT7Vhzu81nnib5bl4oFa4uZv8zalYuI3%0A1QoIqt0Ti2LiD2hQQMjdZEMsiomfPQI/uTMAEfmqWmVTyvKmZ0zOpUr/cf0m%0AcOzORJtm2kfUbsKs7FDYdO8YpZzrwQrKOxDQxrjLOkEJ5jS3ywOkYSBIJsKi%0Aa9nqmKlmFyaOU0ustDaEBfLdNmWCQMWyCxMqbH4d0cAGRMOpGdsnKOzOxMUF%0A4KJZAiAQwqZnzBzJmxRFMTFJ2MDdFhOBkzfJ9WJikrCBuy0mAidvkuuZ7x10%0AgZwkXOJuk/8bVGAx7xo5tfOFzGXeO2bnDLSlXIrSMjEbiIXzePbQE5fW2a6P%0A+qe5O2/LUOPmgy8bE0sytGRQheaLr6n2jmS5eTHNt7rKw8RCIJIdNpMwsRAI%0AmoKZsMjAxHIgbq3M/o1jnzFBAyQ2u2KcpjMHnYH/bDtHAk45szeIunf4BCLH%0AqSIkEz6BoAmdAIt4THgGwn6dnzFiMCZCABF9qQhz7wANmBN+rhinEzQEvt0o%0AYtw74urbFd15ZYC9IygQcXcQ70wEBYJWgqBYuGYiNBDON4gD9/wykQOIiEuF%0Ax3sHaADFga4YB3OOmmLx7e7eEUu+UxoiGvjaO7ICEWsHccREViBoqQiEhRcm%0AcgMRawdxwcQmQERZKhbfO0AD5lCmK8bpkuB/AnTuHZSn09heMdiKhlcUM+ik%0AwwRGNUiVJXkGOl4fgnYQA4Wvu6Qs15wn/K+fSqatXtcw4XmWGKSflgqDgZ4N%0AsYaJZ75m+sozFv3zRCb1l8dycHI6aHrm9isLcDHxTPx7X41S9e656i3Cau+4%0Al913rX3uIC8z8Raq70pfvd1S4AUmRhyM6m/5l97Y4VLxAhPdqADEaBNNn+a7%0AAXoT6gYTB/O+jaqtuatU2a9S4KN7R5eStrL4WJXdZ+PeY0LtCDLZ1CSfzxyq%0Ar6QCSnDZNK98de84dk61ghXUzHM6d88j6Ub1r6txlYmDgRUQZFlYHCh23NSV%0ArivycT+PW+/tHeQunjQekcuvqFRly0geS2D8IYnGg0rFDiq7Zmz/buEGEyoY%0A+NE6qiBoDd71PmJv0ESqpMptRFdkb7/6pOYSE12/W1/Jj259wXElSVIl0lw+%0Ar/Twis0lJuRIjLkMgAyWBCB9S1MmJTkc1pxrphZeOGOSfxwGBTDV6QSdQy76%0AjaaWitFS1XMm4Dr8oycX+JVcx6uMzTIApV2UV0hEP6kkyvihnqNQZbRy07zC%0A+d4h3YIf6pW8VJVkNmqaF0zEniEdc9DKyE0UWmswI+RzJkajnqacAjg1G/W/%0AWz0J1UbdrZ8Kx3MmLrp10azVYreaVijQgEp6Wqpxfp6w9GbDsUYp53rCwlKZ%0A5+uEpZeZxkKyEQ49UWiXB2qV9carxUQmmPRMGf08FpnstjdipbUhLGDfNrWd%0AfFjTZ4Ip/rD3t/r50I0Qn49oYOeJhlMztn9c6DDxLokGMTwO3tWHF2W/aPZJ%0AaNPPmIgBv1owPkmS8bfTmaB4CgvjvH4ynBETcLGw+CRPlt92zhPzhics8Jw3%0AhM+eY22d//sbFxtB69Rpo/PjUez2DnYR6wR+saYOO29QWK7MgnWCZUXwgINf%0Aq+BkBV2clcKCZ4IfKRbsHawCCrWJkBp+gIA/i9cJVoT4oNetnk72C6m5CybI%0AIVdzRWo0r+wz5MV7h5R7t33EJxDIiKN1gvhwq5TE98MyYkQPbu9c7piAWLmx%0A8B+dRyYIC88zCb49+/kHAnE5ZYIUD6HgRTgQCyzd7hcyCtdMwNEcWMSKwtG9%0AQ6LK5QSXkVhA/MzDGKtZzL8ZCbRf8CQMw8SPo3H2Y9I33PLAWMRYJ/66G2HB%0ACIcvy/tLc4i9QzrtfP45d08qOSp7P2O2fns+dSYAAoIH2zsYEW/qwx/4Fm7R%0AZT1lISoTiMFPGrwBKhP8oByYCYp2eT6WO/Ag68efhGcC4a3KCsbF6Dn2C0lJ%0ABiaWYLEKRJm8SeV4946uEMaXkcRA/EywTEufwWJuMEQXesvKVEyQcJQ2GxEz%0AzShWzPT/i/KoBgWDbFnCZ6AYD5HkPMHxUMH4eKFGj/6akwlkxWCdiJ77kf9p%0AmRgFXPWnChQTpxJtZ1BMbJfy04CLiV+Jsl4iTgloDbZmYsTBqL6VL2XN1kx0%0Ar6wAYvM7S9o/s+IZrCa9yrd6xVdtDXe1SSE5E2rSMx9ckGluK/fkIzkTMuWy%0ALJNN3MintNywnPk8QWmWSZUoUL2ygQFq5CcbljMzcZpOBQTZFxabMgEaFBBy%0ACdkci02ZQNbxkwsJEJGvqlU2pS/veMZU6eccd+s3hCMzE0in2iDotU0z1Stj%0AZmW3wkZ7xyjlXE8M7UZAG2/mdQLRyjS3ywMMGAiShuy7lq12WWuSM4G0jRIM%0AGrqthEW3KSsEKq78TKiA8TqigS0Jo1Mztk9W2JGJ0cqhUnvRTH2V4HWjM2aC%0AbNmEUEzY6BxplGIiUrZsfC0mbHSONErOMyZdGSLlwZOvu//bQ0+58OJL7R1e%0AMuHHj2LCTy68eFJMeMmEHz+KCT+58OJJMeElE378KCb85MKLJ8WEl0z48eM/%0AinkL/Qt+BswAAAAASUVORK5CYII=" alt="1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~D() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"C()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~C() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~C()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">C c;   <span class="comment">//D, B, A ,C</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHUAAADJBAMAAADvImCBAAAAAXNSR0IArs4c%0A6QAAAA9QTFRFAAAAwcHB3d3d1dXVLDY+qldFvwAAAaBJREFUaN7tmWGSgyAM%0AhZMbvJyBi/RH73+m1QDqVjtTHyruNk6dKvUjLcnjDVTSkz0ekoQ/urEGNb/S%0AcpbDVDHd6Mt7YYdbf2bsofSSH9P5wdw+9PWGfY27ZEv78azZzJrN7HBtMJT2%0ANTu0ae1T/YXK5n7zZ/om7iYLy9dYtG+x9fssWAHWrGzGlQb2g7jr/HpdDeOp%0A5azjPLI+zuPP8fY8AHfQwgEslGY3MvCJfg1e5rI/cPKqpdlapwj2bLZDfnNd%0AcTXZroXQ7/n6VeFrsoE19Ikb+g39hv8GG/oN/S7ZWhd6Ncv7oK+hurC8/05r%0A7h6+3zLHsvr1fZXQ7+n69Yny+vy2eAqm/alg7+q/8p3+ez3rvgCKzXuQSrNU%0AdhtZaWJVeBY8q8Kz4Nmm/PoGM/6WFsCzqgA576Rff/CA+L2cB6c5YgO731fS%0ARAR7QY4oDy51Bb4maS18oX65dewBLOiaJNexB7DKs9waeNZRF/3yLLkGDv3u%0AHWduD7p5fm7x32Dv778W/vvP9at9/MjQzwdDv6Hf8N9gQ7/32vsK9ubsD6GA%0ARXLi6nDOAAAAAElFTkSuQmCC" alt="2"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMEAAADjCAMAAAAL+ICTAAAAAXNSR0IArs4c%0A6QAAAIFQTFRF9fX1Hh4ek9X19fW14ePn1alqQEBA8fHxAFCbwXoYHGSnmbnT%0Abh5I0dvlWI27brX19fXVs7Oz9dSTbmxsbh4e7+/vk0ke1JJJSJPVtfX19bVu%0AHh5THm611fX1SiFuk0hItW4eHkiPSEiTSCUesbGxSJOTSB5I9/f3n7WHbkhI%0Ak9XVdcmz8wAAA+1JREFUeNrtnX1zojAYxHkRDlstDr6ggCeeXsf2+3/AIwga%0AIUJnelOe1d2Zdtr/spInyY9somUVGlnoeiQH8X5b/zlb2aH7ewPmIEmd2opt%0Ah8XvNdgzSOxKquF5qB5D/R+Gg7xqa1J2pcJBkpW9KURxEKebssl5ZlWffrqZ%0A7ZzkWhoQlZye7LAqZL94IoUDsLEoOmT1X37ofe4+d6d3B8hBfK3k2bzo/sl+%0AtHPiDMZBbvtVY4tBNA7zsKjhohcBVbJ1HnsqB5s8LD59VQcIpXxvPsCrZO0Z%0A1DMawlDKtSkd0IE1QpdFUVS3Xl9eXuEafdTb/zadvqF5OPp6+5fL6VsQgBm4%0AOAgC9QSCQHeg6DmUbkBzUEszsJb/BDodRNLf4JUGWg60So5Q3kHWldxoP0Iv%0A6p0N3IX0Sqaop9YSWM/2rDwP3cB47KEbuLWgZjj5U9zx1sCtg4mDsNwzGKjL%0AQTlQPyDIc3ZQybs4SDLpBvxGHY9LK96lDtKNdAN+YywdayNSWQeSdwpvkafS%0AWJsVlAOIbbamg5tKjt4dNAd6Jas6QDNQDUrwUzP88gjdAAmHhMOSeAbkEf9q%0Asg953IXwSFUv8kintn7kEb5a7UMe8Q6+gjyic2FfQh60rZ428rgLOGgj8nBt%0AwfUdCYeEQz2gDME26TsMjfYbgm1ADu4E24AcmIJt0cH+i+SgFQtTC9U4RXYQ%0A/dli9aJ2sA3LgRZsO2L2outssPTr5UpiI1XyRfOCpufYM/Mc3YDlj/xfXGGR%0AcChqKKBx0SavFtCAOTAADZgDA9C4k9PBXgM5MADNfgsUODI5UL0oD9EcNCoZ%0AKLZmBJo11iZUC2jcyRzypA6BhkBDwiHh/KwYShNgoGUhl39HVlcoTeVYPqSv%0ARDtDaequJukXJ3aH0lQYSr1fl22gK5Smtgdk3/TVF0orL/ySfN9dfyhtcb79%0AEWtI1UNp5U13cEeJ9ErOy3EI4trE1sTGUBrXdyQcEg5LgsNSB/LwHM7wyMNz%0AOMMjD8/hCEAensMZHHl4DodrCyIPCYeEQz2KeA5n+PbzHM7QDngOR4oDnsOR%0AMBvwHI4EC4ytkXBIOBT1PaABaz/iN+b0Ag2QTECT23aG5KCFA2Bcb3KQQL19%0AN39jDsp3hN4BmgTqMJcJaNSXnH4A7uEQaAg0JBwSzs+KoTQBBhhKG8IAQ2nD%0AG2AobXgDDKUJdMBQGtcWXN+RcEg41AOKobTh289Q2tAOGEqT4oChNAmzAUNp%0AEixwD4ci4VDU94AGrP0MpckDmtkK6UpZAw7MVmusZ9AGGqzND3MoDauSW0AD%0A1otMQKM2cXg5NIGGQEPC+U+Eg885dDCo/gG1ixDl3kIusAAAAABJRU5ErkJg%0Agg==" alt="3"></p><p>菱形继承的缺点：数据冗余和二义性    </p><p>解决方法：虚继承（虚基表的推出，虚基表中存放了现对于当前位置虚表地址以及父类地址的偏移量））</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>我们用<code>virtual</code>关键字来标识虚继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"D()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~D()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"~D()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~B()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"~B()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"~A()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~C()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"~C()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    C c;   <span class="comment">//D, B, A ,C</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAACrBAMAAABMNwWUAAAAAXNSR0IArs4c%0A6QAAACRQTFRFAAAAwcHBLDY+1dXV3d3drrC6BFXLrdXVhrvYpmfdOondejDd%0A4bqSowAAAcJJREFUaN7tmP1xwyAMxdEG0gpdhRkyQe+aQTpE+n+W6Hg14su1%0Afdfq4cNOgi+5EMIPAnoPGbuPN+xyFxT0MOjA6wBQmERLlN7pEiIuX2jxGcCp%0ArA0CnrqIbai2ivVTR1vgcsQ5mOr3BEUqKFLBqSwsnOoX4FRBuTfSF2cwdhp/%0Ao60RN0GWWOZZ/QrMf2MGOuY16NYjOhT8x4iLOKpyptWj9M6rGkBd1TALrY+T%0APlDkrSCTEbwUMbIRDKumlHFIr4rEwKxBHuC+YNc4RuXYJQeL/IH86FE/+iP8%0ASA6UHAoK9x5x+HH4EVucHHzqBF7DfQ8iuZveCCFaRcFPDQQAfpe7YyP4he4A%0A9wY/gmA86Qw/7uxH3eZ6xhFOAVzOhwM8QX50r5Mfe4J6Cic7GAMhvUEiaHHY%0AHn4FyYFg2HIQMKRHEbGD7FriiIDlgc3ZRX61bhl1jsSMbB/+1zNQts4RyJG+%0AjoWCxjTgS/MB7h4Oe45MymFQcpjIUSM/mB+Bo2AryJjkkKNgK0ggCJwhqzs6%0A+xEEkTPk8OOfqwo8Y23bVxskh4LCR7ijP9g1jvLc+fH9dfxol9wNBe8HumP4%0A8RR+HOATgD+ONFyLNh6pkwAAAABJRU5ErkJggg==" alt="5"></p><p>下面一张图来总结虚继承</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIEAAALhCAMAAAD/zESTAAAAAXNSR0IArs4c%0A6QAAANhQTFRF////2///OpHb///bHOe1/wAAOgAAAAAAJBzt6aMAAAA6ZgAA%0A//+3ADqR/9uRkToAAABmZmZmt////7dmkdv/25E6t7e3AGa3Zrf/t2YAZjoA%0A/9u329vbsJEvADpmOjo62bdmPWa3Zrfbt2Y/t9v/cpG3ZpHbOjpmt5Fm1uO3%0AkWY6OmaRZjo627SRZmY6iL21npGRRZGr29v/ADo6kb/b/9vbOjoAOmZmOjqR%0At7eRZmaRkWZmt9vbkTo61NuR27e3t7fbAGaRkWYA25Fmmrf//7eRkZFmOgA6%0AZB5jcQAAIABJREFUeNrtnQl72jjbtm34jOZzVhL2HQIhG9mbTtN22nnamfn/%0A/+jVbsmWwQRIWK7zmGlikAXB8smt3fMAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAACsjCBjujY+KgDAsv0TwEAAgA2IgaAgAMBHGaiNIAgAsPz6%0AVxA7DMRv6icMBABYTegTRAYKYg8F8fCojZYgAMDy615BFBQZR4m6WbuNhiAA%0AwKoMRP0TqFqY+TMKgRADAQBWZKDAioaSgVDbg4IAAEtVkN0OFExrB4KBAABL%0AVZDd5cVqYUFqVxhvBEJLEAAAAAAAAAAAAAAAAAAAAAAAAAAAAGsMIfgMAAAf%0AJSB8BAAAGAgAAAMBAAAMBACAgQAAAAYCAEBAAAAABQEAYCAAAICBAAAwEAAA%0AwEAAgA1TEBwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA1RDIHwE+CgDAO2kn%0A0L/AQACAD4p8rN8AAGBdDIRJZACA5dW6eDVL/xPoaldg18b0bzAQAGCJCuKu%0ACaR01HEUAxlCQsUMALD8WleQ/Bk3EOQDAICBAAAwEAAALMVARjtQkKkdCC3R%0AAIDlxUBB1OnF/pPHQRDI/rEgsHvFYCAAwFJrYQAA8DGVMCgIAAAAAAAAAAAA%0AAAAAAAAAgPWG8P8AAOBjBAQFAbCbZB5UFCwpH1s80U8oCAAYKD1ZdgPFkrqn%0AghACAwEAMsc6wRuzSG3kiZsHCgIArMJAHgwEAIhVqgKxokcQP1YLfah/AodW%0AdHovmoevnzFrYYTw6havctF/+H8EBgIAkY69llBgLXFmrXrmWucs8Ow1quPn%0AxUMd1d8lVAQDAQAD2Qayq1CmVJZqIA8GAgCw5cy8LAYKAvdar0FcPjAQAGDZ%0ABkqrhS3PQOiNB2BX62EpBgqMtadTamFJ40THQYqBCAwEALANEphdYPIh+YRa%0A/j6ewDZXbE1qdZ7SC5F9X0R0g4mOMWI8gVkZAIAPBTNTAQAAAAAAAAAAAAAA%0AAAAAAAAAbA/R2mHYUB4A8N4CSj0AAAAYCAAAAwEAAAwEAICBAAAABgIAbI+A%0AoCAAAGIgAAAMBAAAMBAAAAYCAAAYCACwXQrCzFQAAAAAAAAAAAAAAAAAAAAA%0AwJupdc8+uR4vja+a7jMGYdozcfyDwm3RpNs9xCcOADAMREg55fF6PiaUlnBV%0Ajuw1zeMpBmJ5+392e/q4jk8cAGCapuCMS6pkb19o4/WrNFEpvOGRzGdS4D87%0A+tRWa4qBSiFP1uLHp/jEAdhuzkNCzvJW7DLqnmY10PBVVJhC8lKUniFHeSkl%0AmstjKx/VsS7k7znSiKpan8n3vGmgKs+pQ3OBgQDYgaDm6NK+05mSkne+L1RS%0Ak7FOLIxxhEY59tDwmEnl91PjIn8eNerklKTsU7mBSiE587yTY2pFGAiAbYff%0A5VW7vYXe/qcOU/EgZ0x4a/FnuzlIRC92DWtU7DGdvPTY86OQNCZeioGOzBio%0AWhjzd0QfhIEA2BEDlWcaqBTy4EfGQPIosgi5VXWq6Fy/TxqX3nmRqWfYMZ6Y%0AYqBaeHrS2XvgcREMBMAOGKgcv9OnGUjKwzKQf3dMei116tUP+eggvLnkL8DP%0AMMKkKQa6ZbqiPuNvAAZSQaV/fTNxXbyKGOdwMnY+7WJ4/4+oancvrK7LfuxY%0AXBo59KJGbpIDKs4dZ9A3Iro9X786RmCkjeSo8YICdhRaAxvEOr2nGUhW2CwD%0A0bqWzGB43IhKnmg4KoVCML7RcjStFsafFj37MJC4GPTz6dvNbLJKrHoXTbsL%0An9zYrXL+SLX7qzY+6xLw68qP7eY9GvAeyp/7J/cxyeWIFQarklCWb3qv6ajI%0Au0dyeIO0J8AOQItFIfoyG45p/PESphqIFi3uGMtAqi35ZBxanWql8IXdJbey%0Ajyw6Y6qB/GtSeOKvAgOJ63PK/i3H1CAC0npUlWZhie5ejPmF9yOcHBd6hj/q%0AsS+iF7t57zxq9OM/n+KWUBfxvHhovK/6FNckuyuGFdVtKpJHPadgZ8ixwlIl%0AoszS77B23mqyiRmIFqIO67s3DURPcn8V85E9om/Lfm6agQYhuWr6ferBi28w%0AkKrEnhxbSjEM9K3yKVJ164EpwPhEzTs6RwoTmeVZXhtIJjGOZU2pFXV81sxw%0AR42/6IhhXlRaepgXjb32eRgVj7DSDFSVX0+fuypCwxDUHRQQKy2iAMpByOm1%0AMFbU6f+FnmEgmjoy0CmL+CemgaqsoHZYWJPFQA0a/Xw5IFeXTIPOWGznQiDx%0A2Vatj8IwEE1wGgWLOWGgQlFZIqoVs6vx8z4vL5M2Dn1YpNTjuSJNOA1EAxXP%0AVY9jIW+3y7si5NeNinBSR3LQqOww9pV1gSBot6AmuSO8QJ7qiH+KgXIsnqHl%0AizzpMukfFD6rnrCQ3PAhieWogOVYxEQzbHcyGYjwOWSsIYiWX9TC2CdXdtys%0AloHMoZs5FQPVZGdiPQqm6CM8F9tAMuNBsaeSRRKo6VpYsslHXkS/ojSjo+S9%0ApjwvVFc2bSQH/XY6lFXv0ddL1nzVxC25cyFQnTdC9vlwwZz4/ks10IBXqFjF%0AiuhJGAeNJv3qmrS8ZLsNzeel++/rhDVfZ66FGa0UMJDxSeXMtl15i3ccBnph%0Ad/pRvhSeWheSC4hHGT2ngfgL+ZUfv8enCdHFYiDZ3CRqYR2iJacMdJQXzTr0%0A1X+ZzyRGcvhsyFiVNCal7vf8ICxcwT+7B+vaYo0/RT6ZS3ZvpBnoQU0ZrWoD%0AnVzzRiGzFmYaiD3OfMVvkmwG8h+6t/9WLj/BQLFbvyqbceTjf7WmxkAnxTOz%0A4WXAw9NisftESM9loAdyVHmgUnE1eMcNJHo5HbUwaaBn0f0ZFaMpIzn4Y/RP%0A6/EI+Ax35O4ZiDcCyabn2tQYyKyjx3rjpxmIZf8r3hJdiOaFjeMxkD+gt0nh%0AFAbSHyz/cL4dEz0sx2/ROEP1lDsNxCcIR5Kgl+Kq0inwUertmIFIt3vLwine%0ABF36z6rszayFeVFnmDJQoyO7RuMGSo7k8PuFX2L8F7vw/ZRZz2DbGzpZ2/Ih%0A6wmVrQ619L6w+Q3k90k31I2TzhgoalJSaehXtmz33u1GIEPUvDHfGDihPsMU%0AA3m0Xh3rm6SHv9hkmUt3LawuM0iphfl/iunKz8YbKlqdYcpAhHyvuGKg5EiO%0AIV9Uig0iGojGoHu0Q+8arPupOaTx797lnzf7TEg975lWmxq/lmOgySBsXLK7%0AZZqBzhLtQLRs3uy8gej9Kcdl1mUAMaw0rfoz6zpPaQeiH+upGUIZl8fZDsTb%0A9jhXed3WY44H6oi4lFbBPqnvLr6mwTDREn3UPOEDU+MGco3kEKI640UCrUC7%0AqaA+K3SX9N8GK4jPtKCR22734jLdQMPifaVP4gbyf1buYr3ntFTf8m81v9K0%0ADHSuGpSSOrTWSNzt3viWnuhSjqow/AKwETlPhA/3LIxTYqCT8VmspYan+n2/%0A7zRQ8tVFv3291cr711f5ZHEgT+xFS7rDixWDW6k/3qAYM5BrJAf7Y45F688A%0APfFgRn0tKjfPRg+IjoGG14TEh3eQW8MmMwfex0c0JiYb7HBjUOKzqIq1lMpp%0AtTDWsBv1hI3UYAlavb2Mjwea0LhkfJH3f/5wtBJSmRyWwkYzIaDyyfh7nvqj%0AnYiB8mJ2Rim0DOQYyeFF8zjY7DBCbiafcMFBioG6xoyLUtGcflGScxT7sdDG%0ALLj+6OvMKNu/7v5jHaNdQFdZHXY+FYsJsDaahIFalctcfGqGuxbGFlD5zlsA%0A2agtVifWJ/T1WFU2sP1TTEDsxW5NNRkGkis9qS+klJEcYtUWNRRSVAMLPVxx%0AANarpa7sGUMTzciI1XPiBvrf3WtICleXiTNSDESN8cDsUzgU/+v2GFo/Z18z%0ALOHJqMIC3NuJHpvEw6vYKxgG8n5W8raBHCM5WCz90lODMdhcERqqoTEIgHWs%0A/cZHSHCDsAdzxmKSj3e8GU+Mb8jFK8XaQH/SUFMbqErqVBV/CQNNokjrOWz8%0A+yqna3RoaPKtQ/4nBDTs0NhHjqE3Z8CbBoqqj/I310iO5/tmlH7Dq9xBgKIK%0AtjgE8mL9Wmqwp90JSaXDVtqRTTF7HZLoC/O/jfiCcca0ej4xoiHiH10JErMk%0AzISKRxoafVI+zJm1Jj0rY99ypze1HxUGAmC9W4HUeheWTapy4Ja4l3V00/qk%0AbmqmKNbzFMUej6z/4OXfmFj48k1V0hYGajRT34DKpfJDRWTP46v8IGTLYMJA%0ADiWh7IKtENBZnt71ldaB1azM+pW+VS75iPZh5QetIcVmzl8eyA40UmCNOaUx%0Aa+e9ke04NL/K31IsVTV+WbQD2cv9GAby+0WrwkUKYuFvtoYBET0Rqjee9bzf%0A3f8w3vKUkRwwEABry/BAVHKGZs86swJ/eCDXO2SxjRUg0XipK+dvnHfbclSj%0AuRDqY1/Og/BK3V+8o/5zSG7Z/9EI53M99Fkux2i2+QxItMPTIJQ1MSsGYsNa%0AtVKmjOSIlhIJN9lAgaiF0X/Fb0EQuOtl9FORv6B4g3VnoFdiPvnTXHaVt+Cy%0An6JJx9hlVt7U3e6swX05IRB/dK9W000wbblC+orJYYzDV/aqv+UyH+aKjFNG%0Acugh8f7rZveDBVFzUJAeAxG4BwCwOgN50w3EoyB8WACAjzEQ9Q8MBAD4GAOh%0AFgYAeCcDBU4DoRYGAFi2f0TfV/RP2hhFVgsjHiIhAMCHAgMBAN5LNxIYCAAA%0AAAAAAAAAAAAAAAAAAHwEGCkIAPhQB+EjAADAQAAAGAgAAGAgAAAMBAAA72Og%0A3VURAWsNblIEQTAQgIEABAQDwUAABoKBAAwEYCAYCAYCMNCWGAgfAy4N+FAD%0AERRzgEsD3vsKIxhCMcelAaiOoZgDXBqAYg5waQBAMQe4NADFHODSAIBijksD%0AAIo5wKUBAMUclwaArS3m/x98JDAQgIEADAQADAQDwUAABgLrbiB8aut59QAM%0ABAMBGGgTDYQP5QOAgWAgGAgGgoEADAQDwUAwEAwEA4HNMRA+v7W7egAGgoEA%0ADAQDfSAn45sm++m/fm0mn+13L/LZ8yqFVzyPnOus88SD/uj+kzyxe3Npv2wv%0Ar87q5WEgGAgG2loDlUJS5iY6JntJBVXJERNAqxVZo2jQIXVtstcJzWvvsNZt%0A+weurHJkbz+Re6Mp30Th1H5CZZAjhUMYCAaCgbbWQDUpkRoRJoo74oWK5rP5%0AXEvHJH6fFK6akWGOnsO9ywPSpjI79RwG4jLzzouHUe4y25NjwzOR+IyzYCAY%0ACAZKfpKDJ/pE4SyfPDDrOcdqXyt6m7UGxX+mvZTfGnVPp+XGb3xCGoeOgwzE%0AXr/l9W/2eYhj3ersfeSFAOrq+FMieuoUzHoV/zP37qhUala0M3xV8VKhKGym%0AbcMNdHLcOISBYCDwBgP1SePSGx6Im8Q6iNVzbr5UKpUHdnNSr5xOe6nzUCRI%0Azc2jdZyj5oCIaot1kCXisV+/FL50u0wKpzQjFo8MK3n1TEFo40X7w3LEI/1z%0AYnocsYxu/600hbb8yg+ZtJV0iWWgAgyUxiC8SdZnT/50POj/2e3ZD7wWeaqH%0Am0PrIjUTj7FrVWFlrjsxQtbuRUUwNh+GgdbJQPQuPRQWKMcOXPUc//Vrnj8/%0A3RaiCpOem2wZka0q1kEW7NcvhexEGrM0a6RwS0UTqhteOmFQ7MnTonjHH93n%0A2dsse6XixIp0PtNMqKqocbmz7PcuXELLet5tIPrOtNJ2y0B9erPfjbufyRG7%0A4a/J93yy9cwMQeW1saNSeoW4VX7+iApSWX5H5c3SdaYLmTrzeUwKVEmyzOkX%0ALtsZx3l29VxEpks+CwMt3UDq7uDf+daBrQxxBWv8omc0UHpu9Pm6pxqQrYMF%0ADHSUF00yNL9fVinn74NGM7/H8qyT16/UVo2m8AYpXKhmIRrp0LfBsuMl2Szj%0A50YtjHqpbhqo1ZI5vRDjGWogv9Jk39e7YKAq/ahoCPMQGt8j32QActf9zn78%0AbYau9BP7wkwlW+tF0jtaJxYJe+ra8k/O9kqNNdY1vtBkZ5UOv+TfRpURT0lL%0ARpudf6YMdFVRGR86y9GZ629R4qIv24OBVm0g1d7BNWEduMwyPvOyGyg9txpR%0AJqPFxjpYxEDPorhG3pAGeqDfyw/UHWWzDkh1tXd5XJiwoIUGYf9Y7V2FXo69%0AKetbllsq3tA0KhZZUxdp05wGrLzKdmnxREH8d8jP+n3fXLKBhtf8raafYSRw%0Ap108gXHXMgPdXB6bkWzLa4kgZ1hpJoqIHfLyj1eEKkZznfjGkyVIPUxlp8+u%0AqiskXJVjISi9bL0sMZArOPes78JkChho6Qail0t8ebBLZB24ipl4PKOB0nNT%0A3dNV5ijrYAEDNeT3nGkg0u3esu52XnhL/x0a59Ny1jsW91TklZNO4TNriSYv%0AIU8Sf+c6peoMa+VlLYwGRyy17hljT4h7os7+Qta8JL7ul2YgfqNNq7saCdxp%0AF08ww0A8EBx1r+5ovelvUpcfcpUFOnchi4HYT3G1HqMY6EA117HP7QtrTDwg%0A9OG+fJi5xm2g1iB8Io0vHV06jBjIUWKr7u9ZWjq0dxI9ojDQ8lui6Z1IqyFV%0A8e1mHThCIFG7Z7HudUr31XBM5P07JTclG/7TOshqIOP1lYEI+V5xxkAqBsup%0Ax7mB/NevNOWVFdkMjxtNlt1zh/SKZ1F/2HM0doi3bZudYdQ5w2v6h4qW6Gr0%0ApWkaaAm1sD/iJ8oaSjpGAnfaxRPEa2HUQEws1CSnURTCBjz0IleIyEQ1OtfM%0AvoDYlxVPmCP/O+cXkP4iK/W8/sz9VeHfRf7PCq2FNVhHA9NHdAmiGGj0tfnY%0AyscCcfdflDNzqMUKJQy0fAN5ww6J7ifrwFXK1LdEo+k/OBJS6bTzLJPTKbmx%0A0X77KhayDjIbyHh9XQuj5ZINDkwYiL4nyVXejKHYu+N2VIYY/HeR987/67FG%0AI2bbyByyAlAjBe7godUSTb9ndV/Yqgz0xx8JA9Vm1VqNBO60iycwy0abieev%0AYxEwqfuWOoBep9sOufpbfzLCQEw2g+7t/cTREi27IJWB/rzZj75IeGStX+Ch%0Ayzs7WvozphdV9jv8rFjchbG/oOqug9E/NHqriXrY4gYKsiRqM7JlFyzzdaN0%0Aqfm2l26gUtj4wr/DEwdJu8jLLpts6I960g31KAxJy20JBjJen9aVbovFMXuI%0A1xISBnLX4h77pH1MaNQ+sQzB2sXzTDj9m/14mE5V9iQ6+YwTdF9YKVyZgf74%0AI2GgqpQq/1PZ8IdCO64EncBKu8QEdmL6UVJxJwzUYBNZrNCEPsZ7LG+/fqlc%0A/uDDHH5WzJboivwGkwYiZmMQeytH+VIYi5dVK2IpfImU5l/r3vi/E23OKYWD%0APWy6KdaIuaiBgozGaGe91zPmN+N19bM63fsZSLR1DMVQGevAEZ7W7XaYZLOA%0AbFU2e+NduS1eCzNeP+oLE22IpTBqGyhM6IPji7yv+3ejWpwYQ0gL+JkyxLOo%0AX91+DnmbRy/WCMByZ6HR8JjGed67GegPSXoMxCaGDF0jKN4xBpL1tJiB6Cct%0AWmJG9x1HDKSGd7A2a2kX9omriyUNVOg9nOVV8St1Q24g8sLlcie663mc25j4%0AD4WLQdjYt4J2mUs57fuUV+C1YPv0H9NAsb/7nWKg7AbKnH+Q8axZ76/dXrKB%0Aqjq2rccO0rsO0g0k4xhhoPTcltQSnTAQf4tR+zErp9/zbEwJ/b/NmhyiWhzh%0Atwt3hjjgzaGfeA412UVnvyHRRZIjt2GjGQ/mhYHIbfFp2Qb644+ZBuJtFY6A%0A9D0NRD+Az7yvLBYD8U6wHKv+jvREFmGDPil0u90n8+uJloTuVZ47J2pIvqZ/%0AV00EuPQP9O/vmelExfpoQP4n6205/hneTtjVbufnM5D9F5e99TRQ1r0MVmyg%0AtrdkA+luJXY3WweO7zirJTfFQPwRbqApuUUd8PXYwWIGotF83jAQfeyB2Ue0%0A0bAGhKaOgVizJDeQ0lFU4ET2rF++HmugPNVj5GwDfbsLeQw0qdKbp2UY6JHf%0AQG830B9/ZDBQSp/OOxto707EQLwlWt7dpZBFQCPR7aXCFXGD/y5OaGBqZTmg%0AlzNHTgdqqq9yR118s6gQnBlIhC2RgU5ovY1e61MZdHWkwljjFL0C3GPlLLUw%0A0deyEgOp+k0QOwzEb+qn0RDkpRuIpeXp5Unmsfjh6X8Ch1l4cs9IF3h2uiBZ%0AL1udgcryavNbLzpwFMfZBqoZMdCU3JY0IjFpoKheKW9NevCXMNAkqqbw84ev%0AX1VTevQG/X7YuOiLw6rZ7EHrkrfCwLXYnHkqHcK6gHgtzG/l2WBr9cRTY7JI%0ADGT6J3miYaDyhxvI//PmzqyFRR3nrL71F2tY0x1dTNMsP1ZA/D+7h2ZgfNIp%0ARBMztIF4MFPV4wSP8iLkaTyoIRg5+S1CX6NnlIBpMZBzSElUIavry7ucdqBA%0A3dyBdageCmKSmFULC6yctEbsRwNHOs9OrtMF8XRB/IX0G2sv1UDq7hARiHXg%0A6KW0B2o5kskIQchqSm7CHXpWhnGQ0UDG6+tZGfuxDlRW5Gmahoh/jNF0svAN%0AiB60fZS3OtrY7A0zBnrsk7NPqoU7Z47L+3ZNyFWT33KPYtRdv8hf/XH0xGbF%0ALVALs/0z1UD1NTOQ1TTUpzo4D6+auqOLBZ2nNVJnD+ipK2x2Mnu+ZvwxkYFM%0A0dJMqbeezBjoZHwmZcfip6grYloMNOUvMpQeHxL2VgM5ajlBkLzf7fbe9jwG%0AsvM3ZeQ0UMx8Qewkt7ecwdmiBhIX7fGasPY76yB5XQwD0ZvQrzqS1dgzz6xZ%0A8Ne03FjXxaU5M/VyjpmpsddPNRAvlFU2XpkZyGi8UV9/LTlCxDQEvRMao5DU%0Ah8cs6BFjVR555zAv2M/jq/wg5G6RNxNf2sMI6at8WC8bLzBRzfdvMFBcP9MM%0AJP/g2n+HH22gu+tuGDPQtw6zQOWA7F0eqBGjtMJWGDMD0T9brckQNu7EZ1iN%0ABgilGug5rFdNA9G4k7cOdc6ejwt/Re2V1zdNmcu3+8v0ds10AyW+PZdmIFYP%0AUrUw82dGA3lBTD1pBlKvsyQDvb2FfObqHBf55EEiBlK1sPv7UZiy7MYzGwJ0%0A2+1eXE7NbaHVOezXV73xrDn27v5HS8/uqKoSr+atq4HMNES7sdco03fXIHzp%0AsRf4k333sRGV0eqG7EhohQ9z4qslDuW01mgiAE3FvFjqtvOeZaCarF1kMZDD%0AP1MMxNcWoO/87KNjoAILFIWBxFoCVAv0k/+30mrR99g7UHML67z5vy6+SHgd%0AdyzjSGaKg2Q7UNxADyx4slqi+ftjdb1q1O0vRwTxGIiWl8QUsJOOW0G+Hr6d%0AnCm0LAMFSWkkamHLMFBqLWwBA71VQVu7QpkVA7HwS5XU7i++FuLnkPev30YD%0Amf3+133braKc+aNQLLTq94XdWGfaLy2n6BvbG8TnLOZ0A4IRy5Xk0iAdMStD%0AvK/ZBnL6J36ibLEoy9Yr470lE5hpl5kg4vEhFHIuyVZnccNbA6lVLYx9MQwr%0AA1ELi9Y/YRa/faLfQ/4D/Qy/TvJGX5jnGQNNS+FL8YI1JnXP8i3fNBB7kfOw%0AoQcE+a2o681cI9OIgq7yrlhf/qn0myb+JbvEdqBgvnageJTsaK/xosyiFuaU%0AWphhp2COdiAYyMHwlUUjv+USHPSbVPzij+7NtRCncS7Dk8dP8ky9GrRvDH42%0AGk2z8thKPjbLQCn+WfNL1r+ZSO2febF2IPHhPY+7agj7WYUvNHXExx92jHnw%0ARHakD2VQGsVAj/1obARb9WmfmucfmutAj3cVozFGPISVTXRyMOK1GJLUdwjU%0Aj4YIuBh9vcxw9ebqCwuiWpdn9F25usKm9YWZfVZmNlG7T6BfwIsnkCFUYPSq%0A6ePk+4m/L/kPDLSxTDXQH6n+2chL9js0Yog+97w/mqRW5OKGf2bLCfwUawrU%0AdN2MSi7KdChXHKCV3MbD+OsX8xun9T5XbyMJPuA1YaC1N9AU/eCSre3V20gB%0ABR+gIBhozQ003T+4ZDDQhgMDrbeBZvgHlwwGgoHAexgIhR8GgoHAO5bhP0wD%0AofDDQDAQeMcyTK2jDYTCDwPBQOA9yzCPe6SBUPi33EBZF9iAgTaOk7HY/s5/%0Ade3/1O865oXUumd8/GGNOHbOO0+c4Y/u5U4Npe7NpZ27mrhx3u3l5yvDsuaF%0APVN3wkBkxz+7bTaQWtnj5Di2dAZHzr+2R+XXyJ6cpbS3f3IfGyXnmKdfVSPi%0ASqE9hbaqXzLbMrPRJ6/bnndxz1Rl9g/cFPW82ISBYKCloJZ0qDmnLlX5rs2f%0Ao+fY7oNjsb8q//kUP01NFDuPBu3r+dIZN2eeVYbN0T+7uGeqil4/cFNUX6yA%0ADwNthIHETn5EbH3RGhT/mZbYb426vOyIufFny54bH3v9FltVnoc48Q0FW/ae%0ArXorvFa0hoe1HQvftjnalMfYk0ctxto4XIqB7NGHbzSQL5ciEjskFX4lvuPZ%0AIinN+K9LTWB+DPPtmaqj13fZFFVst2gv+5FhvyMYaH0MROs5N1/4hMKyV3si%0A03csZKWVJWCbzXlD116ofEEJc32g5hzrA8VevxS+dLvMFqdyxRe9lw6bwyin%0ApyuxHBq1sKSB1FRSh0us7eGXaKDkpclY+M+7aq4m23uRzeYsx6uSbB1+uQac%0A/nWpCay02fdMNTJ6n01R2QK6bNmEul1pN/Ywg4HW3UCyniO2Nsi4Z6r8YnOt%0ABCWaTIzSPe8aiY49U/eaNVGz0nvpSFkM5LR5WkqjBuaaroU5Xla4xK9U8m4D%0Ase/W/DIM5Lo0GQu/38rpTUbKXnLldbGsN18/0fh1qQlmGsi9Z6p/Hb7zpqhV%0AucRItEhj2Sg6MNAmGCgPaUxqAAAgAElEQVSnVpc69TIbKKcXQXUs5rqMdaJt%0AAx2JDZRZfr+sJhv+PvzKj9/jU6sl2hED8SYiVQvrmEvV07xbLbng/YuxjjC7%0Ax/xKk7WdZjLQH4aB3Jcmc+GvWQaKx2bCTzWxG4m9iuSyEiRrYZn2TGXLcJSj%0AEOYdNkWtygXFo301yo6CtGID7bqAltISfTI+87IbqKa3IkzuI6NMJrbFOfVc%0A69HNa6BnUa1P7Fj4QI4qD7T0ll23b/yuauWT0Yw/KhZZixZb8HXCFyeT7dLi%0AiYL475Cf9ft+SmOJ3vLCHn64oIHUgv3xLUHrKo4xfl1qAjvxHHumRgt0v8+m%0AqKUiC1llxGNuiprLvD8LYqC1MFBOh7FZDMSLkrOKvqT9wmwDyW0TLAORbveW%0AxjJ13sJQ+s9q7ZxZC/OizrBWXtbCaHBkbUzInoi2BeNLIe41p/hHGWjKpZnb%0AQGy100n8U452ry0bvy41QcxAmfdM7RdVXe19N0XNyT/C2BS1RuZsi4aBlm8g%0Af2R2WIkFP6+aKSGQ6GMVe466u694v8xLKHdtJoWLVjW2oKm3jD1TjddXBiLk%0Ae8UZA6kvuhxJqYX5f4quu+do4WjehG12htFCO+Q7UGfcHj7FP8ltvxY3kOxL%0AbMa/BGSVtGz8utQEic6KbHumnhTPou2W3mVTVHXMz7M2RYWBPt5ArBXmk94T%0AYMh29aNhs9sFqirPd4JgyZL9D7SgtPNDue+3WNI9mWgJ+8Ybr69rYc2TY3Yb%0AJgwkNthkXOV1W485HqijFneWnTE0PuKqHVot0fRW0n1hcxsofePBJRioT3qj%0AeBXknQ00x56prC1Rfim856aotHCIOpi5KSoM9PEGKul9+PZ1qJviAn1JZTLH%0ARmBRuC5ioMaX6zCZ2RIMZLy+2iuDl2GaVcJACVry5FYr718n1yqnH8mT6Msz%0Ayue828On+GcVBuI3H5V9PeVK2BdleQlsA2XeM1W4RPaCvtumqCdjfqFjm6LC%0AQGvSDvT47UG2ZhIzFki0jtTtdpjU7ZjN3vhhJ2mWxWth7j1TeX9a1F7KhoHQ%0AB8cXef/nj8RbYDtv7lGhxMfZsUxYQR2aX7YLGCi29uHSDaQjPetj1nrW/oi1%0AIy+ewLokmfdM5QM6dP34vTZFHcoGhNimqO/aEo2ZqSntQM9j3nAj9i2dEoZE%0A43qm7Rsf7dqshmPI3vYVtEQnDMTfYnQrssaE73lZjWjTJFFjZV+H/TTR2aeY%0AgFjWt7aaDAOR2+JTZgMl1l5dlYHi3QPv2xuffc/UUljWZendNkUVAvIrn+xX%0Aetfe+J0nrR2owzcArc3eOTn6BpxmIHlTiHj51JsaKomvVutgMQN5Pyt5w0A1%0AFriXVeMN65qTTvH7RDV9noxo4SWF24keVkhkP145FjOVvW93IY+BJmzn85Zh%0AoEfemOEwUIatTxc2kPw04vsL88slPlTj16UmSBgoy56puWiM1rttiiq7UGpG%0At4KzsRoG+gADySG9NfklJ6+Ra6OrGpltoJoRA+kCkLwzlzQiMWkgz7oVaRBG%0AD/4SBppEQ7Ofw8a/r9Fugj16l4ixcKzKeKsbxpq2gQqEjbfjtTC/laf3hH7i%0AqTFxx0BZtj59u4FU8FhjI5SGB45ZGX9Fo87/cgasCyaIGSjLnqn+3/xN1+Q4%0A+HfZFJXXA1utZ92OqcZnVzMXORhoVQZS32vCQKrCJCZfJKpORi2s7I5aZOgg%0AZCXvSNdXZ84MuXKz4y/nl5tunUjZN56F/SxsF/GP2iGYDZ+9jDVsqeYwGhp9%0AUiF+jhijCL5d8yEKLJR6FFOc5KzQx9ETjyFnGGh6GX6TgeQuraeeGgHRi5/w%0AjjNTM++ZyroxxX7Y7Mc7bYqqp1WrBke5Keo7z0yFgZwxEL/RHuk3SOH23zz9%0AOmWNIt+cE42rpoHoSX6VNPaTgRJ9hm2d3PglK+2P145krDfr0pyZejnHzNTY%0A66caiBewKhvIzAzkuH1iBnrkGwjzG+F5fJUfhNwt4vXEECmje4VvSs+HBUxU%0AVmkGmlmGt2B1jux7ptoX4CM3RX3v1TlgIHdLNPtyI40vB8IAbNQdIc4VpXJR%0ALez+fhSmLLvxzIYA3Xa7F+zmFatzXCx7dQ779VVvPC2//t39j5ae3VFVY6TV%0AhPbzomuQLFvlomm1fhSEVvhoJr5a4rA4UV/TPZ2K6a/Uld1l2kC1bs9WUIYy%0AvLUrlDn2TLULy4duinp+c+jBQB9voI3HioFY+KWaE7q/Rnxgc0hu2f/RCOdz%0APfT5Rfww23wGNAN1B/A5YDEL63WSdMhWipqU2GvMaFvYJQNtH7gIMFCC4SsL%0AU37LJThotNOTAfi9nGeapDWl+p/cvnwmj63FyjAMBAPBQODjyjAMtMMGkhu4%0Af8RG7jAQyjAMtJsG0r4JAhgIwEDgvWOgwPEbDARgILAuBtq+SWQwEAwEPshA%0AtI7Fq1n6n0BXuwK7NqZ/g4EADASWdRGEdaRvgug4ioEMIW1pxQwGgoFWiho7%0AWItvec3WUs1v79XLXusKkj/jBtrmViEYCAZaKTk5qLmmlyBQqAmgiUWaYCAY%0ACGysgd5h4ukce6ZGc+ZqeradmrglF4u+JnNPRYeBYCCwpgZ6hy1R59kzNRIP%0A/0XMU5djz6ubb56FDWS0AwWZ2oHQEg3W2kDvsCXqXHum+tc3+yf393xj76PK%0AyNpXGwaK+r4C0S2mjoMgkP1jQWD3iu2QgayZ6WzJVlJw7daTcTb7cpNloDUo%0A/rODBnqHRVjn2jO1Rn6xlqDLvFELE3sVyFrYiCR3bdqxWtiOk7pO9AE5aqrV%0AefqsFXHYcZQ0K5l1sMJkGag9EXK6gwZ6hy1R59kzdTj+rtYgtA3EHqqK5cD2%0A9nfWQEEABaUaKCfXyzS+5Bxry1vJ7IMVJsvC/KuNb4OB3mFL1Ln2TM0RchuK%0A7xBmILVaAAwEZhnIWqU5p9exfOPKzstNBgOlnvgOGxLOt2dqi29Jy1ZufiBH%0Ad6G1FDwMBNINFO1UwbevESUnaSArmXWwwmQw0OYYSGxGKlduNmphBd0OBAPB%0AQCnrREe7dfmVilxbvuysNs3c4Wu5yWCgDLWwlW2JOteeqWx71Fbl9V+xZvOd%0A2tOUBT4lsWxlKTyCgWCg5Cfp2rHU0eeRcZfT5SbLaqD29QJ9aRttoFVuiTrX%0AnqlMMzeTvNy3Qm9w8Vi5ZKv5k0L3cDvuIhho2QZy7dp+cpzolsq40/tyk2U2%0AEGk0/Ye3nb2pBlq73vifPHqOG4g/cvQ3aR8UDmGgrdAI/2+1BvIdpWW9DSQ2%0AFJ93C/DNNtA7bIk6z56pgm/3nbiBBqSxXyVlttMsDLQVAnqzgrLWwvwD92Zh%0Aa1wLS9nAdasN9B5bos6xZyqtcN2NyVUzHgPxHYyqvBmIXDVhoIXIPKgoWFI+%0ARvk0BPRWBWVpifbYJlkN92Zh694SvWsGWq+ZqTm5L1xOtUTzS+r3CdtPjffG%0As93XChu/SscmGGjm8Efj+VhSZzE04p5VGCjqC+cR9vC44byPrWSxc1aWDAba%0AmApAqXiWbAdS32ZiXpj/kNyyEAZaTElvi4FSk7obeUiy+kWWaCB7PKASkNwV%0APWL9RyTCQOvAeZdN0vNH96xpriJiJv+6+4+3JWy9gbx3N5C8c8W/J8fiLj4Z%0Af88nwuwomX2wwmQZDVT2dq8lGuyKgcRs+kDXrsxjtdCH+idwaEWn96J5+PoZ%0AsxYmiyEvivQf/h9xVMWWbSDWl3Qp5oWyoTUVXo1P3s1GstjBCpNlNFCh5/lV%0A0tiHgcAWxkDR0tHG3mLG6mbmqmeudc4Cz16jOn5ePAZSshEqSjyzdAMZa2Pw%0AwWOCZIVoXVfn8O/vRyEhhbO8twMGAmvAhxvIrkKZUlmqgRLqWZGBAAwE1thA%0AbDkzL4uBgsC91msQl8+8BiIeDAQDwUAw0HQDpdXCFjYQiTdVL7U3fvM4OSZk%0ASm0RBgJbZiDXWtJepJ1oF0R3LSxpnOg4SDEQIZlqY4iBEAOBnTGQ7vsyN1iN%0Aerv0zqyxLi6zBdtek1qdFy+GRHSDiY4x+StxdYnBQDtlIAA+nuXOTAXr8S0K%0AA4FdkBcMBAMBAAMBGAjAQAAGAgAGgoFgILCDBgK4NACgmANcGpCpjCR/QzEH%0AuDTgfYpI6gGKOcClATAQijkMBGAgFHOASwNgIBRzXBoAA6GYA1waAAOhmOPS%0AgO0R0KYqCMUclwYgBkIxB7g0AAYCuDQABkIxB7g0AAYCuDQABkIxh4EASCkj%0Ayd9QzAEuDQAo5rg0AKCYA1waAFDMcWkAWP9i/gf4UGAgAAMBGAgAGAgGgoEA%0ADARgIABgIBgIgB0xED6VjwAGAjAQDAQDAQADwUAwEICBAAwEAAwEAwEAA20e%0AJ+ObJvvpv35tJp/tdy/y2fMqhVc8j5zrrPPEg/7o/pM8sXtzab9sL6/O6uVh%0AIAADba2BSiEpcxMdk72kgqrkiAmg1YqsUTTokLo22euE5rV3WOu2/QNXVjmy%0At5/IvdGUb6Jwaj+hMsiRwiEMBGCgrTVQTUqkRoSJ4o54oaL5bD7X0jGJ3yeF%0Aq2ZkmKPncO/ygLSpzE49h4G4zLzz4mGUu8z25NjyjBKfcRYMBGCg5G0weKJP%0ANCZedFA4S9Q/6A0pobdZa1D8Z9pL+a1R93RabvzGpy966DiYn5bXv9nnIU7s%0AVveFaHIqyPFbnxLRU6dg1qv4n7l3R6VSs6Kd4auKlwpFYTNtG26gk+PGIQwE%0AwBsMRGOAifcsqzF90rj0hgf2HSPrOTdfKpXKA7s5qVdOp73UeSgSpObm0TrO%0AUXNARLXFOnhLFeyl22VSOKUZsb9iWMmrZwpCGy/aH5YjHumfE9PjiGV0+2+l%0AKbTlV37IpC2XSwwDFWAgAN5goJq4K8UPesseCiWU3fUc//Vrnj8/3RaiCpOe%0Am2wZka0q1sFbDMROpDFLk/4Rt1Q0obrhpRMGxZ7UXhTv+KP7PHubZa9UnFiR%0AzmeaCVUVNS53lv3ehUv8SiXvNhD9W7XSYCAAZhtI3if8ZtS3Si5qnFW3nvh+%0Ar3H1ZDRQem70+bqnGpCtgwUMdJQXTTI0v19Wywx/HzSa+T2W7/rk9Su1VaMp%0AvEEKF6pZiEY69G2w7Lg9zbagc6MWRr1UNw3UasmcXojxDP1k/UpzVGzCQACk%0AGYjKpB59Y6vGj6Qz5K07PvOyGyg9txpRJuMvahwsYqDnUMn01DLQAzmqPFB3%0AlM06INXV3uVxYcKCFhqE/WO1dxV6OfamrNZobql4Q9OoWGRNXaRNcxqEhZ5q%0AlxZPFMR/h/ys3/dNGAjAQOkGovcxveV4LeOg4G4WlpFQRgOl56a6p/mLWgcL%0AGKjREfmYBiLd7i3rbudN0KX/DrWBTlmw0ztmsjG9ctIpfGYt0eQl5Eni71yn%0AVJ1hrbyshdHgiKXWPWPsCZaW6Zf+hax5SXXOw0AABorXwtjwF175YHWSaqGX%0AEgJ9z8s7uH2d0n01HBN5/07JTcmG/7QOMuL3Q/oyohddGYiQ7xVnDKRisJx6%0AnBvIf/1KU15Zkc3wuNFk2T13SK94FvWHPUdjh3jbttkZRp0zvKZ/qGiJrkZV%0ASdNAS6iFYUGTNV1bBSxmIBmB0FoHv9uGHUJISgRE76lTdQeTRtN/cCSk0mnn%0AWSY8ZUpuUnfixa2DjH/LkEZX7PX5iboW1jw5ZoMDEwYqhWokwVXeM2I49u64%0AHZUhBv9d5L3z/3qs0YjZNjKH7MavkQJ38NBqib6qVHRfGAwEA4G5DETvVyoT%0ANiBHxECNL/wLPb26EzXZ6Bqc5ZZ6FIak5baogeTryxNoXem2WByzh3KyKmkb%0AyHX+qffYJ+1j8sRGQpmGYO3ieSac/s1+Nfb3UZU9iU4+4wTdF1YKYSAYCMxr%0AIM9n9anCBb+pRcPHsON2QTSyT7YDJTvQZauy2Rvvym3BWlhJVPJkZBL1hYn+%0ANPUsfwMT+uD4Iu///GEbiNYixRhCGvydKUM8i/rV7eeQ9Ogf14sNi2a5s9CI%0ARmBtR288DAQDgTcYKPrqZzdNPTpwRA7lWQaSYYkwUHpuC7ZE29GSYSD+FqP2%0AY6qMl+95NtCA/t+mSc70+ycsuaw3iQPG4yeeQ0120dlvSAwXyJHbsNG0bKoN%0ARG6LTzAQDATeYCA+o0r3cTlHB0axxTQD8Ue4gabkFnXA12MHGQ1kZmgYyPtZ%0AyRsGoo89MPuINhrWNdfUMRDrXOcGUjrSp+TFG2f98nXrRYl8uByL58ret7uQ%0Ax0CTKin0WoaBHivXSzUQivGH8wHXIQi2uxbGB7rwAERHOTnX0JwamW2gmhED%0ATcltwRGJNRUD8bkSpoFk3Ut3U9XpwV/CQJNoaDZ//8PXr6opPXqDfj9sXPTF%0AYdWce0LrkrfCwLXYnHkqHXJzKWth9MNkg63VE0+NSQ4GgoHexUBrP6AjxUD+%0AgW5A0beiOxzJEaMWVnYnkxGCkNWU3IS79KwM4yALql4n5ojoWRn7yk+6wZy3%0AczdE/EOiQQHSoAOiB20bhmAxEZu9YcZAj31y9km1cOeMnLxv13xQAIumHivc%0ATP0if/XH0RObFefBQDDQ8pXkvsM31kB7+8+hvKUP2GI3j9ek4ZBB1TQQvQn9%0AqiNZjT1DsyONX9NyY967NGemXs41M7UWUiN43zqyLyzFQCU2RrrKxisf8h4/%0AL2YgryVnY5iG8PukMaIfx/CYBT1iktcjn5/KDfQ8vsoPQu4WaSs+KMnodauy%0A3/h4hYlqvoeBYCAYKLUWNvyTDSFU3+piPQ3nmoK5qBZ2f09vUveyG89sCNBt%0At3txOTW3BVfnYGMACbmRIxJFbzyrRt7d/2jp2R1VNUZazVtXA5lpiHZjr1Gm%0ADTEI2Ufh3//JqnJsRGW0uiE7Elrhw5z4aolDOa2V2qmnUzHhlrptZTdpoFq3%0At0sGGoQ3yQXeTv50POj/2e3ZD7wWeaqHG7NIjPiD9mN8kjCLO7sTo5x2LyqC%0Asfkwvfw3aUXsvNhcYwMFohZG/xW/BUHgrJcRXREjG2WgjceKgVj4JUO1UvcX%0AXwvxc8j712+jgcx+/+u+7VZhIH8UioVW/b6wK+tM+6XlRHNWzuVzwGJ61gso%0A6ViuJJcG6YhZGSqE3B4D9enNfjfufiZH7Ia/Jt/z8Yq2HszpeVGoaC/TpGbt%0A6AETsipvTxSkD555nj1Vz38ek8LNYWz2TC4K1a1hILn0qUT+nzf762sgFfMI%0A/UyJgch6x0Fba6DhK4tGfsslOGghF7/4o3tzLcRpnMsv4cdP8ky9GrRvDH6m%0A39XzLqL22MpUhjMYaD17gdkgefqxPIRGE943GYDcdb+zH3+b7fn04nxhppJt%0A+SLpXadwIRLqMPJI6N8UCJ953PhCk51VOtwx30aVUShHxrbZ+WfKNFcVlbE1%0AaKPuDOzLxkuuuYG8GQZa86oY9spY25aEGQZKG4cy5GNJe9PqqjqBO+2iCXLc%0AQDeXx2YnQstriSBnWInXbU6O7d6GVl6HKsb6lTXV4l834iUqO312NRpyKoZc%0AneWNerA7BnLPttYdsFVyCgPBQDDQNPvEz+L33LQeRCOBO+3CCZwG4iOhRt2r%0AO1pv+pvU1dgEFujchSwGYj/FDf8YxUAHaoQFW0jgC1td84DQh/vyYeYat4Fa%0Ag/CJNL50tEKMGMjQSi1lkK2qsodZe2JhIBhoVww0YyzuzJqDkcCdduEEVWUg%0AJhZqktMoCmE7APSM0IJHJqrRuWYujptoruEjz/93zpVBf5EDJviCctxfFd6V%0A6f+s0FpYoyOmFhprWUYx0Ohr87FlTUZO1MHUeTMXnFk3AwVoBwKrNFCG2QC1%0AWSu61eyh3itIUCVtJp6/jkWUpMII6gD/gdx2yNXfWgzCQEw2g+7t/cQKRGT/%0AgFiTWxlINA7n9MweIwZ64A1yfkt3IQw7sgrGtGRyp+YQO2Mc+jfpN5jLOiL/%0AQ/rCWCN09E/KGEX0hYHlGMjtnthZVdnzxr+52dYAhXbcDjqBlXaJCejDtAJU%0A+XGSMFCDteVboQl9jC/hffv1S+XyB2+h/1kxW6IrckkXaSBiNgax1z/KJyyi%0AestK4UukNP9a98brxmm3QFnPnJ5JXMu6Qucm3DgwEHirgdIjnykxENs0ceja%0AXWDVMZCsnMUMRMUgWmJG9x1HDKTGsrM2a2kXJhvVGS8NVOg9nOWVgUrdkBuI%0AvHC53B2rHiw27tN/KFwMwmjUa1WMxy8b9TH99mt6zMQp28rl1NsCA6m/CAYC%0ACxpoer0r3UA1Oaev/t4GokHEZ95BFouBeCdYjq0HN9I7Owob9Emh2+0+mWsb%0AUNl0r/LRXBfekMzm89bEik91PgKWmU6sNHc0IP87UPP5GLcTtvxBO5/FQPYf%0AV/a87YyB0A4E5jfQrDUg0g1UTWnCeAcD7d2JGIi3RMtKUilkEdBIdHupcEXc%0A6r+LE//nDyufAdVnjpwO9KwZ6Y66mH2ommeYgUQAExnohNbbjh7EHGj6kh2p%0AMNY4RRXGPTbFQGLJYRgIBloGJ2Mx2p+G947h9f2uY15IrXv2SZQ8x0SB88QZ%0A/uheDkwpdcW46Sh3NXHjvNvLv6UM/+Ey0OySbxio/DEG8v+8uTNrYVHHOatv%0A/cWG8uiOLrZuCcuEecUY28mXejrpFKKJGdpAPJip6t7yo7wIeRoPak+CnFxW%0Ahb5GzxjA6IyBki3RUYWsbjQ4wUAw0FtQA8toNL6X9IlcjL/Vsgvg3qGqwpxY%0AfTOec55+VX1J05J+aj+x1zTupjnLMP89bqBsJf/jYyDbQFbTUJ9+FOfhVVN3%0AdLFW6dMaqbMH9F6ObEIge94crBMZyLQrzZR668mMgU7GZ1J27NJE0zWcMVBa%0Ab3t1I3rjYaB1R5XgGnGFA1W+a/Pn6Dm2++BY7K/Kfz7FT1O9vOe6GSMKNDJv%0AzjyzDGvjmAbKXvLtdiD647/DDzHQ3XU3jBnoW4dZoHJA9i4P1PRgWmErjJmB%0Aoul1g7BxJz7NajRAKNVAz2G9ahpodJ/nrUOds+fjwl/RAp7XN02Zy7f7S+OS%0A1qcZaL1HJG61gVqD4j9mtZzPZj9zVPn1xMvD+DkJ/Naoezott4Xnxlu02Kry%0APMSJbyjYsvds1SP/W9EaHjUz3OHbNkeb8hh78qjFWBuHSzKQiTLQfCVfO4F1%0ASjfp7Xz2ITFQga2cJD5DMQ2OaoF+Rv9WWi36xnoHarPdOu/Sr4uVXfiHPZYL%0AKzFTHCTbgeIGemDBk9USzd8Uu6bVqNtfjgjiMdAojLrj3bsW+GrQdjXz8nhv%0AMhC2g0s1UO3JGuTBRsN7Q8fupbSec8NaFh/YMspPZHrIyoannE7LTdw05vpA%0AzbnWB4q9tZdul9niVK6cpvfSoRWmopyersRyaNTCkgZSU0kdLrG2h1+FgeYs%0A+bIZQ+zQyndPi4neSGCmXWKCx4dQrFZSkq3O4oa3Rk+rWhhbKWVYGYhamBp8%0AKL7Zbp/ol4//QG3/dZI3+sLk06fqIhcvWGNS9yzf8k0DsRc5DxuT6GtHe8yq%0AerumZVTVX7X6malQ0JQVyk6Nm1mM13CNLTFWJcy4Z2p6brLJRK+RaBy8xUBy%0AdY5mTdSs9F46UhYDOW2eFtyogbmma2GOlxUu8SuVvNtA/kF0v89nIGeP+6au%0AztG/mcjG+TMv1g4kPvDncVftqHRW4d9fR3z8YceYB09kR/pQrtIUxUCP/Wiz%0AAPZlsk8vII29/YHeAEpsTzAK9fJWemb+tRiS1Ldma3zk6hwwUCYD5fSypYnd%0ALVQwfeplNlB6bguuE+020JHYQJnl98uKvPn7oF+7v8enVku0IwbiTUSqFtYx%0Al6qnebdacsH7F2I8Qw3kV5ps/axZBkod77NdK5T9Do1orM87ufzRJPXejy95%0A8nxPq2M/75vi4qi6GZVclOnwXj5a6zYexl+/5K0qeXponr5C2U32JgAYaJUG%0AqunNA929KyfjMy+7gdJzi7bHENviRAeLGOhZfPkmdiyk37yVByqVsv0WnAYS%0AC0bE25NGxSJr0WILvk744mSy2UA8URD/HfKzft8357LP9hloy4GBVmkgPgEw%0AbS2VKBLKaKD03BbcL8xtIDlKxDIQ6XZvaSxT503Qpf+sFa9m1sK8qDOslZe1%0AMBocWRsTsieibcH4UoiJ8QAz55jCQDDQThuofa27othayBetasqyV2IYafwc%0Am+GYLTsdyl2bU3JbcM9U1fZ61TQNRMj3ijMGUjGY1RBgxkC0KsCfeY4WjuZN%0A2GZnGHXOkO9AnXl7+Cn6gYF210AEBkoYiG0cr7bO4ouwpw2sU6u9xM6xAxLS%0Azg/lNOe03BbdN94bss0H6evzE3UtrHlyzJoNEgYS84kYV3nd1mOOB+qoxZ1l%0Abz2Nj7hqh1ZL9FWlovvCMhvIZR4YaAcNhCBo+n5hamJjKWx8uQ5TVKBHbdnn%0AxNxSj8KQtNwWNZB8/ZzqZxF7ZfB5jDSrhIEStOSbb7Xy/vVV3mHRJ9GXZyhl%0A/u3hkwZKK8MwEGphaAfiN6/oPx923C6IRvZN2TOVP2P2xrtyW7AWpvaPFiGL%0AsWcq70+Ldpdm+yjTB8cXeV9vxGCKg75/KpRGM5F7mdU3h+aE64UNNK0Mw0Aw%0AEAyUEzJQK9K5F9UtzzJQzti1eUpuC7ZE29GSYSD+FqM9FtiCMt/Z0g1ltnwD%0AWxtUn9TXSz+U+O6HtoDYS9zaajIMRG6LT3O1A80qwzAQDAQDMZvoPi7n6MAo%0AtphmIP6I2jc+LbeoA74eO8hoIHseUrRv/M9K3jBQjS3eUFaNN6xrTjrF7xO1%0A/NXJqHJNSOF2oocVEtmPV47FTGXv213IY6AJm+jdMgz0yAfxzjsvDAaCgWCg%0AuIHK8jZ03Es1MttANSMGmpLbgiMSayoG4pMoTAPJupfuv6rTg7+EgSbR0Ozn%0AsPHva7SbYO9bR66HzqqMt0K0tVivOpUOYUuy81qY38qP7vUChYWnxiQHA9k4%0A90xV0fSKNkXdCAOhLyxpoLKOQOQ95A5Hcua+8U1+hxAAABzRSURBVGV3Mhk6%0ACFlNyU24S8/KMA6yoOp1Yo5I6r7xbCASW7pBxD96ryt/9PUy1rAleaSh0SfV%0AkJ0zN8f6ds37/lko9Sh2weoXxWTM0RPfRH43DTTvnql2KVn2pqia56/TNmEe%0AfW2+u4GMywsDJQ1E7zS/ync7F0utPF6ThkMGVdNA0TmJ8KTHt05u/JqWGyt8%0Al+bM1Mu5ZqbWeNvNt47sC0sxEJ+gVGUDmZmBGk2HUy0DPfL5kvwWeB5f5Qch%0Ad4t4g2LskdG5xjel58MSJiqrdzYQm//bmHYzGQncaRdOMO+eqbrevIpNUY2y%0Apdr7fPk9IbdbPJPbZkzb5dFb9TcBDBQ30P39KIyW0BDraVzkna0vuhZmn2N/%0A/7AhQLfd7sXl1NwWXJ2DDQ4kcnVD1RvPFku+u//R0t+sVTVGWk1oN5b7MQ1E%0Ay2nTau4qCK3w0Ux8tcRhcaK+p3s6FfNqqSu7y7SBat3e+xgox+eBTIkbjQTu%0AtMtIkH3PVOPslWyKaghIPn3eVRNbWdsd+16sx1J8hIHQDrR1H6QVA7HwSy0p%0A0/014gObQ3LL/o9GOJ/roc8v4ofZ5jMwFroYhIltijVRyFaKmpTYa8ws3ksx%0AkOgXqKa33hsJ3GkXTzDPnqn+dbjaTVGjF1dv0m/l9ECPstl8aNX0YCAYaEGG%0AryxM+S2X4KDRTk8299zLeaZJWlNqS8nZ2jN5bC1Wht9iIHFz1dKDICOBO+3i%0ACebZM5UNTC9HIczSN0U1KnN548AcamZ2kr5xJRgYCAbaApZioKrqQEz7NjcS%0AuNMunmC+PVOJXqxlFZuiRm+p7CUMVCqe5c2VWBeph+HGgYFgIHP6C7uVHHum%0AGgnstMtLMNeeqf2iqqutZlNUiT0Rx451jI6HzDtjwEAwEAzkOkvKQPxw7Zlq%0AJLDSLjGBaqjJsmfqSfEsGkW2ik1RrUZBp4FKRha1N65FhRsHBoKBEgZy7pn6%0AHgaaY89U1v2VUztzrWJT1JkGOjk2BoXAQDAQDLSkWtipu0PMSGAvWLC8BPPs%0AmSpcIjv2V7Ep6qxa2MnYXAQBBoKBYKBlGEg2E5dTDcQSmGmXmWCOPVP56HW9%0AYNwqNkWN3vSpy0DDsTlee9ooBhgIBoKBMpxl9I+7b6d36I3PvmdqKSzrHqjV%0AbIrqjG70GxYC8itq5+2wcAgDwUAw0AIG4vGIWlzAtWeqkcD4dakJsu+Zmos2%0ALVnVpqhREFROGEguL1yT3pljGQYYCAaCgdxn5UjhLxGapOyZGiUwf11mgsx7%0Apvp/83u/JjeGW8mmqLolqGOOXZQ71tEqYav1LEX55l1ZcOPAQDBQRDRX1Lln%0A6upnpmbeM5UNDCoc8r51+mNVm6IaUdCVHPrIOY22HOcGGnbIWd6DgWAgGGgx%0AA3082fdMtSOrFW2KqhU0Kk5r5dGLs8BAa2Iga2Y6n83ecK37lHE2+3KTwUCb%0AV/Ide6ZarG5T1I+5emBBA/FWBLU6D/1qyvsPjiVd7GTWwQqTwUAo+Wt/9cCC%0ABsrJ5kExe5i7x7VmvJnMPlhhMhgIJR8G2nIDWas0l8QiTrVk5T3jys7LTQYD%0AoeTDQNtuoGinCrHXRNNtICuZfc7qksFAKPkw0LYbyLVbV9W1tHymHb6WmwwG%0AQsmHgbbdQMkdSx/7JLmTccZdTpebLCNiOMxVEwYCMNCmGSixazsbNnaUuJkz%0A7vS+3GQZGbKdCP2HzYmgYCAYCAZKNZAYEFbeHAPJ9qO3+gsGAjDQetXCnKsP%0Ar28tTL1Zx854MNDKUWMHa93YnkxsLdU8DARmGsjVDuyYO7y+LdEbFPxsoYFy%0AclBzLVF1V1NOf/6AgcAUA0V94Uw6Pyt5b0b/eT1+zuqSZbwHNq0Lbfl7pq5o%0AS9TZCfSShDV98dTELblY9DXZsmFeMNCSDWSNB6QyqLsNtL4jEvXgpcfWThno%0AXbZEnZEgEg//RcxTlxt4Vbd0gCkMtGQDyRhCLYLHwxHXLlRmMvtghcmyIAUm%0AFgLdHQO9w5aos/dM9a9v9k/u72mo80COKiNrPiEM5CbIlqzNmJZNsNzXU+lS%0A822vzEAs4LmU80Lp7//7FG2wbRU2I5l9sMJk2YKgkJx98r51dqsv7B0WYZ29%0AZ2qN/GItQZd5oxbGt8X5ImthIxLb9nrXDRRkNEd71k2fMZ8Zr6ef1ek+wEDW%0A2hj+iA3ue3GVmvVdnWN4zd70zW6NSHyHLVFnJhiOv6uFB20DsYeqYqLh1o1z%0Af58YqD33TR+86fWCzO+r3V6ZgcAGGugdtkSdvWdqjpDbUISuzECqIQ4GWthA%0Abdf9+6EGanswEAzk3rFwVRsSZtgzlW3sfspXbn4gR3ehXvIZBkqvDwWxw0D8%0Apn5ONxBLw9PJxOax+OHpfwKHWXhyz0gXeHa6IFkvg4Hi6FV/CdnMnt7tMRAN%0AfdgDvt0LKZaNFu1AMJARYgTGnR57KLBl0Z6ZjdlyHMtX5Rc4YpsgiL1uEE8X%0AxF9Iv6M2DIQYyFFFWtmWqLP3TGXbo7Yqr/+KNZvv1J6mLPDhGzCX2ZrRMFBK%0AbScIkvf9Gwxk52vKyGmgmPGC2Elub3mibw4GgoHieljllqiz90xlmrmZ5OW+%0AFXqDi8fKJdsdgxS6h7tw9d5mIFYfUrUw8+cMA3lBTD1pBlL5L8lAbQ8xEAy0%0Afr3xYgh93ED8kaO/SfugcAgDuQ0UJOVh3fapfWEZDZRaC1vAQIsqCAbaKgO9%0Aw5aoMxMIvt134gYakMZ+lZRLYWECA6W1AwVT2oEcMYcqIY72Gi/KJGphTqmF%0AGXYK5mgHgoFgoPQ9U1e1JersBN7j3ZhcNeMxEN+ducqbgTZo4bjVGsiLdXnJ%0AXil3V5hod/GmGEj3fZmdV+plpFriCWQIFXV68ZpaVAm034ddK2TvZtGWIJeB%0AwIexsIHWYGZqjpDCBV+bSbZEcwP5fdLOy974YUcmgYHWg+ADXxsG2jIDfTyl%0A4lmyHWjYEaIS88L8h+SWhTDQxwkoCGAgsHVrJJ53/2GyGd1TH/kVESj51/xB%0AtEQDGAgGAjAQDARgIBgIBgKbemlQ8mEgGAjAQDAQrgMMBAOBDTTQjt9/MBAM%0ABD7SQATFHAaCgQAMBAMBGAgGQjEHMBCAgWAgAAPBQCjmAAYCMBAMhEsDA22n%0AgQiKOQwEAwHEQDAQeLOBwPrN6oOBYCAYCMBAMBCAgWAgGAgGgoEADAQDARgI%0ABopfZxRz3O24NACgmANcGoBiDnBpAEAxx6XBpQEo5gCXBgAUc1waAFDMAS4N%0AACjmuDQAoJgDXBqwEuRG7h+5oTuKOQyES7Nj2gn0LzAQwKUBHxT5WL+hmANc%0AGrAuBtq+EoFijksDPq7WxatZ+p9AV7sCuzamf9shA/l9+kTjMHqgRo7yM5Il%0AzllRssz4rVH3FAYC66sg7ppASkcdRzGQIaQtrZilFXP/gBw1B6Sg799S6DKQ%0AlSxxzoqSZec8JAQGAmtd6wqSP+MG2uZWobRiniOFQ/bv3r6Wg8tAVrL4OatK%0ANgcnxzAQgIE2r5jTO7cuAp+ykoPLQFayxDkrSgYDARho2w1UE7UXVhPKi+O9%0AjsNAVrL4OatKBgOBLWwHCjK1A+1MS7SoAnleVVSCTo4Lh1WHCqxksXNWlgwG%0AAlsTAwVRpxf7Tx4HQSD7x4LA7hXbGQOp+17+rNL72GUgK1nsnJUly8hwTP+y%0AlxAGAutdC9tx3MWc1n3EfS8ikRprknEYyEoWO2dlyTJSCkk7P+ygLwyscSUM%0ACspkoFLI3LNZBqLn11ELA2ALamH+nzeiJrZJtTDZkA0DAbCJxdxsB6b1Gc1p%0AerL1aomWp8NAAGxiMY/6wutRhDKtN77uPGclyTIaSHbiwUAAbF4xd4wHrG7U%0AiMQaYiAANriYixjCnBNRdc/KMJIlz1lNsixQ9ZSjsAoGAmCVZZX/t9RizsYi%0AX5rzQv2/yd7h9GSJc1aULGsQ1POeQ0Iav2AgAFYsoDcrKOPqHDSkYCTjkfVd%0AneO5Q0+/7XYvLmEgsMVkHlQULCkfo3waAnqrglDMYSCwCwaaOfzReD6W1FkM%0AjbgHBoKBAJgZ6wRvzMLdyEOS1S+y08Vc1hMF5W34i2AgsC4GSi2jMBBiILCj%0Ada9AVKwCPZ1eH6uFPtQ/gUMrOr0XzcPXz5i1MFkMeVGk//D/iKUcGAgGArsZ%0A6VhrCQXWEmfWqmeudc4Cz16jOn5ePAZS4Y5QkSigHgwEAwEYKBbiJEwSLNVA%0AhmsQA8FAYIcVZKsnzUBB4F7rNYjLZ34DoR0IBgIw0HQDpdXCFjUQeuNhIIB6%0AWIqBAmPt6ZRaWNI40XGQYiACA8FAANgGCcwuMPmQfEItfx9PYJsrtia1Oi9e%0ADInoBhMdY8QcE72aWRkABgIgY1ld/sxUAAMBgGKOSwMAijnApQEAxRyXBgAU%0Ac4BLAwCKOS4NACjmAJcGfFgZSf6GYg5wacD7FJHUAxRzgEsDYCAUcxgIwEAo%0A5gCXBsBAKOa4NAAGQjEHuDQABkIxx6UB2yOgTVUQijkuDUAMtBbF/P+BNQAG%0AAjAQgIEADAQDwUAwEICBAAwEYCAYCAYCIH77Jn/bcAPhon4cMBDYRYnCQDAQ%0AADAQgIEADIRPBAYCAAaCgWAgAAMBGAgAGAgGAgAGAjAQADBQVk7GN03203/9%0A2kw+2+9e5LPnVQqveB4511nniQf90f0neWL35tJ+2V5endXLw0AABtpaA5VC%0AUuYmOiZ7SQVVyRETQKsVWaNo0CF1bbLXCc1r77DWbfsHrqxyZG8/kXujKd9E%0A4dR+QmWQI4VDGAjAQFtroJqUSI0IE8Ud8UJF89l8rqVjEr9PClfNyDBHz+He%0A5QFpU5mdeg4DcZl558XDKHeZ7cmx7RkpPuMsGAjAQBkMVIvfMCK6kNDbrDUo%0A/jPtpfzWqMtv38ETO+HMUQeiNz4hjUPHwfy0vP7NPg9xYre6L0STU0GO3/qU%0AiJ46BbNexf/MvTsqlZoV7QxfVbxUKAqbadtwA50cNw5hIACWYSBapUkaiD54%0A86VSqTywm5N65XTaS52HIkGfNC694YEjO1rHOWoOiKi2WAdvqYK9dLtMCqc0%0AIxaPDCt59UxBaONF+8NyxCP9c2J6HLGMbv+tNIW2/MoPmbTldok2UAEGAmAZ%0ABqK3sUMZsp7jv37N8yTTbSGqMFQAhyLDcrI2w56SrSrWwVsMxE6kMUuzRgq3%0AVDTaoNIJg2JP/mVRvOOP7vPsbZa9UnFiRTqfaSZUVdS43Fn2excu8SuVvNtA%0A9G/VSoOBAHiDgXLEZaCc+H6vcfVkNJC68XJRU2/0fN1TDcjWwQIGOsqLJhma%0A3y+rZYa/DxrN/B7Ld33y+pXaqtEU3iCFC9UsRCMd+jZYdtyeZlvQuVELo16q%0AmwZqtWROL8R4hhrIrzRHxSYMBEBmA9FYouMwkLx1x2dedgOpppSkgWpEmYy+%0AknWwiIGeQ55B5A1poAdyVHmg7iibdUCqq73L48KEBS00CPvHau8q9HLsTVmt%0A0dxS8YamUbHImrpIm+Y0CAs91S4tniiI/w75Wb/vmzAQgIFmGIjdtNVUFchI%0AKKOB6L+8znJQOHRWwniH9b59sICBGh2Rj2kg0u3esu523gRd+u9QG+iUBTu9%0AYyYb0ysnncJn1hJNXkKeJP7OdUrVGdbKy1oYDY5Yat0zxp5gaZl+6V/Impei%0A3n0YCMBA0fe42WFVpTdeqoFOxt/z8g5uX6d0Xw3HRN6/vGJFazjVQi+eSMmG%0A/7QOsmG9Z2UgQr5XnDGQisFy6nFuIP/1K015ZUU2w+NGk2X33CG94lnUH/Yc%0AjR3ibdtmZxh1zvCa/qGiJboaVSVNA6EWBmAgt4FYK8wndk/WRfWo7qUbqCpv%0AYdZY3Wj6DyQR3DDptPPDjuwsY784ErHRfvsqFrIOsv0p9nvWtbDmyTEbHJgw%0AEH1Pkqu8Z8Rw7N1xOypDDP67yHvn//VYoxGzbWQO2Y1fIwXu4KHVEn1Vqei+%0AMBgIgLkMVBLhSk22v7JbJc1A4laPmmyUAmy31KMwpBQ2vvDwYMkGst4zqyvd%0AFotj9pZ4f1rCQJ7DgKfeY5+0j8kTaUwsQzC75Zlw+jf71djfR1/3SXTyGSfo%0AvrBSCAMB8KZ2oMdvD+ze9f+82ffSDRSN7JPtQMkOdNmqbPbGDztJsyxaCzPe%0As9kXJvrTpJ+Emyb0wfFF3v/5wzYQrUWKMYQ5Qs6UIZ5F/er2c0h69I/rxYZF%0As9xZaDQ8pnGeBwMBsJR2oOcxb7iht3FUXXENOYzG9aQbSMYxwkAyhJC97Y5k%0Ab26JNt6zZSD+FqP2Y/r3vHzPs1E/9P82TXKm3z8fcSDrTdHwg8dPPIea7KKz%0A35AYLpAjt2GjadlUG4jcFp9gIADmagfqsIHL1iSElBgoii2mGYg/wg2ke8xS%0AQyVRZ7MOsrUDWe/ZMJD3s5I3DEQfe2D2EW00rGuuqWMg1rnODaR0pE/JizfO%0A+uXr1p9G5MPlWDxX9r7dhTwGmlRJodcyPsbHyjUMBMAUA0ndZDBQjcw2UM2I%0AgXTMlJzKsOCIRPs9mwaSdS/dTVWnB38JA02iodn8/Q9fv6qm9OgN+v2wcdEX%0Ah1UzEKR1yVvd+tS030yB3FzKWpjfyrPB1uqJp8YEMRAAUwwUdYLNNFCOGLWw%0AsjtqkRGCkJW88VzBjXCXnpVhHGSpg9nvWc/K2FcW1A3mvJ27IeIfEg0KkAYd%0AED1o2/iDWUzEZm+YMdBjn5x9Ui3cOSMn79s1IVdNHk09VriZ+kX+6o+jJx6o%0AwUAATIuB+P30OApJ4fZf2Vf9N9k7dEYehoHoSX6VNPaTgRJ95jkkpPGLJWs0%0AvcdrRzLWm3Zpzky9nGdmqv2eUw3Ee/aqbLwyM5DReKNiuJacjWEawu+TBs25%0APjxmQY8YcfTI56dyAz2Pr/KDkLtF2oov7WH0ulXZb3y8wkTkDQMBkG4gPpGd%0ANL4cSAPIZTgc8UguqoXd39Ob1L3sxjMbAnTb7V6we1SsznGx9NU5rPeseuNZ%0AZ97d/Y+Wnt1RVWOk1bx1NZCZhmg39hpl2hCD8KXH/sA/WVWOjaiMVjdkR0Ir%0AfJgTXy1xKKe10k+tp1Mx4Za6bWU3aaBatwcDARjIcQNsOFYMxMIvGaqVur/4%0AWoifQ96/fhsNZPb7X/dttwoD+aNQLLTq94VdWWfaLy0nmrNyLp8DFtOzXkBJ%0Ax3IluTRIR8zKiNq5YCAAA23NHzZ8ZdHIb7kEB412xC/+6N5cC3FqSCXDk8dP%0A8ky9GrRvDH72/+zOu4jaY8v9OAwE5iAIYCCwVGAgAAPhwsJAYEOVBAMBGAjA%0AQDAQDAR2oBIWyLqY+C0IgpR6mSpG61mYYCAYCGxyzCP0MyUGImsrHxgIBgKb%0AbyBvuoHWvQjBQDAQgIFgIAADARgIBoKBwAYbKEhRENqBAAwElusf0fcV/ZM6%0ARhF9YQAGAmtwr2+WgeIz0/spy7tnm82+3GQwEAAZbmy7AG2WgdjqPE29VM+o%0AGLq3rLCTmQcrTAYDAbBVqnTcAGKheLVC4c/KgdtAVjL7nNUlg4EA2HIDJVZp%0ArjkNlHFl5+Umg4EA2HYDRTtVyHUC3QaykiXOWVEyGAiAbTdQYrcut4Ey7vC1%0A3GQwEADbbqDEjqVuA2Xc5XS5ybLhj/hq1GcbFEDBQDt38+EzSN+tJ7Zru9NA%0AGXd6X26ybLBmpE/z7HcIA4EPuP3wEWyrgUp6I8F9GAjAQKiFvXctjPH47QEG%0AAjDQBhpo81ui/ecxIS8hDARgoA00UNQXXvemGMhKljhnRcmytQN1+A6mqIUB%0AGGgTDbTxIxLlLvcwENgIAxEYKDErg926OWPb9ZRZGUay+DmrSpalDiZDJxgI%0AIAjaSAOxsciX0bxQv0qcsYiVLHbOypJlIUcKPe9xFJLC7b95GAhAQBtmIGtt%0ADCoDjmN+xNquznHOtopvfDnYoMn1MBAMBAPhE4GBAAwEA8FAMBAMBANtECfH%0AJGIzF/SAgXbXQOgLQwwEA4F3v/kQDMFAMBBAdQwGAjAQgIFgIBgIABgIBoKB%0AAAwEYCAAYCAYCAAYCMBAAMBAMBAAW2wg8MHAQAAGAjAQADAQDAQDARgIwEAA%0AwEAwEADbbCCASwMAijnApQEo5gCXBgAUc1waAFDMAS4NACjmuDQAoJgDXBoA%0AUMxxaQBAMQe4NACgmOPSAIBiDnBpAEAxx6UBAMUc4NIAgGKOSwMAijnApQEA%0AxRyXBqwZQZZEbcZC+QfBkvKdmt9cOaKYw0Dgw/0TZDKQ15b/Z842nn/K62TM%0Ad678PBgIBgLbFQPNdWfbuQZLMds8+cFAMBDYfgNNLyEfZKA2ijkMBDar/hXE%0ADgPxm/qZzUA0qTxL/hPoalIQq+3Z9b6UVpu35gcDwUBgc0KfwLijYw8FsXBj%0AVu0mCGLnB2bOpumS+baXlx8MBAOBDat7BeZNH7+/sxsoZq7A82IaC+bK9435%0AwUAwENhMA7F6j6qFmT+33UBgbcFduksGsiozjkBoQww0f18YgIHAerQDBbPa%0Agdqx+zet3SZ4QztQvLwtmh8MBAOBNVeQ3eUle5/SusKSfVYxA3lRX5qo0UWV%0AOTu/lHzjBnpbfjxH1MJgILC7tbq3tj0uOT8YCAYCuxZQLVFAQYAPFQAAAAAA%0AAAAAAAAAAAAAACwAOjwBAB8nIHwEAAAYCAAAAwEAAAwEAICBAAAABgIAQEAA%0AAAAFAQBgIAAAgIEAADAQAADAQACADVMQHAQAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAIDVIDdsx8btAIB3006gf4GBAAAfFPlYvwEAwLoYCJPIAADLq3Xxapb+%0AJ9DVrsCujenfYCAAwBIVxF0TSOmo4ygGMoSEihkAYPm1riD5M24gyAcAAAMB%0AAGAgAABYioGMdqAgUzsQWqIBAMuLgYKo04v9J4+DIJD9Y0Fg94rBQACApdbC%0AAADgYyphUBAAAAAAAAAAAAAAAAAAAAAA6w3h/wEAwMcICAoCYDfJPKgoWFI+%0AMfPEfwAAYCBHsuwGiiVNmwpCYCAAQNZYJ3hjFqmNPNJAJBYSAQBgoKUaKKUO%0ABgMBsLN1r0BUrAI9nV4fq4U+1D+BQys6vRfNw9fPmLUwwpDxDv2H/0es0AgG%0AAmA3Ix1rLaHAWuLMWvXMtc5Z4NlrVMfPi8dA2jpEHsBAAMBAnrWKmec0SbBU%0AAxk/YSAAdlhBtnrSDBQE7rVeg7h85jQQkfUzGAgAGCjVQGm1sEUNlPoDALAz%0A9bAUAwXG2tMptbCkcaLjIMVABAYCANgGCcwuMPmQfEItfx9PYJsrtia1Ok/5%0Ah6i+L9ENJjrGiPkMZmUAAD4SzEwFAAAAAAAAAAAAAAAAAAAAAACwPURrh2FD%0AeQDAewso9QAAAGAgAAAMBAAAMBAAAAYCAAAYCACwPQKCggAAiIEAADAQAADA%0AQAAAGAgAAGAgAMB2KQgzUwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAANpAgwGcAANgAAxGCjwsAsGIlTVEQPh0AAAwEANiWSlgg62LityAI%0A3PUywoCGAACriHmEftJjIMgHALBCA3kwEAAABgIAwEAwEADggwwUuA2E8UAA%0AgCX7R/R9Rf+kjVFkPWFcQdAQAODjgIEAAO+lGwkMBAAAAAAAAAAAAAAAAAAA%0AAD4CDBQEAHyog/ARAABgIAAADAQAADAQAAAGAgCA9zEQVAQAQBAEAICAAAAA%0ABgIAwEAAAAADAQC21UBQEQDgvf1DEAwBAFAdAwAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8N/8HwJm9+cfX8awAAAAA%0ASUVORK5CYII=" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据流中的中位数</title>
      <link href="/2019/03/12/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/03/12/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; p;</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><br><span class="line"> </span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p.empty() || num &lt;= p.top())</span><br><span class="line">            p.push(num);</span><br><span class="line">        else</span><br><span class="line">            q.push(num);</span><br><span class="line">        if(p.size() == q.size()+2)&#123;</span><br><span class="line">            q.push(p.top());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if(p.size() +1 == q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            p.push(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        return p.size() == q.size()?(p.top()+q.top())/2.0:p.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求最小步变成斐波拉契数</title>
      <link href="/2019/03/11/%E6%B1%82%E6%9C%80%E5%B0%8F%E6%AD%A5%E5%8F%98%E6%88%90%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0/"/>
      <url>/2019/03/11/%E6%B1%82%E6%9C%80%E5%B0%8F%E6%AD%A5%E5%8F%98%E6%88%90%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Fibonacci数列是这样定义的：</p><pre><code>F[0] = 0F[1] = 1for each i ≥ 2: F[i] = F[i-1] + F[i-2]   </code></pre><p>因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, …，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。   </p><p>输入描述:   </p><pre><code>输入为一个正整数N(1 ≤ N ≤ 1,000,000)   </code></pre><p>输出描述:</p><pre><code>输出一个最小的步数变为Fibonacci数&quot;</code></pre><p>示例1<br>输入</p><pre><code>15</code></pre><p>输出</p><pre><code>2</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>思路：这个题非常容易理解，在求斐波拉契数的过程中找到整数N的左右即可，然后算出最小步数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">1</span>, c=<span class="number">1</span>,leftstep = <span class="number">0</span>,rightstep = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">c = a + b;</span><br><span class="line"><span class="keyword">if</span> (c&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">leftstep = n - c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">rightstep = c - n;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(leftstep,rightstep) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>删除公共字符串</title>
      <link href="/2019/03/11/%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/03/11/%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入<code>They are students.</code>和<code>aeiou</code>，则删除之后的第一个字符串变成<code>Thy r stdnts.</code>   </p><p>输入描述:   </p><pre><code>每个测试输入包含2个字符串</code></pre><p>输出描述:   </p><pre><code>输出删除后的字符串</code></pre><p>示例1<br>输入</p><pre><code>They are students. aeiou</code></pre><p>输出</p><pre><code>Thy r stdnts.</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>思路：这个思路真的非常不容易想到，我们利用一维数组制作一个哈希映射，利用字符串2中字符映射一个值，然后<br>遍历字符串1中的字符与字符串2中的字符值进行比对，如果字符串1中的字符映射结果为0，那说明该字符不存在于字符串2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line">getline(<span class="built_in">cin</span>, str1);</span><br><span class="line">getline(<span class="built_in">cin</span>, str2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hashtable[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">hashtable[str2[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ret;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashtable[str1[i]] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret += str1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连续最大和</title>
      <link href="/2019/03/11/%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2019/03/11/%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个数组有 N 个元素，求连续子数组的最大和。 例如：[-1,2,1]，和最大的连续子数组为[2,1]，其和为 3   </p><p>输入描述:   </p><pre><code>输入为两行。第一行一个整数n(1 &lt;= n &lt;= 100000)，表示一共有n个元素第二行为n个数，即每个元素,每个整数都在32位int范围内。以空格分隔。</code></pre><p>输出描述:   </p><pre><code>所有连续子数组中和最大的值。   </code></pre><p>示例1<br>输入</p><pre><code>3 -1 2 1</code></pre><p>输出</p><pre><code>3</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">&#125;</span><br><span class="line">result = vec[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += vec[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; result)</span><br><span class="line">&#123;</span><br><span class="line">result = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组队竞赛</title>
      <link href="/2019/03/10/%E7%BB%84%E9%98%9F%E7%AB%9E%E8%B5%9B/"/>
      <url>/2019/03/10/%E7%BB%84%E9%98%9F%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛牛举办了一次编程比赛,参加比赛的有3*n个选手,每个选手都有一个水平值a_i.现在要将这些选手进行组队,一共组成n个队伍,即每个队伍3人.牛牛发现队伍的水平值等于该队伍队员中第二高水平值。<br>例如:<br>一个队伍三个队员的水平值分别是3,3,3.那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是3,2,3.那么队伍的水平值是3<br>一个队伍三个队员的水平值分别是1,5,2.那么队伍的水平值是2<br>为了让比赛更有看点,牛牛想安排队伍使所有队伍的水平值总和最大。<br>如样例所示:<br>如果牛牛把6个队员划分到两个队伍<br>如果方案为:<br>team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.<br>而如果方案为:<br>team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.<br>没有比总和为10更大的方案,所以输出10.</p><p>输入描述:   </p><pre><code>输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值.</code></pre><p>输出描述:   </p><pre><code>输出一个整数表示所有队伍的水平值总和最大值.</code></pre><p>示例1   </p><p>输入</p><pre><code>25 2 8 5 1 5</code></pre><p>输出   </p><pre><code>10</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*本题的主要思路是贪心算法，保证每组的第二个值取到最大就</span></span><br><span class="line"><span class="comment">* 排序，然后取 第 3n - 1 3n - 3 3n - 5...个元素累加即可</span></span><br><span class="line"><span class="comment">* 例如 现在排序后 有 1 2 5 5 8 9 ，那么取 8 和 5相加等于 13</span></span><br><span class="line"><span class="comment">* 我们每次尽量取最大，但是最大的数不可能是中位数，所以退而求其次，取 每组中第二大的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">3</span> * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">3</span> * n); i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">3</span> * n - <span class="number">2</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏替换？内联函数</title>
      <link href="/2019/03/02/%E5%AE%8F%E6%9B%BF%E6%8D%A2%EF%BC%9F%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/02/%E5%AE%8F%E6%9B%BF%E6%8D%A2%EF%BC%9F%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在上一篇中提到了宏定义常量，说到宏这个概念，我们就来谈谈C++中关于宏的真正概念。</p><h3 id="用内联函数取代宏"><a href="#用内联函数取代宏" class="headerlink" title="用内联函数取代宏"></a>用内联函数取代宏</h3><p>在C++ 语言中支持函数内联，目的是为了提高函数的执行效率。在C语言中使用宏代码的方式提高执行效率。宏本身不是函数，但使用起来像是函数。在编译预处理阶段拷贝宏代码的方式取代函数调用，省去了参数压栈，生成汇编语言的CALL调用，返回参数等等。但是使用==宏的最大缺点就是容易出错==。<br>因此在C++中采用了一种内联函数来取代宏。==内联函数的优点是可以调试==</p><h3 id="如何使用内联函数替代宏？"><a href="#如何使用内联函数替代宏？" class="headerlink" title="如何使用内联函数替代宏？"></a>如何使用内联函数替代宏？</h3><p>使用inline关键字。<br>如下代码函数Fun不能成为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下代码Fun能成为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>总结：关键字inline必须与函数定义放在一起才能是函数真正内联，仅把inline放在函数声明的前面不起任何作用。一句话：内联是用于实现的不是用于定义的！！！</strong></p><p>tip：当然，在一些集成开发环境，如vs2017使用该关键字时，如果没有预期的效果，检查vs2017是否开启内联函数的支持。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const在C语言和C++中的区别</title>
      <link href="/2019/03/02/const%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/03/02/const%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="const在C语言和C-中的对比一"><a href="#const在C语言和C-中的对比一" class="headerlink" title="const在C语言和C++中的对比一"></a>const在C语言和C++中的对比一</h4><ul><li>C语言中const是定义了一个const变量，该变量只具备读的功能，不具备写的功能。</li><li>C++中const是定义了一个常量。</li></ul><pre><code>const int a = 5;int array[a]; //在C语言中编译错误，因为a是一个变量   int array[a];//在C++中正确，因为a是一个常量</code></pre><h4 id="const在C语言和C-中的对比二"><a href="#const在C语言和C-中的对比二" class="headerlink" title="const在C语言和C++中的对比二"></a>const在C语言和C++中的对比二</h4><ul><li>C语言中不能定义const函数，而C++中可以定义const函数   </li><li>C++中的const成员函数：不能修改类的成员变量的值。</li></ul><p>下面这段代码在C语言中和C++中表现出不同结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>:</span><br><span class="line">    p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>环境</th><th>C语言中</th><th>C++中</th></tr></thead><tbody><tr><td>结果</td><td>20</td><td>10</td></tr></tbody></table><p><strong>总结：const在C语言中修饰的变量的值是可以被修改的，而C++中不能被修改</strong></p><p>指针常量和常量指针：</p><ul><li><p>指向指针的常量：当const在* 前面就是指向常量的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种方式是一样的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> b;</span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p=<span class="string">"123456"</span>;</span><br><span class="line">p1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//表示指针p所指向的空间不能被修改,但是可以指向其它常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* p=<span class="string">"123456"</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//这种写法错误，表示p指向地址的值不能被修改</span></span><br></pre></td></tr></table></figure></li><li><p>常量指针：当const在* 后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> p = <span class="string">"123456"</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">"a"</span>;<span class="comment">//正确，可以修改指向内存的值</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">"abc"</span>; <span class="comment">//错误，不能修改p指向的内存</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> e;<span class="comment">//e不能被修改，指向的空间也不能被修改</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const与define的比较</title>
      <link href="/2019/03/02/const%E4%B8%8Edefine%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2019/03/02/const%E4%B8%8Edefine%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="const与define"><a href="#const与define" class="headerlink" title="const与define"></a>const与define</h3><p>在C++中定义一个常量用const修饰，也可以用#define来定义，但是前者比后者更具有优点：</p><ul><li>const所修饰的常量可以具有类型，而宏常量没有数据类型。编译器可以对前者进行静态类型安全检查；而对后者只进行字符替换，没有类型安全检查，并且在字符替换的时候可能产生意料不到的错误。</li><li>集成开发环境可以对const常量进行调试，而不能对宏常量进行调试。</li></ul><p><strong>建议在C++程序中尽量使用const来定义符号常量，包括字符串常量。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 yum安装Mariadb教程</title>
      <link href="/2019/03/01/Centos7yum%E5%AE%89%E8%A3%85Mariadb%E6%95%99%E7%A8%8B/"/>
      <url>/2019/03/01/Centos7yum%E5%AE%89%E8%A3%85Mariadb%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><strong>以下操作都是在root用户权限下进行操作</strong><br><strong>以下操作都是在root用户权限下进行操作</strong><br><strong>以下操作都是在root用户权限下进行操作</strong></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装mariadb服务</p><pre><code># yum install -y mariadb-server</code></pre><p>安装mariadb命令行客服端</p><pre><code># yum install -y mariadb</code></pre><p>安装mariadb C library</p><pre><code># yum install -y mariadb-libs</code></pre><p>安装mariadb开发包</p><pre><code># yum install -y mariadb-devel</code></pre><h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>更改 <code>/etc/my.cnf.d/client.cnf</code>文件</p><p>[client]下加一行配置<code>default-character-set=utf8</code></p><p>最终内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># These two groups are read by the client library</span><br><span class="line"># Use it for options that affect all clients, but not the server</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line"># This group is not read by mysql client library,</span><br><span class="line"># If you use the same .cnf file for MySQL and MariaDB,</span><br><span class="line"># use it for MariaDB-only client options</span><br><span class="line">[client-mariadb]</span><br></pre></td></tr></table></figure><p>更改  <code>/etc/my.cnf.d/mysql-client.cnf</code>文件<br>最终内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># These groups are read by MariaDB command-line tools</span><br><span class="line"># Use it for options that affect only one utility</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line">[mysql_upgrade]</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line"></span><br><span class="line">[mysqlbinlog]</span><br><span class="line"></span><br><span class="line">[mysqlcheck]</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"></span><br><span class="line">[mysqlimport]</span><br><span class="line"></span><br><span class="line">[mysqlshow]</span><br><span class="line"></span><br><span class="line">[mysqlslap]</span><br></pre></td></tr></table></figure><p>更改 <code>/etc/my.cnf.d/server.cnf</code></p><p>[mysqld]下加配置<br>collation-server = utf8_general_ci<br>init-connect=’SET NAMES utf8’</p><p>character-set-server = utf8</p><p>sql-mode = TRADITIONAL   </p><p>最终内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># These groups are read by MariaDB server.</span><br><span class="line"># Use it for options that only the server (but not clients) should see</span><br><span class="line">#</span><br><span class="line"># See the examples of server my.cnf files in /usr/share/mysql/</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># this is read by the standalone daemon and embedded servers</span><br><span class="line">[server]</span><br><span class="line"></span><br><span class="line"># this is only for the mysqld standalone daemon</span><br><span class="line">[mysqld]</span><br><span class="line">collation-server = utf8_general_ci</span><br><span class="line">init-connect = &apos;SET NAMES utf8&apos;</span><br><span class="line">character-set-server = utf8</span><br><span class="line"></span><br><span class="line">sql-mode = TRADITIONAL</span><br><span class="line"></span><br><span class="line"># this is only for embedded server</span><br><span class="line">[embedded]</span><br><span class="line"></span><br><span class="line"># This group is only read by MariaDB-5.5 servers.</span><br><span class="line"># If you use the same .cnf file for MariaDB of different versions,</span><br><span class="line"># use this group for options that older servers don&apos;t understand</span><br><span class="line">[mysqld-5.5]</span><br><span class="line"></span><br><span class="line"># These two groups are only read by MariaDB servers, not by MySQL.</span><br><span class="line"># If you use the same .cnf file for MySQL and MariaDB,</span><br><span class="line"># you can put MariaDB-only options here</span><br><span class="line">[mariadb]</span><br><span class="line"></span><br><span class="line">[mariadb-5.5]</span><br></pre></td></tr></table></figure></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动服务</p><pre><code># systemctl start mariadb</code></pre><p>设置服务开启自启动</p><pre><code># systemctl enable mariadb</code></pre><p>查看服务状态</p><pre><code># systemctl status mariadb</code></pre><p>成功的话输出为Active状态为 active(running)</p><pre><code>● mariadb.service - MariaDB database server   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; enabled; vendor preset: disabled)   Active: active (running) since 五 2018-11-09 12:49:23 CST; 19min ago Main PID: 1510 (mysqld_safe)   CGroup: /system.slice/mariadb.service           ├─1510 /bin/sh /usr/bin/mysqld_safe --basedir=/usr           └─2030 /usr/libexec/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --log-...11月 09 12:49:15 peixinchen.host systemd[1]: Starting MariaDB database server...11月 09 12:49:17 peixinchen.host mariadb-prepare-db-dir[1062]: Database MariaDB is probably initialized in /var/lib/m...ne.11月 09 12:49:19 peixinchen.host mysqld_safe[1510]: 181109 12:49:19 mysqld_safe Logging to &apos;/var/log/mariadb/mariadb.log&apos;.11月 09 12:49:19 peixinchen.host mysqld_safe[1510]: 181109 12:49:19 mysqld_safe Starting mysqld daemon with databas...mysql11月 09 12:49:23 peixinchen.host systemd[1]: Started MariaDB database server.Hint: Some lines were ellipsized, use -l to show in full.</code></pre><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>使用命令行客户端尝试连接</p><pre><code># mysql -uroot</code></pre><p>成功的会输出<br>    Welcome to the MariaDB monitor.  Commands end with ; or \g.<br>    Your MariaDB connection id is 2<br>    Server version: 5.5.60-MariaDB MariaDB Server</p><pre><code>Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt;</code></pre><p>查看mariadb版本号</p><pre><code>MariaDB [(none)]&gt; select version();+----------------+| version()      |+----------------+| 5.5.60-MariaDB |+----------------+1 row in set (0.01 sec)</code></pre><p>查看字符集配置</p><pre><code>MariaDB [(none)]&gt; show variables like &apos;%char%&apos;;+--------------------------+----------------------------+| Variable_name            | Value                      |+--------------------------+----------------------------+| character_set_client     | utf8                       || character_set_connection | utf8                       || character_set_database   | utf8                       || character_set_filesystem | binary                     || character_set_results    | utf8                       || character_set_server     | utf8                       || character_set_system     | utf8                       || character_sets_dir       | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)</code></pre><p>目前我们的 mariadb 用户是没有密码的，是非常不安全的，需要执行以下步骤   </p><pre><code># mysql_secure_installation</code></pre><p>选择 Y/N 的时候都选 Y，</p><p>在</p><p>New password:</p><p>Re-enter new password:</p><p>时设置你自己的 root 密码</p><p>使用命令行客户端尝试连接（带密码）</p><pre><code># mysql -uroot -p</code></pre><p>随后输入你刚才设置的密码，成功的会输出为</p><pre><code>Welcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 2Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.MariaDB [(none)]&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mariadb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的后序遍历序列</title>
      <link href="/2019/02/27/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/02/27/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifyBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seq.empty() || begin &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root = seq[end];</span><br><span class="line">        <span class="comment">//在二叉搜索树中左子树的结点小于根结点</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;end;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root &lt; seq[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;end;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root &gt; seq[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;begin)&#123;</span><br><span class="line">            left = VerifyBST(seq,begin,i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;end<span class="number">-1</span>)&#123;</span><br><span class="line">            right = VerifyBST(seq,i,end<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VerifyBST(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23.合并k个排序链表</title>
      <link href="/2019/02/25/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/25/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><pre><code>输入:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们采用二分法与迭代法来解决该问题，每次讲两个链表合并成一个链表后，将得到的新链表继续进行与下一个链表进行合并，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* l1,ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">while</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = (len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;++i)&#123;            </span><br><span class="line">                lists[i] = mergeTwoList(lists[i],lists[i+n]);</span><br><span class="line">            &#125;</span><br><span class="line">            len = n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.合并两个有序链表</title>
      <link href="/2019/02/25/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/25/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = newNode;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1= l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1?l1:l2;</span><br><span class="line">        <span class="keyword">return</span> newNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.删除链表的倒数第N个节点</title>
      <link href="/2019/02/24/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2019/02/24/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：用两个指针，第一个指针先走n步，第二个指针再开始和第一个指针一起走，当第一个指针走到末尾的时候，第二个指针刚好走到要删除的节点的前一个节点，此时只需要改变它所指向的节点位置就可以了，以下是完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            fast =fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加</title>
      <link href="/2019/02/24/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/02/24/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。   </p><p>示例：</p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方法：初等数学<br>思路</p><p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。</p><p><img src="https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg" alt=""></p><p>图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。</p><p>伪代码如下：</p><ul><li style="list-style: none"><input type="checkbox"> 将当前结点初始化为返回列表的哑结点。</li><li style="list-style: none"><input type="checkbox"> 将进位 carrycarry 初始化为 00。</li><li style="list-style: none"><input type="checkbox"> 将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。</li><li style="list-style: none"><input type="checkbox"> 遍历列表 l1l1 和 l2l2 直至到达它们的尾端。</li><li>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。</li><li>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。</li><li>设定 sum = x + y + carrysum=x+y+carry。</li><li>更新进位的值，carry = sum / 10carry=sum/10。</li><li>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</li><li>同时，将 pp 和 qq 前进到下一个结点。</li><li style="list-style: none"><input type="checkbox"> 检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。</li><li style="list-style: none"><input type="checkbox"> 返回哑结点的下一个结点。</li></ul><p>以下是具体的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* root = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* node = root;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 ? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 ? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = n1+n2+carry;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);            </span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1= l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2= l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) node-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表中重复的结点</title>
      <link href="/2019/02/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
      <url>/2019/02/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead || !pHead-&gt;next) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        start-&gt;next = pHead;</span><br><span class="line">        ListNode* pre = start;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* cur = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != pre-&gt;next) </span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>115.最小min栈</title>
      <link href="/2019/02/20/115%E6%9C%80%E5%B0%8Fmin%E6%A0%88/"/>
      <url>/2019/02/20/115%E6%9C%80%E5%B0%8Fmin%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><pre><code>push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><p>示例:</p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || x&lt;=s2.top())</span><br><span class="line">            s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top())</span><br><span class="line">            s2.pop();</span><br><span class="line">            s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2019/02/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/02/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) <span class="built_in">set</span>.insert(num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num:numbers)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>.count(num))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[num]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[num] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>[num]&gt;(numbers.size() / <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小的K个数</title>
      <link href="/2019/02/20/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/02/20/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>利用优先级队列很好的解决该问题，知道优先级队列的伙伴理解起来就非常简单啦。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.size()) <span class="keyword">return</span> vec;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num :input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>.push(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(<span class="built_in">queue</span>.top());</span><br><span class="line"><span class="built_in">queue</span>.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>包含min函数的栈</title>
      <link href="/2019/02/20/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/02/20/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || x &lt;= s2.top())</span><br><span class="line">        &#123;</span><br><span class="line">            s2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top())</span><br><span class="line">            s2.pop();</span><br><span class="line">            s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>101.对称二叉树</title>
      <link href="/2019/02/18/101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/02/18/101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><pre><code>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。    1   / \  2   2 / \ / \3  4 4  3   但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:    1   / \  2   2   \   \   3    3</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。<br><img src="https://leetcode-cn.com/media/original_images/101_Symmetric.png" alt=""><br>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><p>1.它们的两个根结点具有相同的值。<br>2.每个树的右子树都与另一个树的左子树镜像对称。</p><p><img src="https://leetcode-cn.com/media/original_images/101_Symmetric_Mirror.png" alt=""><br>就像人站在镜子前审视自己那样。镜中的反射与现实中的人具有相同的头部，但反射的右臂对应于人的左臂，反之亦然。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode *p1,TreeNode *p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1 &amp;&amp; !p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || !p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val == p2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isMirror(p1-&gt;left,p2-&gt;right)&amp;&amp;isMirror(p1-&gt;right,p2-&gt;left); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 <code>root</code> 以及 <code>root</code>。该算法的工作原理类似于 <code>BFS</code>，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode *&gt; p1,p2;</span><br><span class="line">            p1.push(root-&gt;left);</span><br><span class="line">            p2.push(root-&gt;right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!p1.empty() &amp;&amp; !p2.empty())&#123;</span><br><span class="line">                TreeNode* node1 = p1.front();</span><br><span class="line">                TreeNode* node2 = p2.front();</span><br><span class="line">                p1.pop();</span><br><span class="line">                p2.pop();</span><br><span class="line">                <span class="keyword">if</span>((node1 &amp;&amp; !node2)|| (!node1 &amp;&amp; node2)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(node1)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node1-&gt;val != node2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    p1.push(node1-&gt;left);</span><br><span class="line">                    p1.push(node1-&gt;right);</span><br><span class="line">                    p2.push(node2-&gt;right);</span><br><span class="line">                    p2.push(node2-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>752.打开转盘数</title>
      <link href="/2019/02/15/752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E6%95%B0/"/>
      <url>/2019/02/15/752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><blockquote><p>输入：deadends =    [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p></blockquote><p>示例 2:</p><blockquote><p>输入: deadends = [“8888”], target = “0009”<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 “0000” -&gt; “0009”。</p></blockquote><p>示例 3:</p><blockquote><p>输入: deadends =    [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。</p></blockquote><p>示例 4:</p><blockquote><p>输入: deadends = [“0000”], target = “8888”<br>输出：-1</p></blockquote><p>提示：</p><p>1.死亡列表 deadends 的长度范围为 [1, 500]。<br>2.目标数字 target 不会在 deadends 之中。<br>3.每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deadlock(deadends.begin(),deadends.end());</span><br><span class="line">        <span class="keyword">if</span>(deadlock.count(<span class="string">"0000"</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;&#123;<span class="string">"0000"</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;<span class="string">"0000"</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=q.size();k&gt;<span class="number">0</span>;--k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.front();q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();++i)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==<span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">string</span> str = t;</span><br><span class="line">                        str[i] = ((t[i]-<span class="string">'0'</span>)+<span class="number">10</span>+j)%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">if</span>(str == target) <span class="keyword">return</span> res;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.count(str)&amp;&amp;!deadlock.count(str)) </span><br><span class="line">                            q.push(str);</span><br><span class="line">                        visited.insert(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>279.完全平方数</title>
      <link href="/2019/02/14/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/2019/02/14/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><blockquote><p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p></blockquote><p>示例 2:</p><blockquote><p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.   </p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>是考察四平方和定理，to be honest, 这是我第一次听说这个定理，天啦撸，我的数学是语文老师教的么?! 闲话不多扯，回来做题。先来看第一种很高效的方法，根据四平方和定理，任意一个正整数均可表示为4个整数的平方和，其实是可以表示为4个以内的平方数之和，那么就是说返回结果只有1,2,3或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的栗子。还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这里就不证明了，因为我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0. (注：由于输入的n是正整数，所以不存在两个平方数均为0的情况)。注意下面的!!a + !!b这个表达式，可能很多人不太理解这个的意思，其实很简单，感叹号!表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号!!的作用就是看a和b是否为正整数，都为正整数的话返回2，只有一个是正整数的话返回1，参见代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">4</span>==<span class="number">0</span>) n /=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">8</span>  ==<span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i*i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">sqrt</span>(n-i*i);</span><br><span class="line">            <span class="keyword">if</span>(i*i + j*j == n)</span><br><span class="line">                <span class="keyword">return</span> !!i+!!j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划思路二"><a href="#动态规划思路二" class="headerlink" title="动态规划思路二"></a>动态规划思路二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i+j*j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+j*j] = min(dp[i+j*j],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><p>这样写的好处是简洁，但是效率不敢恭维。我们的目的是遍历所有比n小的完全平方数，然后对n与完全平方数的差值递归调用函数，目的是不断的更新最终结果，直到找到最小的那个，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n, num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(num*num &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a =n/(num*num),b = n%(num*num);</span><br><span class="line">            res = min(res,a+numSquares(b));</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>199.二叉树的右视图</title>
      <link href="/2019/02/13/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/02/13/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：与之前二叉树的层次遍历类似的，该问题需要用到队列,   </p><ul><li>建立一个queue</li><li>遍历每层的节点时，把下一层的节点都存入到queue中</li><li>每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.有效的括号</title>
      <link href="/2019/02/13/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2019/02/13/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。   </p><p>注意空字符串可被认为是有效字符串。 </p><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(]”<br> 输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: “([)]”<br>输出: false</p></blockquote><p>示例 5:</p><blockquote><p>输入: “{[]}”<br>输出: true</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; parentheses;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>||s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span>)</span><br><span class="line">                parentheses.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(parentheses.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>&amp;&amp; parentheses.top() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>&amp;&amp; parentheses.top() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>&amp;&amp; parentheses.top() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                parentheses.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parentheses.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易2019实习模拟练习题</title>
      <link href="/2019/02/13/%E7%BD%91%E6%98%932019%E5%AE%9E%E4%B9%A0%E6%A8%A1%E6%8B%9F%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/02/13/%E7%BD%91%E6%98%932019%E5%AE%9E%E4%B9%A0%E6%A8%A1%E6%8B%9F%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="牛牛找工作"><a href="#牛牛找工作" class="headerlink" title="牛牛找工作"></a>牛牛找工作</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。</p><p>输入描述</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。<br>接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。<br>接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。<br>保证不存在两项工作的报酬相同。</p></blockquote><p>输出描述:   </p><blockquote><p>  对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。</p></blockquote><p>输入例子1:</p><blockquote><p>3 3<br>1 100<br>10 1000<br>1000000000 1001<br>9 10 1000000000   </p></blockquote><p>输出例子1:   </p><blockquote><p>   100<br>    1000<br>    1001</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">work</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> di;</span><br><span class="line">    <span class="keyword">int</span> pi;</span><br><span class="line">    work()</span><br><span class="line">    &#123;</span><br><span class="line">        di = <span class="number">0</span>;</span><br><span class="line">        pi = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ai;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    student()</span><br><span class="line">    &#123;</span><br><span class="line">        ai = <span class="number">0</span>;</span><br><span class="line">        id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortByPi</span><span class="params">(<span class="keyword">const</span> work &amp;w1, <span class="keyword">const</span> work &amp;w2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w1.di == w2.di)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w1.pi &gt; w2.pi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w1.di &lt; w2.di;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortByAi</span><span class="params">(<span class="keyword">const</span> student &amp;stu1, <span class="keyword">const</span> student &amp;stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stu1.ai &lt; stu2.ai;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;work&gt; vec_work(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; vec_student(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vec_work[i].di &gt;&gt; vec_work[i].pi;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec_work.begin(), vec_work.end(), sortByPi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vec_student[j].ai;</span><br><span class="line">        vec_student[j].id = j;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec_student.begin(), vec_student.end(), sortByAi);</span><br><span class="line">    <span class="keyword">int</span> worknum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_pi[<span class="number">101000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (worknum &lt; n &amp;&amp; vec_student[i].ai &gt;= vec_work[worknum].di)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(vec_work[worknum].pi, ans);</span><br><span class="line">            worknum++;</span><br><span class="line">        &#125;</span><br><span class="line">        max_pi[vec_student[i].id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_pi[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="被3整除"><a href="#被3整除" class="headerlink" title="被3整除"></a>被3整除</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。</p><p>并且小Q对于能否被3整除这个性质很感兴趣。</p><p>小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。</p><p>输入描述:</p><blockquote><p>输入包括两个整数l和r(1 &lt;= l &lt;= r &lt;= 1e9), 表示要求解的区间两端。</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数, 表示区间内能被3整除的数字个数。</p></blockquote><p>输入例子1:</p><blockquote><p>2 5</p></blockquote><p>输出例子1:</p><blockquote><p>3</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span>!=<span class="number">1</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安置路灯"><a href="#安置路灯" class="headerlink" title="安置路灯"></a>安置路灯</h3><h4 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h4><p>小Q正在给一条长度为n的道路设计路灯安置方案。</p><p>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。</p><p>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。</p><p>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p><p>输入描述:</p><blockquote><p>输入的第一行包含一个正整数t(1 &lt;= t &lt;= 1000), 表示测试用例数<br>接下来每两行一个测试数据, 第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。<br>第二行一个字符串s表示道路的构造,只包含’.’和’X’。</p></blockquote><p>输出描述:</p><blockquote><p>对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯。  </p></blockquote><p>输入例子1:</p><blockquote><p>2<br>3<br>.X.<br>11<br>…XX….XX   </p></blockquote><p>输出例子1:</p><blockquote><p>1<br> 3</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++num;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷路的牛牛"><a href="#迷路的牛牛" class="headerlink" title="迷路的牛牛"></a>迷路的牛牛</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。 </p><p>输入描述:</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含一个正整数，表示转方向的次数N(N&lt;=1000)。<br>接下来的一行包含一个长度为N的字符串，由L和R组成，L表示向左转，R表示向右转。   </p></blockquote><p>输出描述:</p><blockquote><p>输出牛牛最后面向的方向，N表示北，S表示南，E表示东，W表示西。</p></blockquote><p>输入例子1:</p><blockquote><p>3<br>LRR   </p></blockquote><p>输出例子1:</p><blockquote><p>E</p></blockquote><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> status = <span class="string">'N'</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">string</span> s=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = s[i];</span><br><span class="line">        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'N'</span>) &#123;status = <span class="string">'W'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'W'</span>) &#123;status = <span class="string">'S'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'S'</span>) &#123;status = <span class="string">'E'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'E'</span>) &#123;status = <span class="string">'N'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'N'</span>) &#123;status = <span class="string">'E'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'E'</span>) &#123;status = <span class="string">'S'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'S'</span>) &#123;status = <span class="string">'W'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="string">'W'</span>) &#123;status = <span class="string">'N'</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数对"><a href="#数对" class="headerlink" title="数对"></a>数对</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。</p><p>但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。<br>牛牛希望你能帮他计算一共有多少个可能的数对。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n*n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=k+<span class="number">1</span>;y&lt;=n;++y)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=n/y*(y-k);</span><br><span class="line">        <span class="keyword">if</span>(n%y&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=n%y-k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。</p><p>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。</p><p>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// square overlap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> left, right, up, down;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Square &amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> down &lt; x.down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leftto</span><span class="params">(Square a, Square b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.left &lt; b.left;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eraselower</span><span class="params">(<span class="built_in">vector</span>&lt;Square&gt; &amp;a, <span class="keyword">int</span> ybound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deln = <span class="number">0</span>, i = <span class="number">0</span>, n = a.size();</span><br><span class="line">    <span class="keyword">while</span>(i + deln &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].up&lt;=ybound)</span><br><span class="line">            swap(a[i], a[n-(++deln)]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    a.erase(a.end()-deln, a.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Square&gt; sqs(n), row;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].down;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqs[i].up;</span><br><span class="line">    sort(sqs.begin(), sqs.end());</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="number">0</span>, curdown = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sn&lt;n)</span><br><span class="line">   &#123;</span><br><span class="line">        curdown = sqs[sn].down;</span><br><span class="line">        <span class="keyword">while</span>(sn&lt;n &amp;&amp; sqs[sn].down == curdown)</span><br><span class="line">            row.push_back(sqs[sn++]);</span><br><span class="line">        eraselower(row, curdown);</span><br><span class="line">        sort(row.begin(), row.end(), leftto);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rights;</span><br><span class="line">        <span class="keyword">for</span>(Square x:row)</span><br><span class="line">        &#123;</span><br><span class="line">            rights.erase(rights.begin(), upper_bound(rights.begin(), rights.end(), x.left));</span><br><span class="line">            rights.insert(upper_bound(rights.begin(), rights.end(), x.right), x.right);</span><br><span class="line">            <span class="keyword">if</span>(res &lt; rights.size()) res = rights.size();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛牛的闹钟"><a href="#牛牛的闹钟" class="headerlink" title="牛牛的闹钟"></a>牛牛的闹钟</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床    </p><p>输入描述:</p><blockquote><p>每个输入包含一个测试用例。<br>每个测试用例的第一行包含一个正整数，表示闹钟的数量N(N&lt;=100)。<br>接下来的N行每行包含两个整数，表示这个闹钟响起的时间为Hi(0&lt;=A&lt;24)时Mi(0&lt;=B&lt;60)分。<br>接下来的一行包含一个整数，表示从起床算起他需要X(0&lt;=X&lt;=100)分钟到达教室。<br>接下来的一行包含两个整数，表示上课时间为A(0&lt;=A&lt;24)时B(0&lt;=B&lt;60)分。<br>数据保证至少有一个闹钟可以让牛牛及时到达教室。</p></blockquote><p>输出描述:</p><blockquote><p>输出两个整数表示牛牛最晚起床时间。</p></blockquote><p>输入例子1:</p><blockquote><p>3<br>5 0<br>6 0<br>7 0<br>59<br>6 59   </p></blockquote><p>输出例子1:</p><blockquote><p>6 0</p></blockquote><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> get[N];</span><br><span class="line">    <span class="keyword">int</span> hi,mi,x,goclass;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;hi&gt;&gt;mi;</span><br><span class="line">        get[i]=hi*<span class="number">60</span>+mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;hi&gt;&gt;mi;</span><br><span class="line">    goclass = hi * <span class="number">60</span> + mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (get[i] + x &lt;= goclass &amp;&amp; get[i] &gt; res)</span><br><span class="line">            res = get[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;res/<span class="number">60</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;res%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="牛牛的背包问题"><a href="#牛牛的背包问题" class="headerlink" title="牛牛的背包问题"></a>牛牛的背包问题</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p><p>输入描述:</p><blockquote><p>输入包括两行<br>第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量。<br>第二行n个正整数v<a href="0 &lt;= v[i] &lt;= 10^9">i</a>,表示每袋零食的体积。   </p></blockquote><p>输出描述:</p><blockquote><p>输出一个正整数, 表示牛牛一共有多少种零食放法。   </p></blockquote><p>输入例子1:</p><blockquote><p>3 10<br>1 2 4</p></blockquote><p>输出例子1:</p><blockquote><p>8</p></blockquote><p>例子说明1:</p><blockquote><p>三种零食总体积小于10,于是每种零食有放入和不放入两种情况，一共有2<em>2</em>2 = 8种情况。</p></blockquote><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nums = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> size , <span class="keyword">long</span> <span class="keyword">long</span> w, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        nums++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span> ; i &lt; size ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(<span class="built_in">array</span>,size,w,sum+<span class="built_in">array</span>[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n &gt;&gt; w;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; <span class="built_in">array</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i != n ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i];</span><br><span class="line">        total += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(total &lt;= w)</span><br><span class="line">    &#123;</span><br><span class="line">        nums = <span class="built_in">pow</span>(<span class="number">2</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sort(<span class="built_in">array</span>.begin(),<span class="built_in">array</span>.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i != n ; ++i)</span><br><span class="line">            DFS(<span class="built_in">array</span>, <span class="built_in">array</span>.size(), w, <span class="built_in">array</span>[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nums&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模拟笔试题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水1</title>
      <link href="/2019/02/12/%E6%8E%A5%E9%9B%A8%E6%B0%B41/"/>
      <url>/2019/02/12/%E6%8E%A5%E9%9B%A8%E6%B0%B41/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。   </p><p>示例:</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>,mx=<span class="number">0</span>,n = height.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = mx;</span><br><span class="line">            mx=max(mx,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i],mx);</span><br><span class="line">            mx = max(mx,height[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;height[i])</span><br><span class="line">                res += dp[i]-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,l=<span class="number">0</span>,r =height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = min(height[l],height[r]);</span><br><span class="line">            <span class="keyword">if</span>(mn == height[l])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp; height[l]&lt;mn)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += mn-height[l++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --r;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;height[r]&lt;mn)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += mn-height[r--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.size()<span class="number">-1</span>,level=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lower=height[(height[l]&lt;height[r])? l++:r--];</span><br><span class="line">            level = max(level,lower);</span><br><span class="line">            res+= level-lower;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,res=<span class="number">0</span>,n=height.size();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty()||height[i]&lt;=height[st.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(i++);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(st.empty()) <span class="keyword">continue</span>;</span><br><span class="line">                res+=(min(height[i],height[st.top()]) - height[t])*(i-st.top()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学学网络之Socket套接字</title>
      <link href="/2019/02/11/%E5%AD%A6%E5%AD%A6%E7%BD%91%E7%BB%9C%E4%B9%8BSocket%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
      <url>/2019/02/11/%E5%AD%A6%E5%AD%A6%E7%BD%91%E7%BB%9C%E4%B9%8BSocket%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。其本质为内核借助缓冲区形成的伪文件。因为我们常说，Linux下一切皆文件。<br>既然是文件，那么理所当然的，我们使用<code>文件描述符</code>引用套接字。与管道类似的，Linux系统将其封装成文件的<code>目的</code>是为了统一接口，使得读写套接字和读写文件的操作一致。<code>区别</code>是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。<br>套接字通信原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190211222541780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。<br>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。</p><p><img src="https://img-blog.csdnimg.cn/2019021122262628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2">   </p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。<br>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure><blockquote><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。<br>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p></blockquote><h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p>早期：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure></p><pre><code>只能处理IPv4的ip地址不可重入函数注意参数是struct in_addr</code></pre><p>现在：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><pre><code>支持IPv4和IPv6可重入函数其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。因此函数接口是void *addrptr。</code></pre><h4 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h4><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p><img src="https://img-blog.csdnimg.cn/20190211222821652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family; <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>sudo grep -r &quot;struct sockaddr_in</code> {“  /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_sa_family_t</span> sin_family; <span class="comment">/* Address family */</span>  地址结构类型</span><br><span class="line">__be16 sin_port; <span class="comment">/* Port number */</span>端口号</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* Internet address */</span>IP地址</span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr'. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) -</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) - <span class="keyword">sizeof</span>(struct in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span><span class="comment">/* Internet address. */</span></span><br><span class="line">__be32 s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin6_family; <span class="comment">/* AF_INET6 */</span></span><br><span class="line">__be16 sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">__be32 sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 address */</span></span><br><span class="line">__u32 sin6_scope_id; <span class="comment">/* scope id (new in RFC2553) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__u8 u6_addr8[<span class="number">16</span>];</span><br><span class="line">__be16 u6_addr16[<span class="number">8</span>];</span><br><span class="line">__be32 u6_addr32[<span class="number">4</span>];</span><br><span class="line">&#125; in6_u;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr in6_u.u6_addr8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr16 in6_u.u6_addr16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s6_addr32 in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line"><span class="keyword">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock-addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void <em>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void </em>类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));<span class="comment">/* initialize servaddr */</span></span><br></pre></td></tr></table></figure></p><h3 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h3><p><img src="https://img-blog.csdnimg.cn/20190211222855352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p><h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domain:</span><br><span class="line">AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">传<span class="number">0</span> 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">成功：返回指向新创建的socket的文件描述符，失败：返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd：</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line"><span class="keyword">sizeof</span>(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>, 设置errno</span><br></pre></td></tr></table></figure><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。<br>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure></p><p>首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为==INADDR_ANY==，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p><h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">sockfd:</span><br><span class="line">socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">排队建立<span class="number">3</span>次握手队列和刚刚建立<span class="number">3</span>次握手队列的链接数和</span><br></pre></td></tr></table></figure><p>查看系统默认backlog</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入传出参数（值-结果）,传入<span class="keyword">sizeof</span>(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回一个新的socket文件描述符，用于和客户端通信，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。<br>我们的服务器程序结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line">......</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p><h4 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">传入参数,传入<span class="keyword">sizeof</span>(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure><p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p><h3 id="C-S模型-TCP"><a href="#C-S模型-TCP" class="headerlink" title="C/S模型-TCP"></a>C/S模型-TCP</h3><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>下面通过最简单的客户端/服务器程序的实例来学习socket API。<br>server.c的作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">n = read(connfd, buf, MAXLINE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(connfd, buf, n);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p>client.c的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"><span class="keyword">int</span> sockfd, n;</span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"usage: ./client message\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">str = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">write(sockfd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">n = read(sockfd, buf, MAXLINE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Response from server:\n"</span>);</span><br><span class="line">write(STDOUT_FILENO, buf, n);</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。注意，客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。<br>客户端和服务器启动后可以使用netstat命令查看链接情况：   </p><pre><code>netstat -apn|grep 6666</code></pre><h3 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h3><p>上面的例子不仅功能简单，而且简单到几乎没有什么错误处理，我们知道，系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。<br>为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块wrap.c：</p><h4 id="wrap-h"><a href="#wrap-h" class="headerlink" title="wrap.h"></a>wrap.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> my_read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr);</span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="wrap-c"><a href="#wrap-c" class="headerlink" title="wrap.c"></a>wrap.c</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(s);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ( (n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">nleft -= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span> ((read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read_ptr = read_buf;</span><br><span class="line">&#125;</span><br><span class="line">read_cnt--;</span><br><span class="line">*ptr = *read_ptr++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n, rc;</span><br><span class="line"><span class="keyword">char</span> c, *ptr;</span><br><span class="line">ptr = vptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">*ptr++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="/2019/02/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/02/08/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p><pre><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code></pre><p>则依次打印出数字</p><pre><code>1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> || col==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>,right = col<span class="number">-1</span>,bottom=row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top&lt;= bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i) </span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;++i) </span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            <span class="keyword">if</span>(top != bottom)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=left;--i) </span><br><span class="line">                    res.push_back(matrix[bottom][i]);</span><br><span class="line">            <span class="keyword">if</span>(left != right)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i= bottom<span class="number">-1</span>;i&gt;top;--i)</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">            left++,top++,right--,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/2019/02/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/02/07/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = vin.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left,pre_right, vin_left,vin_right;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_left.push_back(pre[i+<span class="number">1</span>]);</span><br><span class="line">            vin_left.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-index<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre_right.push_back(pre[index+<span class="number">1</span>+i]);</span><br><span class="line">            vin_right.push_back(vin[index+<span class="number">1</span>+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = reConstructBinaryTree(pre_left,vin_left);</span><br><span class="line">        node-&gt;right = reConstructBinaryTree(pre_right,vin_right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的子结构</title>
      <link href="/2019/02/07/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/02/07/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = isSubtree(pRoot1,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>说说网络之名词解析</title>
      <link href="/2019/02/02/%E8%AF%B4%E8%AF%B4%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%90%8D%E8%AF%8D%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/02/02/%E8%AF%B4%E8%AF%B4%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%90%8D%E8%AF%8D%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>学习一些网络之后，发现存在对一些名词的含义还是记不住，因此作此文章来梳理网络中的一些关键名词。</p><h3 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a>网络名词术语解析</h3><h4 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a>路由(route)</h4><p>路由（名词）<br>数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。<br>路由（动词）<br>某个路由节点为数据包选择投递方向的选路过程。</p><h4 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h4><p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。   </p><p>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。   </p><p>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。   </p><p>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。   </p><p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</p><h3 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h3><p>路由表中的一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。</p><h3 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h3><p>路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。</p><h3 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a>路由节点</h3><p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p><h3 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。<br>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p><h3 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a>hub工作原理</h3><p>集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。<br>集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。其次是Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。<br>由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作：   </p><ul><li>第一步是将信息上传到上联设备；</li><li>第二步是上联设备再将该信息广播到所有端口上。<h3 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a>半双工/全双工</h3>Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。<br>Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3>DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。<br>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。<h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h3>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。</li></ul><ol><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</li><li>通信延迟时间短，可靠性较高</li><li>局域网可以支持多种传输介质<h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h3>wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。<br>覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。<br>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</li><li>适应大容量与突发性通信的要求；</li><li>适应综合业务服务的要求；</li><li>开放的设备接口与规范化的协议；</li><li>完善的通信服务与网络管理。<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3>逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li><li>端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。</li><li>客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</li><li>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。<br>我们应该在自定义端口时，避免使用well-known的端口。如：80、21等等。</li></ol><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU）<br>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。    </p><p>以下是一些协议的MTU：<br>FDDI协议：4352字节<br>以太网（Ethernet）协议：1500字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up/Modem）：576字节<br>Point-to-Point：4470字节   </p><h3 id="网络知识点的一些常见题"><a href="#网络知识点的一些常见题" class="headerlink" title="网络知识点的一些常见题"></a>网络知识点的一些常见题</h3><ol><li>TCP如何建立链接</li><li>TCP如何通信</li><li>TCP如何关闭链接</li><li>什么是滑动窗口</li><li>什么是半关闭</li><li>局域网内两台机器如何利用TCP/IP通信</li><li>internet上两台主机如何进行通信</li><li>如何在internet上识别唯一一个进程<br>答：通过“IP地址+端口号”来区分不同的服务</li><li>为什么说TCP是可靠的链接，UDP不可靠</li><li>路由器和交换机的区别</li><li>点到点，端到端</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再浅谈网络之“TCP协议”</title>
      <link href="/2019/01/31/%E5%86%8D%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9CTCP%E5%8D%8F%E8%AE%AE%E2%80%9D/"/>
      <url>/2019/01/31/%E5%86%8D%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9CTCP%E5%8D%8F%E8%AE%AE%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。<br><img src="https://img-blog.csdnimg.cn/20190202193733165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1">   </p><p>首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。   </p><h3 id="建立连接（三次握手）的过程："><a href="#建立连接（三次握手）的过程：" class="headerlink" title="建立连接（三次握手）的过程："></a>建立连接（三次握手）的过程：</h3><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。   </li><li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。   </li><li>客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为==三方握手（three-way-handshake）==。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</li></ol><h4 id="数据传输的过程："><a href="#数据传输的过程：" class="headerlink" title="数据传输的过程："></a>数据传输的过程：</h4><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据。</li><li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。<br>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</li></ol><h3 id="关闭连接（四次挥手）的过程："><a href="#关闭连接（四次挥手）的过程：" class="headerlink" title="关闭连接（四次挥手）的过程："></a>关闭连接（四次挥手）的过程：</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端发出段7，FIN位表示关闭连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求。</li><li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</li><li>客户端发出段10，应答服务器的关闭连接请求。<br>建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</li></ol><h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口 (TCP流量控制)"></a>滑动窗口 (TCP流量控制)</h3><p>UDP传输的时候描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过<code>滑动窗口（Sliding Window)</code>机制解决这一问题。看下图的通讯过程：<br><img src="https://img-blog.csdnimg.cn/20190202193849279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ol><li>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li><li>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li><li>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</li><li>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li><li>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</li><li>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</li><li>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li><li>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</li><li>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。<br>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。<br>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。<h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3></li></ol><p><img src="https://img-blog.csdnimg.cn/20190202194033294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"><br><strong>CLOSED</strong>：表示初始状态。<br><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。<br><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。<br><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。<br><strong>ESTABLISHED</strong>：表示连接已经建立。<br><strong>FIN_WAIT_1</strong>:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：<br>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。<br>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。<br><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。<br><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。<br><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。<br><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure></p><p>使用close中止一个连接，它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。<br>shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 </li><li>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信，如果一个进程close(sfd)将不会影响到其它进程。</li></ol><h4 id="2MSL-Maximum-Segment-Lifetime"><a href="#2MSL-Maximum-Segment-Lifetime" class="headerlink" title="2MSL(Maximum Segment Lifetime)"></a>2MSL(Maximum Segment Lifetime)</h4><p> TIME_WAIT状态的存在有两个理由：   </p><ul><li>让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。   </li><li>防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</li></ul><h4 id="程序设计中出现的问题"><a href="#程序设计中出现的问题" class="headerlink" title="程序设计中出现的问题"></a>程序设计中出现的问题</h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure></p><p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">1</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       CLOSE_WAIT  <span class="number">3525</span>/client     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>      FIN_WAIT2   -</span><br></pre></td></tr></table></figure><p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。<br>现在用Ctrl-C把client也终止掉，再观察现象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxk$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>       <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38104</span>      TIME_WAIT   -</span><br><span class="line">lxk$ ./server</span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure><p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。==TCP协议规定==，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。<br>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。</p><h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:8888）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:8888），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。<br>在server代码的socket()和bind()调用之间插入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a>TCP异常断开</h3><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。<br><strong>Heart-Beat线程:</strong><br>这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。<br>该方法的==好处是通用==，但缺点就是==会改变现有的通讯协议==！大家一般都是使用业务层心跳来处理，主要是灵活可控。<br>UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p><h4 id="设置TCP属性"><a href="#设置TCP属性" class="headerlink" title="设置TCP属性"></a>设置TCP属性</h4><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持==存活探测分节==(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈网络之“协议格式”</title>
      <link href="/2019/01/30/%E5%86%8D%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9C%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E2%80%9D/"/>
      <url>/2019/01/30/%E5%86%8D%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E2%80%9C%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上一篇中是有关网络的设计模式和分层模型，这篇就来说说网络里面用到的几个重要协议的格式，用程序员来的话来说就是报头格式。当然，在进入主题之前，先了解下通信的过程。</p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p><strong>两台计算机通过TCP/IP协议通讯的过程如下所示：</strong><br><img src="https://img-blog.csdnimg.cn/2019013021170727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</strong><br><img src="https://img-blog.csdnimg.cn/20190130211750435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><ul><li>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。   </li><li>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。   </li><li>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。   </li><li>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说 的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。   </li><li>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。   </li><li>那么目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211851391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></li><li>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</li><li>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</li></ul><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><h3 id="数据表封装"><a href="#数据表封装" class="headerlink" title="数据表封装"></a>数据表封装</h3><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（也就是我们常说的socket编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190130211956396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"><br>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网的帧格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212040538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"></p><p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，<code>HWaddr 00:15:F2:14:9E:3F</code>部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行<code>分片</code>（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p><p><strong>上面说到的分片？为什么要分片？如何分片？</strong></p><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须==获得目的主机的硬件地址==。==ARP协议就起到这个作用==。例如：源主机发出ARP请求，询问“IP地址是<code>192.168.0.1</code>的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。<br>每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。<br><strong>为什么表项要有过期时间而不是一直有效？</strong></p><p>ARP数据报的格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20190130212121578.png" alt="6"></p><p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为==1表示ARP请求==，op字段为==2表示ARP应答==。</p><p><strong>源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</strong></p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212157821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="6"><br>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p><p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212215315.png" alt="8"></p><p>UDP首部：源端口号是客户端的端口号，目的端口号是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</p><h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h3><p><img src="https://img-blog.csdnimg.cn/20190130212243418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="9"><br>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小等。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，关于SYN、ACK、FIN、RST四个位，会在后面的文章里详细解释，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。</p><p>以上为网络协议的格式介绍，协议相关的具体内容将在后面的文章里介绍。欢迎大家关注。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈网络之设计模式与分层模型</title>
      <link href="/2019/01/30/%E8%B0%88%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/30/%E8%B0%88%E8%B0%88%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在学习网络之前，我们先了解下网络应用程序设计模式和网络的分层模型</p><h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><p><strong>优缺点：</strong> 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<code>提高数据传输效率。</code>且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所<code>采用的协议相对灵活。</code>可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。<br>    因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏英雄联盟。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br>    C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。<code>工作量</code>将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<code>安全性</code>构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。<br>    B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其<code>工作开发量较小</code>。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br>    B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<code>缓存数据不尽如人意</code>，从而<code>传输数据量受到限制</code>。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，<code>协议选择不灵活</code>。<br>    因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="https://img-blog.csdnimg.cn/20190130131007694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li><li>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li><li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li></ol><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190130131054219.png" alt="2"></p><p>一般在应用开发过程中，讨论最多的是TCP/IP模型。但也有一些自定义协议类型，只是在其之上进行一些修改完成需求功能即可的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的第k个结点</title>
      <link href="/2019/01/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/01/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = KthNode(pRoot-&gt;left,k);</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            index++;  </span><br><span class="line">            <span class="keyword">if</span>(index == k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot-&gt;right,k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“三次握手，四次挥手”你真的懂吗？</title>
      <link href="/2019/01/24/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/"/>
      <url>/2019/01/24/%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E2%80%9D%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是”三次握手，四次挥手“"><a href="#什么是”三次握手，四次挥手“" class="headerlink" title="什么是”三次握手，四次挥手“"></a>什么是”三次握手，四次挥手“</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用3次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p><img src="https://img-blog.csdnimg.cn/20190124115039196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>三次握手和四次挥手的状态转换如下图<br><img src="https://img-blog.csdnimg.cn/20190124115225958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><h4 id="“三次握手，四次挥手”是怎么完成的？"><a href="#“三次握手，四次挥手”是怎么完成的？" class="headerlink" title="“三次握手，四次挥手”是怎么完成的？"></a>“三次握手，四次挥手”是怎么完成的？</h4><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。<br><img src="https://img-blog.csdnimg.cn/20190124115513655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="3"></p><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><ol><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p><h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://img-blog.csdnimg.cn/20190124115650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="4"></p></li><li><p>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </p></li><li><p>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</p></li><li><p>服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</p></li></ol><h4 id="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接的时候是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h3 id="”三次握手，四次挥手“进阶"><a href="#”三次握手，四次挥手“进阶" class="headerlink" title="”三次握手，四次挥手“进阶"></a>”三次握手，四次挥手“进阶</h3><h4 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><p>ISN = M + F(localhost, localport, remotehost, remoteport)</p><p>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h4 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h4><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h5 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h5><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h5 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h5><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h5 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h5><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。<br><img src="https://img-blog.csdnimg.cn/20190124122642462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="5"><br>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><p>查看是否有连接溢出 <code>netstat -s | grep LISTEN</code></p><h5 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h5><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><h5 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h5><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><code>netstat -s</code>命令</p><p>[root@server ~]# netstat -s | grep “listen|LISTEN” </p><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><p>[root@server ~]# netstat -s | grep TCPBacklogDrop </p><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><p>[root@server ~]# ss -lnt</p><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装更新git的正确打开方式</title>
      <link href="/2019/01/03/CentOS7%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0git%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/01/03/CentOS7%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0git%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://img-blog.csdnimg.cn/20190103165013557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">1</a></p><p>安装centos7 之后一直用自带的git，在提交的时候总是出现下面这种情况，原因是git版本太低导致的，于是就想了办法去更新git，<br>百度看了很多教程，都是什么先卸载再重新安装，卸载之前还需要备份一份配置文件，看了很多感觉非常麻烦，于是就在Linux网站中看到了一个最正确的更新及安装方式。以下是记录我更新安装过程。</p><h3 id="配置存储库"><a href="#配置存储库" class="headerlink" title="配置存储库"></a>配置存储库</h3><p>在这之前，我们需要在root权限下才可以进一步操作。<br>1.启用Wandisco GIT存储库<br>启用存储库需要在/etc/yum.repos.d/目录中命名的新yum存储库配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/wandisco-git.repo</span><br></pre></td></tr></table></figure></p><p>添加以下字段，ESC，然后:输入wq保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><p>使用以下命名了导入存储库GPG密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>完成之后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p><p>输出<code>git version 2.18.0</code></p><h3 id="验证配置文件更改"><a href="#验证配置文件更改" class="headerlink" title="验证配置文件更改"></a>验证配置文件更改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=Your Name</span><br><span class="line">user.email=youremail@yourdomain.com</span><br></pre></td></tr></table></figure></p><p>配置设置存储在~/.gitconfig文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = youremail@yourdomain.com</span><br></pre></td></tr></table></figure><p>要进一步更改Git配置，可以使用git config命令或~/.gitconfig手动编辑文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7环境下安装vscode</title>
      <link href="/2019/01/03/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/"/>
      <url>/2019/01/03/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85vscode/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>最近在Linux环境下写几个程序时发现用vim时总出现一点问题，配置了vim也还是不太习惯，因此就安装了vscode，这篇文章记录了CentOS7下安装过程。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>环境参数：<br>操作系统版本：CentOS-7-x86_64-1511<br>软件版本：visual stdio code 1.2   </p><p>操作步骤：<br>1.下载 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode_x86_64.rpm</a><br>2.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>可能会报这样一个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libXss.so.1()(64bit) is needed by code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libXss*  -y</span><br></pre></td></tr></table></figure></p><p>然后在重新安装rpm文件，没报错可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh code-insiders-1.25.0-1530077090.el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>然后打开应用程序可以看见vscode安装好了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7环境下安装Chrome</title>
      <link href="/2019/01/02/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Chrome/"/>
      <url>/2019/01/02/CentOS7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Chrome/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>下载Chrome浏览器的rpm包（<a href="https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）" target="_blank" rel="noopener">https://www.chrome64bit.com/index.php/google-chrome-64-bit-for-linux）</a><br>利用xshell连接好Linux，使用命令rz，弹出选择窗口，将下载好的包上传进去，然后进入包目录，使用rpm命令进行安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>当然，这里需要切换到root用户下才可以执行。<br>执行完命令后会出现错误<br><img src="https://img-blog.csdnimg.cn/20190102230011852.png" alt="1"></p><p>出现这个错误是因为少了redhat-lsb这个依赖</p><p>安装readhat-lsb依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  redhat-lsb</span><br></pre></td></tr></table></figure></p><p>安装完上面的lsb依赖后，再来执行chrome安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh google-chrome-stable_current_x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>至此Chrome就安装完毕了，打开 应用程序 》互联网 就会发现Chrome的图标了</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>在以上正常的安装方式中， 我安装失败了，原因是我的key无法更新，于是我就选择了另外一种在线安装。以下记录了在线安装的过程。仅供参考，大佬勿喷。   </p><h4 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h4><p>在/etc/yum.repos.d/目录下新建文件google-chrome.repo，向其中添加如下内容:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[google-chrome]</span><br><span class="line">name=google-chrome</span><br><span class="line">baseurl=http:<span class="comment">//dl.google.com/linux/chrome/rpm/stable/$basearch</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//dl-ssl.google.com/linux/linux_signing_key.pub</span></span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable</span><br></pre></td></tr></table></figure></p><p>注：Google官方源在国内可能无法正常访问，导致安装失败或安装后无法正常更新，可以尝试添加–nogpgcheck参数再安装。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install google-chrome-stable --nogpgcheck</span><br></pre></td></tr></table></figure></p><p>或者可以尝试修改gpgcheck=0再安装。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Linux下静态链接库出现的问题</title>
      <link href="/2018/12/31/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/31/%E8%A7%A3%E5%86%B3Linux%E4%B8%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>该问题是针对刚安装的Linux环境的小萌新在使用gcc/g++编译时出现的问题，如果你是大佬，这篇文章可能对你并没有帮助。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当我们用Makefile工具时，在Makefile文件中写编译语句时，希望编译时用静态链接库来编译，例如语句如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o $@ $^ -<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>编译时链接静态库的方式有好几种，这里我使用static。问题出现的是，当我们make时，出现如下问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test test.cpp -<span class="keyword">static</span></span><br><span class="line">/usr/bin/ld: cannot find -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lm</span><br><span class="line">/usr/bin/ld: cannot find -lc</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">make: *** [tcpClient] Error <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在我百度了很久之后CSDN未能解决如下问题，还是Stack Overflow解决了该问题。<br>用如下两条命令安装所需要的静态库即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install libstdc++-<span class="keyword">static</span></span><br><span class="line">sudo yum install glibc-<span class="keyword">static</span></span><br></pre></td></tr></table></figure></p><p>安装了以上两个库之后，make一下，编译成功，使用<code>ll</code>查看你会发现编译之后的目标文件会非常大。这时就是成功的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的几款内存泄漏检测工具</title>
      <link href="/2018/12/24/Linux%E4%B8%8B%E7%9A%84%E5%87%A0%E6%AC%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/12/24/Linux%E4%B8%8B%E7%9A%84%E5%87%A0%E6%AC%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="http://blog.csdn.net/gatieme%09https://blog.csdn.net/gatieme/article/details/51959654" target="_blank" rel="noopener">原文链接</a></p><p>Linux下编写C或者C++程序，有很多工具，但是主要编译器仍然是gcc和g++。最近用到STL中的List编程，为了检测写的代码是否会发现内存泄漏，了解了一下相关的知识。</p><p>所有使用动态内存分配(dynamic memory allocation)的程序都有机会遇上内存泄露(memory leakage)问题，在Linux里有三种常用工具来检测内存泄露的情況，包括：</p><p>参见 <a href="http://elinux.org/Memory_Debuggers" rel="nofollow" target="_blank">http://elinux.org/Memory_Debuggers</a> <br><br>偶然发现的<a href="http://blog.163.com/zhuang_qianxin/blog/static/29765138201051092529107/" rel="nofollow" target="_blank">内存泄露检测工具比较 </a></p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">工具</th><br>  <th align="center">描述</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#valgrind" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center">一个强大开源的程序检测工具</td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Memory_Debuggers#mtrace" rel="nofollow" target="_blank">mtrace</a></td><br>  <td align="center">GNU扩展, 用来跟踪malloc, mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数</td><br></tr><br><tr><br>  <td align="center"><a href="" rel="nofollow" target="_blank">dmalloc</a></td><br>  <td align="center">用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存,以一个运行库的方式发布</td><br></tr><br><tr><br>  <td align="center">memwatch</td><br>  <td align="center">和dmalloc一样，它能检测未释放的内存、同一段内存被释放多次、位址存取错误及不当使用未分配之内存区域</td><br></tr><br><tr><br>  <td align="center"><a href="http://mpatrol.sourceforge.net/" rel="nofollow" target="_blank">mpatrol</a></td><br>  <td align="center"><a href="http://www.ibm.com/developerworks/cn/linux/l-mleak2/" rel="nofollow" target="_blank">一个跨平台的 C++ 内存泄漏检测器</a></td><br></tr><br><tr><br>  <td align="center"><a href="http://dbgmem.sourceforge.net/" rel="nofollow" target="_blank">dbgmem</a></td><br>  <td align="center"></td><br></tr><br><tr><br>  <td align="center"><a href="http://elinux.org/Electric_Fence" rel="nofollow" target="_blank">Electric Fence</a></td><br>  <td align="center"></td><br></tr><br></tbody></table></div><h1 id="1-被测程序"><a name="t0"></a>1  被测程序</h1><hr><p class="cye-lm-tag">为了方便测试,,我们编写了一个简单的程序, 循环10次每次申请了一个100个字节的单元, 但是却不释放</p><h1 id="2-valgrind"><a name="t1"></a>2  valgrind</h1><hr><h2 id="21-valgrind介绍"><a name="t2"></a>2.1   valgrind介绍</h2><hr><p class="cye-lm-tag">是不是说没有一种内存检查工具能够在Linux使用呢，也不是，像开源的valgrind工具还是相当不错的</p><ul><br><li><p class="cye-lm-tag">Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</p></li><br><li><p class="cye-lm-tag">Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</p></li><br><li><p class="cye-lm-tag">Cachegrind。它主要用来检查程序中缓存使用出现的问题。</p></li><br><li><p class="cye-lm-tag">Helgrind。它主要用来检查多线程程序中出现的竞争问题。</p></li><br><li><p class="cye-lm-tag">Massif。它主要用来检查程序中堆栈使用中出现的问题。</p></li><br><li><p class="cye-lm-tag">Extension。可以利用core提供的功能，自己编写特定的内存调试工具</p></li><br></ul><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">主页</th><br>  <th align="center">下载</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center"><a href="http://valgrind.org/" rel="nofollow" target="_blank">valgrind</a></td><br>  <td align="center"><a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">downloads</a></td><br></tr><br></tbody></table></div><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719211251895" alt="valgrind介绍" title=""></p><blockquote><br>  <p class="cye-lm-tag">参照</p><br><br>  <p class="cye-lm-tag"><a href="http://www.cnblogs.com/sunyubo/archive/2010/05/05/2282170.html" rel="nofollow" target="_blank">Valgrind简单用法</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">Unix下C程序内存泄漏检测工具Valgrind安装与使用</a></p><br><br>  <p class="cye-lm-tag"><a href="http://blog.csdn.net/sduliulun/article/details/7732906" rel="nofollow" target="_blank">valgrind 的使用简介</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" rel="nofollow" target="_blank">应用 Valgrind 发现 Linux 程序的内存问题</a></p><br><br>  <p class="cye-lm-tag"><a href="http://www.oschina.net/translate/valgrind-memcheck" rel="nofollow" target="_blank">如何使用Valgrind memcheck工具进行C/C++的内存泄漏检测</a></p><br></blockquote><h2 id="22-安装"><a name="t3"></a>2.2   安装</h2><hr><p class="cye-lm-tag"><strong>源码安装</strong></p><p class="cye-lm-tag">到<a href="http://valgrind.org/downloads/current.html#current" rel="nofollow" target="_blank">下载地址</a>)下载最新版的valgrind,按照里面的README提示，安装后就可以使用这个工具来检测内存泄露和内存越界等</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">/configuremakesudo make install<p class="cye-lm-tag">当然也可以使用发行版的自带的源中安装</p>sudo apt install valgrind这是一个没有界面的内存检测工具，安装后，输入 valgrind ls -l 验证一下该工具是否工作正常（这是README里面的方法，实际上是验证一下对ls -l命令的内存检测），如果你看到一堆的信息说明你的工具可以使用了。<h2 id="23-使用说明"><a name="t4"></a>2.3   使用说明</h2><hr><p class="cye-lm-tag">Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif。</p><p class="cye-lm-tag"><strong>Memcheck</strong></p><p class="cye-lm-tag">最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc()/free()/new/delete的调用都会被捕获。所以，Memcheck 工具主要检查下面的程序错误</p><div class="table-box"><table><thead><tr>  <th align="center">内容</th>  <th align="center">描述</th></tr></thead><tbody><tr>  <td align="center">使用未初始化的内存</td>  <td align="center">Use of uninitialised memory</td></tr><tr>  <td align="center">使用已经释放了的内存</td>  <td align="center">Reading/writing memory after it has been free’d</td></tr><tr>  <td align="center">使用超过 malloc分配的内存空间</td>  <td align="center">Reading/writing off the end of malloc’d blocks</td></tr><tr>  <td align="center">对堆栈的非法访问</td>  <td align="center">Reading/writing inappropriate areas on the stack</td></tr><tr>  <td align="center">申请的空间是否有释放</td>  <td align="center">Memory leaks – where pointers to malloc’d blocks are lost forever</td></tr><tr>  <td align="center">malloc/free/new/delete申请和释放内存的匹配</td>  <td align="center">Mismatched use of malloc/new/new [] vs free/delete/delete []</td></tr><tr>  <td align="center">src和dst的重叠</td>  <td align="center">Overlapping src and dst pointers in memcpy() and related functions</td></tr></tbody></table></div><p class="cye-lm-tag">这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。 </p><p class="cye-lm-tag"><strong>Callgrind</strong></p><p class="cye-lm-tag">和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 </p><p class="cye-lm-tag"><strong>Cachegrind</strong></p><p class="cye-lm-tag">Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 </p><p class="cye-lm-tag"><strong>Helgrind</strong></p><p class="cye-lm-tag">它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 </p><p class="cye-lm-tag"><strong>Massif</strong></p><p class="cye-lm-tag">堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 </p><blockquote>  <p class="cye-lm-tag">此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具</p>  <p class="cye-lm-tag"><strong>注意</strong></p>  <p class="cye-lm-tag">Valgrind不检查静态分配数组的使用情况</p>  <p class="cye-lm-tag">Valgrind占用了更多的内存–可达两倍于你程序的正常使用量</p>  <p class="cye-lm-tag">如果你用Valgrind来检测使用大量内存的程序就会遇到问题，它可能会用很长的时间来运行测试</p></blockquote><h2 id="24-使用说明"><a name="t5"></a>2.4   使用说明</h2><hr><p class="cye-lm-tag">编译程序</p>g++ -g -o leak leak.c <p class="cye-lm-tag">被检测程序加入 –g   -fno-inline 编译选项保留调试信息, 否则后面的valgrind不能显示到出错行号。</p>valgrind被设计成非侵入式的，它直接工作于可执行文件上，因此在检查前不需要重新编译、连接和修改你的程序。要检查一个程序很简单，只需要执行下面的命令就可以了。valgrind --tool=tool_name program_name比如我们要对ls -l命令做内存检查，只需要执行下面的命令就可以了<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck ls -l</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><blockquote><br>  <p class="cye-lm-tag">小提示 <br><br>  如果不知道有哪些参数, 可以先输入valgrind –tool=, 然后狂按两次tab, 会输出linux系统的只能提示, 同样,如果你输入了valgrind –tool=mem再狂按两次tab,linux系统会为你自动补全</p><br></blockquote><h2 id="25-使用valgrind检测memcheck"><a name="t6"></a>2.5   使用valgrind检测Memcheck</h2><hr><p class="cye-lm-tag">下面我们就可以用valgrind对我们的程序检测leak</p><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes    ./leak</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag">其中–leak-check=full 指的是完全检查内存泄漏，</p><p class="cye-lm-tag">–show-reachable=yes是显示内存泄漏的地点，</p><p class="cye-lm-tag">–trace-children=yes是跟入子进程。</p><p class="cye-lm-tag">当程序正常退出的时候valgrind自然会输出内存泄漏的信息原理：</p><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719210756831" alt="输出内存泄漏的信息原" title=""></p><h1 id="3-mtrace检测内存泄露"><a name="t7"></a>3  mtrace检测内存泄露</h1><hr><h2 id="31-mtrace简介"><a name="t8"></a>3.1   mtrace简介</h2><hr><p class="cye-lm-tag">在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace. </p><p class="cye-lm-tag">mtrace其实是GNU扩展函数，用来跟踪malloc。</p><p class="cye-lm-tag">mtrace为内存分配函数（malloc, realloc, memalign, free）安装hook函数。这些hook函数记录内存的申请和释放的trace信息。 <br><br>在程序中，这些trace信息可以被用来发现内存泄漏和释放不是申请的内存。 <br><br>当调用mtrace，mtrace会检查环境变量MALLOC_TRACE。该环境变量应该包含记录trace信息的文件路径。如果文件可以被成功打开，它的大小被截断为0。 <br><br>如果MALLOC_TRACE没有设置，或者设置的文件不可用或者不可写，那么将不会安装hook函数，mtrace不生效。</p><p class="cye-lm-tag">详细说明可参考man page：man 3 mtrace</p><h2 id="32-mtrace使用"><a name="t9"></a>3.2   mtrace使用</h2><hr><p class="cye-lm-tag">mtrace能监测程序是否内存泄露</p><ul><br><li>在程序的起始处包含头文件</li></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-preprocessor cye-lm-tag">#include &lt;mcheck.h&gt;</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>更改环境变量：export   MALLOC_TRACE=”mtrace.out”可以加入如下代码</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">setenv(<span class="hljs-string cye-lm-tag">"MALLOC_TRACE"</span>, <span class="hljs-string cye-lm-tag">"mtrace.out"</span>, <span class="hljs-number cye-lm-tag">1</span>);</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>调用函数mtrace()</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace()</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>编译程序带上 -g 选项</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">gcc -g -c leak_mtrace.c -o leak_mtrace.o  -<span class="hljs-built_in cye-lm-tag">std</span>=gnu9x -Wall</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>运行程序一次，尽量调用所有程序内的函数。这时调试信息就已经被写入我们指定的mtrace.out文件中</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">./leak_mtrace </code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><br><li>mtrace a.out  mtrace.out查看内存监测情况</li><br></ul><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">mtrace a.out  mtrace.out</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p class="cye-lm-tag"><img src="https://img-blog.csdn.net/20160719214131721" alt="这里写图片描述" title=""></p><h1 id="4-dmalloc"><a name="t10"></a>4  dmalloc</h1><hr><p class="cye-lm-tag">dmalloc是一种用于检查C/C++内存泄露(leak)的工具，即检查是否存在直到程序运行结束还没有释放的内存，并且能够精确指出在哪个源文件的第几行。</p><h1 id="5-linux内核的kmemleak"><a name="t11"></a>5  Linux内核的Kmemleak</h1><h2 id="51-kmemleak检测工具介绍"><a name="t12"></a>5.1   Kmemleak检测工具介绍</h2><hr><p class="cye-lm-tag">Kmemleak工作于内核态是内核自带的内核泄露检测工具, 其源代码位于<a href="http://lxr.free-electrons.com/source/mm/kmemleak.c?v4.7" rel="nofollow" target="_blank">mm/kmemleak.c</a></p><p class="cye-lm-tag">Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，其方法类似于跟踪内存收集器。当独立的对象没有被释放时，其报告记录在 /sys/kernel/debug/kmemleak中，Kmemcheck能够帮助定位大多数内存错误的上下文。</p><h2 id="52-kmemleak使用过程概述"><a name="t13"></a>5.2   Kmemleak使用过程概述</h2><ul><br><li><p class="cye-lm-tag">首先`CONFIG_DEBUG_KMEMLEAK在Kernel hacking中被使能.</p></li><br><li><p class="cye-lm-tag">查看内核打印信息详细过程如下：</p><br><br><ol><li>挂载debugfs文件系统 <br><br>mount -t debugfs nodev /sys/kernel/debug/</li><br><li>开启内核自动检测线程 <br><br>echo scan &gt; /sys/kernel/debug/kmemleak</li><br><li>查看打印信息 <br><br>cat /sys/kernel/debug/kmemleak</li><br><li>清除内核检测报告，新的内存泄露报告将重新写入/sys/kernel/debug/kmemleak <br><br>echo clear &gt; /sys/kernel/debug/kmemleak</li></ol></li><br></ul><p class="cye-lm-tag">内存扫描参数可以进行修改通过向/sys/kernel/debug/kmemleak 文件写入。 参数使用如下</p><pre class="prettyprint" name="code"><code class="language-cpp hljs  has-numbering">off 禁用kmemleak（不可逆）<span class="hljs-built_in cye-lm-tag">stack</span>=on 启用任务堆栈扫描(<span class="hljs-keyword cye-lm-tag">default</span>)<span class="hljs-built_in cye-lm-tag">stack</span>=off 禁用任务堆栈扫描scan=on 启动自动记忆扫描线程(<span class="hljs-keyword cye-lm-tag">default</span>)scan=off 停止自动记忆扫描线程scan=&lt;secs&gt; 设置n秒内自动记忆扫描scan 开启内核扫描clear 清除内存泄露报告dump=&lt;addr&gt; 转存信息对象在&lt;addr&gt;</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p class="cye-lm-tag">通过“kmemleak = OFF”，也可以在启动时禁用Kmemleak在内核命令行。在初始化kmemleak之前，内存的分配或释放这些动作被存储在一个前期日志缓冲区。这个缓冲区的大小通过配CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE设置。 </p><h2 id="53-kmemleak动态检测原理"><a name="t14"></a>5.3   Kmemleak动态检测原理</h2><hr><p class="cye-lm-tag">通过的kmalloc、vmalloc、kmem_cache_alloc等内存分配会跟踪其指针，连同其他的分配大小和堆栈跟踪信息，存储在PRIO搜索树。相应的释放函数调用跟踪和指针就会从kmemleak数据结构中移除。 <br><br>分配的内存块，被认为是独立的，如果没有指针指向它起始地址或块的内部的任何位置，可以发现扫描内存（包括已保存的寄存器）。这意味着，有可能没有办法为内核通过所分配的地址传递块到一个释放函数，因此，该块被认为是一个内存泄漏。</p><p class="cye-lm-tag">扫描算法步骤： <br><br>1.  标记的所有分配对象为白色（稍后将剩余的白色物体考虑独立的）</p><ol><br><li><p class="cye-lm-tag">扫描存储器与所述数据片段和栈开始，检查对地址的值存储在PRIO搜索树。如果一个白色的对象的指针被发现，该对象将被添加到灰名单</p></li><br><li><p class="cye-lm-tag">扫描的灰色对象匹配的地址（一些白色物体可以变成灰色，并添加结束时的灰名单），直到黑色集结束</p></li><br><li><p class="cye-lm-tag">剩下的白色物体被认为是独立儿，并报告写入/sys/kernel/debug/kmemleak。 <br><br>一些分配的内存块的指针在内核的内部数据结构和它们不能被检测为孤儿。对避免这种情况，kmemleak也可以存储的数量的值，指向一个内的块的地址范围内的地址，需要找到使块不被认为是泄漏.</p></li><br></ol><h2 id="54-kmem相关函数"><a name="t15"></a>5.4   kmem相关函数</h2><hr><p class="cye-lm-tag">从kernel源代码中的目录<code>include /linux/kmemleak.h</code>中可查看函数原型的头</p><div class="table-box"><table><br><thead><br><tr><br>  <th align="center">函数</th><br>  <th align="center">功能</th><br></tr><br></thead><br><tbody><tr><br>  <td align="center">kmemleak_init</td><br>  <td align="center">初始化kmemleak</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc</td><br>  <td align="center">一个内存块分配的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_percpu</td><br>  <td align="center">通知的一个percpu的内存块分配</td><br></tr><br><tr><br>  <td align="center">kmemleak_free</td><br>  <td align="center">通知的内存块释放</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_part</td><br>  <td align="center">通知释放部分内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_percpu</td><br>  <td align="center">一个percpu内存块释放的通知</td><br></tr><br><tr><br>  <td align="center">kmemleak_not_leak</td><br>  <td align="center">当不是泄露时，标记对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_ignore</td><br>  <td align="center">当泄漏时不扫描或报告对象</td><br></tr><br><tr><br>  <td align="center">kmemleak_scan_area</td><br>  <td align="center">添加扫描区域内的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_no_scan</td><br>  <td align="center">不扫描的内存块</td><br></tr><br><tr><br>  <td align="center">kmemleak_erase</td><br>  <td align="center">删除一个指针变量的旧值</td><br></tr><br><tr><br>  <td align="center">kmemleak_alloc_recursive</td><br>  <td align="center">为kmemleak_alloc，只检查递归</td><br></tr><br><tr><br>  <td align="center">kmemleak_free_recursive</td><br>  <td align="center">为kmemleak_free，只检查递归</td><br></tr><br></tbody></table></div>            <br>                        <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-2b43bc2447.css" rel="stylesheet"><br>                </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>window双系统Deepin安装及正确删除</title>
      <link href="/2018/12/24/window%E5%8F%8C%E7%B3%BB%E7%BB%9FDeepin%E5%AE%89%E8%A3%85%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4/"/>
      <url>/2018/12/24/window%E5%8F%8C%E7%B3%BB%E7%BB%9FDeepin%E5%AE%89%E8%A3%85%E5%8F%8A%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><a href="https://blog.csdn.net/qq_39478237/article/details/85239249" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口的最大值</title>
      <link href="/2018/12/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2018/12/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>暴力破解法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || num.size() &lt; size || num.size() &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> end = size;   <span class="comment">//定义end为窗口数组的大小</span></span><br><span class="line"><span class="keyword">while</span> (end &lt;= num.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = num[end-size];    <span class="comment">//默认窗口中第一个元素为最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = end - size+<span class="number">1</span>; i &lt; end; ++i)         <span class="comment">//从第二个元素开始进行窗口元素遍历，找到窗口中最大的元素，存入v中，end后移</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; num[i])</span><br><span class="line">&#123;</span><br><span class="line">max = num[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br><span class="line">v.push_back(max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><strong>Thinking</strong> 。。。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux编程之进程间通信</title>
      <link href="/2018/12/08/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/12/08/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程,在这个过程中，伴随着资源的分配和释放。那么释放的资源可能是其他进程需要的，然而进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。</p><h3 id="进程通信应用场景"><a href="#进程通信应用场景" class="headerlink" title="进程通信应用场景"></a>进程通信应用场景</h3><ul><li><p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p></li><li><p>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p></li><li><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p></li><li><p>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p></li><li><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p></li></ul><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><h4 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h4><p><img src="https://img-blog.csdnimg.cn/20181208215636614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"></p><p><strong>管道实现细节</strong><br>在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图<br><img src="https://img-blog.csdnimg.cn/20181208215019885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><p>仅仅适用于具有亲缘关系的进程间通信，因为匿名管道其它进程根本找不到，因此也就没有办法通信，所以只能通过子进程复制父进程的方法，让子进程能够访问相同的管道，来实现通信。<br>（管道的操作：io操作—文件描述符）</p><h5 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5><p>有名字：体现在文件系统可见性，因为其它进程都能看见这个管道文件，因此都能打开可以用于任意（本机）进程间通信<br>（单向通信）所以一个管道使用的时候就必须确定数据流向，但是不能一创建就确 定，因为我们不确定谁读谁写。   因此，操作系统提供两个描述符来供<br>使用，一个读一个写，这样的确定方向就是将对应的一段关闭掉就可以，这样操作系统就把方向的控制权交给用户了<br>接口：pipe（int fd[2]）fd[0]— 读  fd[1]—写</p><h4 id="信号量（semophore）"><a href="#信号量（semophore）" class="headerlink" title="信号量（semophore）"></a>信号量（semophore）</h4><p>信号量并不是用来数据传输的，而是用来进程控制，是解决进程间同步与互斥问题<br>是一个具有等待队列的计数器<br>释放资源+1，<br>获取资源-1，<br>当计数器的值不大于0，意味着没有资源，想要获取信号量资源（计数器-1）的就需要等待<br>同步：如果现在没有资源，等待，等待别人释放资源，别人释放资源后会通知等待的人<br>互斥：一元信号量实现互斥（计数器是0或 1）   </p><h4 id="消息队列（message-queue）"><a href="#消息队列（message-queue）" class="headerlink" title="消息队列（message queue）"></a>消息队列（message queue）</h4><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。   它通常在内核中创建一个消息队列，其它的所有进程都可以通过相同的<code>IPC_KEY</code> 打开消息队列<br>这时候既可以向消息队列中放数据，也可以从中拿数据，但是这样的数据就有可能拿错了，拿到的不是自己的数据，因此消息队列中能够放的数据是有类型的数据块，并且读写的时候只能按消息块来发送/接收。</p><h4 id="信号（sinal）"><a href="#信号（sinal）" class="headerlink" title="信号（sinal）"></a>信号（sinal）</h4><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>它是通过软中断的方式来进行的，信号产生之后第一时间也不是直接处理，而是先存储下来，处理信号<br>为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去准备处理事件，事件处理完毕后进程回到原先运行的位置继续运行   </p><p><strong>信号的产生-&gt;信号的注册-&gt;注销信号-&gt;信号的处理</strong><br>Linux下有62种信号，kill -l查看<br>信号分两类：普通信号（不可靠信号1~31)(非实时信号)<br>可靠信号（34~64）(实时信号)</p><p><strong>信号的产生：</strong>   </p><ul><li>1.硬件中断产生  Ctrl+C</li><li>2.程序异常   SIGFPE   SIGSEGV  </li><li>3.软件条件产生<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line">kill(getpid(),SIGINT);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">()</span></span>;   </span><br><span class="line">raise(SIGTERM);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">sigqueue</span><br><span class="line">alarm(<span class="number">3</span>); <span class="comment">// 在3秒后向进程发送SIGALRM信号，返回值会取消上一次的定时器，并且返回上一次定时器剩余时间</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心转储（core dump）</strong>：<br>保存当前程序运行的数据以及调用栈信息，用于错误原因定位调试。如果程序运行出现错误，可以直接通过core文件来gdb调试（有些错误可能偶然发生）  coredump默认关闭：隐私安全/资源占用   </p><p><strong>信号的注册：</strong><br>pcb中有一个信号结构体,信号注册/进程发送信号，就是修改这个进程pcb中关于信号的pending位图，将相应的信号为置1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">sigset_t</span> pending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号的阻塞</strong>：暂时不处理信号（阻止信号的递达），并不是不接收信号,<br>pcb中还有一个信号位图block，要阻止一个信号就是修改pcb中关于信号的<code>block</code>位图，将相应的信号位置1，这个位置就像是一个备注说明如果接收到这<br>个信号暂时不处理   </p><p>信号未决：这是一种状态，信号从注册成功到信号递达之间   </p><p><strong>信号的注销：</strong><br>就是从<code>pending</code>集合中将即将处理的信号相应位置0（从pcb的<code>pending</code>集合中移除）<br>非可靠信号注册就是将相应pending位图置1，然后添加一个<code>sigqueue</code>结构到链表中，之后如果有相应信号到来，一看位图已经            置1那么就不做任何操作，意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了！！！   </p><blockquote><p>可靠信号就是不管有没有注册都要置1，并且添加结点到链表中，所以不会丢信号。<br>非可靠注销就是删除链表结点，相应位图置0.<br>可靠信号删除结点，判断是否有相同信号结点，如果没有则位图置0，如果有则置1；</p></blockquote><p><strong>信号的递达（信号的处理）：</strong>  </p><ul><li>默认操作——安装操作系统中对信号事件的既定处理方式   </li><li>忽略操作——直接将信号丢掉   </li><li><p>自定义处理—–用户自定义事件处理方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signal接口</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">    signum：信号的编号</span><br><span class="line">    handler：处理方式</span><br><span class="line">    SIG_IGN 忽略</span><br><span class="line">    SIG_DFL 默认</span><br></pre></td></tr></table></figure></li></ul><p><strong>信号的捕捉流程：</strong><br> 信号并不是立即处理，而是选择一个合适的时机处理，合适的时机就是当前程序从==内核态==切换到==用户态==的时候<br>程序如何从内核态切换到用户态：发起系统调用，程序异常，中断时<br>信号是当我们发起系统调用/程序异常/中断当前程序从用户态切换到内核态，去处理这些事情，处理完毕后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有，就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕后再次返回内核态，判断如果没有信号要处理了就调用<code>sys_sigreturn</code>返回用户态（我们程序之前的运行位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sigaddset</span><br><span class="line">sigdelst</span><br><span class="line">sigfillset</span><br><span class="line">sigprocmask信号阻塞接口，阻塞函数，向block添加信号</span><br><span class="line">sigismember </span><br><span class="line">sigpending</span><br></pre></td></tr></table></figure><p>struct sigqueue</p><p>操作系统如何通知父进程说子进程退出了？<br>信号：SIGCHLD -17号信号<br>用户自定义信号：SIGCHLD -17处理方式，相当于提前告诉进程，当接收到这个信号时使用waitpid，这样就不用一直等待 </p><h4 id="共享内存（shared-memory）"><a href="#共享内存（shared-memory）" class="headerlink" title="共享内存（shared memory）"></a>共享内存（shared memory）</h4><p>是进程间通信速度最快的方式<br>其它的进程间通信方式，都会涉及到将用户空间的数据拷贝到内核空间（因为公共缓冲区都在内核空间），这是两步操作（拷入和拷出）<br>而共享内存的原理是多个进程将同一块物理内存映射到自己的虚拟地址空间，以这种方式实现数据共享，操作这个虚拟地址就是操作这个物理内存，相较于其它通信方式，少了两步用户空间和内核空间的拷贝过程，因此速度最快<br>共享内存操作步骤：    共享内存的生命周期随内核<br>1.创建/打开一块共享内存<br>2.将这块共享空间映射到自己的虚拟地址空间<br>3.各种内存操作<br>4.解除映射关系<br>5.删除共享内存  </p><h4 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h4><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。因此被广泛应用于网络通信中。</p><h3 id="进程间通信的实现"><a href="#进程间通信的实现" class="headerlink" title="进程间通信的实现"></a>进程间通信的实现</h3><h4 id="匿名管道通信"><a href="#匿名管道通信" class="headerlink" title="匿名管道通信"></a>匿名管道通信</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个匿名管道的demo</span></span><br><span class="line"><span class="comment"> *      匿名管道操作：</span></span><br><span class="line"><span class="comment"> *          创建：pipe</span></span><br><span class="line"><span class="comment"> *          读写：read write</span></span><br><span class="line"><span class="comment"> *      匿名管道仅能用于具有亲缘关系的进程间通信</span></span><br><span class="line"><span class="comment"> *      创建匿名管道必须在创建子进程之前，否则子进程将无法复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程 读</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        read(pipefd[<span class="number">0</span>], buff, <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%s\n"</span>, buff);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程 写</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> *ptr = <span class="string">"hello world"</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        write(pipefd[<span class="number">1</span>], ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名管道通信"><a href="#命名管道通信" class="headerlink" title="命名管道通信"></a>命名管道通信</h4><p>这是一个命名管道的实现实例，实现两个进程聊天功能<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(file, <span class="number">0664</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fifo exist!!\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open fifo success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0x00</span>, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = read(fd, buff, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer say:%s\n"</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="管道符实现命令"><a href="#管道符实现命令" class="headerlink" title="管道符实现命令"></a>管道符实现命令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个实现管道符的demo</span></span><br><span class="line"><span class="comment"> *  命令：ps -ef |grep ssh</span></span><br><span class="line"><span class="comment"> *  一个进程运行ps程序，一个进程运行grep程序</span></span><br><span class="line"><span class="comment"> *  ps程序就需要将结果通过匿名管道传递给grep程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程运行grep程序处理ps的结果（从管道读数据）</span></span><br><span class="line">        dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/grep"</span>, <span class="string">"grep"</span>, <span class="string">"ssh"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程运行ps程序，将结果写入管道</span></span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        execl(<span class="string">"/bin/ps"</span>, <span class="string">"ps"</span>, <span class="string">"-ef"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一块共享内存的demo，共享数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x01234567</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int shmget(key_t key, size_t size, int shmflg);</span></span><br><span class="line">    <span class="comment">//  key：共享内存在系统中的标识啊</span></span><br><span class="line">    <span class="comment">//      ftok这个接口可以通过一个文件计算出一个key值</span></span><br><span class="line">    <span class="comment">//  size：共享内存大小</span></span><br><span class="line">    <span class="comment">//  shmflg：IPC_CREAT 创建|权限</span></span><br><span class="line">    <span class="comment">//  返回值：共享内存的操作句柄</span></span><br><span class="line">    shmid = shmget(IPC_KEY, <span class="number">32</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmget error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建的这个共享内存无法直接操作，因为我们只能操作虚拟地址空间</span></span><br><span class="line">    <span class="comment">//中的地址，因此第二步就是将共享内存映射到虚拟地址空间，让我们</span></span><br><span class="line">    <span class="comment">//能够通过虚拟地址来访问这块内存</span></span><br><span class="line">    <span class="comment">//void *shmat(int shmid, const void *shmaddr, int shmflg);</span></span><br><span class="line">    <span class="comment">//  shmid:  共享内存句柄</span></span><br><span class="line">    <span class="comment">//  shmaddr：映射首地址（通常置空）</span></span><br><span class="line">    <span class="comment">//  shmflg：</span></span><br><span class="line">    <span class="comment">//      SHM_RDONLY  只读 否则可读可写</span></span><br><span class="line">    <span class="comment">//  返回：映射到虚拟地址空间的首地址 失败：(void*)-1</span></span><br><span class="line">    <span class="keyword">void</span> *shm_start = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmat error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while(1) &#123;</span></span><br><span class="line"><span class="comment">        sprintf(shm_start, "%s---%d\n", "吃什么呢??", i++);</span></span><br><span class="line"><span class="comment">        sleep(1);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">//int shmdt(const void *shmaddr);</span></span><br><span class="line">    <span class="comment">//  解除共享内存在虚拟地址空间中的映射关系</span></span><br><span class="line">    <span class="comment">//  shmaddr: 映射的首地址</span></span><br><span class="line">    <span class="comment">//  返回值 成功：0  失败：-1</span></span><br><span class="line">    shmdt(shm_start);</span><br><span class="line">    <span class="comment">//int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span></span><br><span class="line">    <span class="comment">//  cmd:</span></span><br><span class="line">    <span class="comment">//      IPC_RMID    删除共享内存</span></span><br><span class="line">    <span class="comment">//  buf：存放获取到的共享内存信息</span></span><br><span class="line">    <span class="comment">//  删除共享内存（并不会立即删除，会判断映射链接数是否为0）</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  这是一个演示signal接口修改信号处理方式的demo</span></span><br><span class="line"><span class="comment"> *  信号的处理方式有三种：</span></span><br><span class="line"><span class="comment"> *      忽略</span></span><br><span class="line"><span class="comment"> *      默认</span></span><br><span class="line"><span class="comment"> *      自定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    b++;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv signo:%d--%d\n"</span>, signo, c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//sighandler_t signal(int signum, sighandler_t handler);</span></span><br><span class="line">    <span class="comment">//  signum: 信号的编号</span></span><br><span class="line">    <span class="comment">//  handler：   处理方式</span></span><br><span class="line">    <span class="comment">//      SIG_IGN 忽略</span></span><br><span class="line">    <span class="comment">//      SIG_DFL 默认</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGINT, sigcb);</span><br><span class="line">    signal(SIGQUIT, sigcb);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        printf("-----------\n");</span></span><br><span class="line"><span class="comment">        kill(getpid(), SIGINT);</span></span><br><span class="line"><span class="comment">        if (++i == 3) &#123;</span></span><br><span class="line"><span class="comment">            signal(SIGINT, SIG_DFL);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sigcb(SIGQUIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="僵尸进程的避免"><a href="#僵尸进程的避免" class="headerlink" title="僵尸进程的避免"></a>僵尸进程的避免</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*僵尸进程的避免：</span></span><br><span class="line"><span class="comment"> *  僵尸进程是子进程先于父进程退出，操作系统会通知父进程说你的子进</span></span><br><span class="line"><span class="comment"> *  程挂了，你去收尸吧，但是父进程没有管，所以子进程死不瞑目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  操作系统如何通知父进程说子进程退出呢？</span></span><br><span class="line"><span class="comment"> *      信号：SIGCHLD -17号信号</span></span><br><span class="line"><span class="comment"> *  以前因为没有学信号，因此我们避免产生僵尸进程，只能让父进程一直</span></span><br><span class="line"><span class="comment"> *  等待子进程的退出（因为实在是不知道子进程到底什么时候退出，），</span></span><br><span class="line"><span class="comment"> *  浪费了父进程资源，</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  现在学了信号完全可以这样做：</span></span><br><span class="line"><span class="comment"> *      自定义信号：SIGCHLD的处理方式，相当于提前告诉进程，当接收到</span></span><br><span class="line"><span class="comment"> *      这个信号的时候使用waitpid，这样就不用一直等了；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用非阻塞的循环来处理SIGCHLD信号</span></span><br><span class="line">    <span class="comment">//因为SIGCHLD信号不是可靠信号，有可能丢失</span></span><br><span class="line">    <span class="comment">//因此就有可能漏掉僵尸子进程没有处理，</span></span><br><span class="line">    <span class="comment">//所以一旦接收到信号就处理到不能处理为止</span></span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"have child exit!!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGCHLD, sigcb);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组的最小数字</title>
      <link href="/2018/12/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2018/12/08/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>咋眼一看这题，很简单啊，就一次遍历找到最小值就可以了啊，那答案就很简单。如下给出一般解决方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;rotateArray.size()<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i] &gt; rotateArray[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这个题目时我们应该更加进一步去思考该题，这个题难道就这么简单？其实不然，当我们控制其时间复杂度时，我们可以思考另外一种方式来解决，如下给出思路：   </p><p>我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。<br> 我们试着用<strong>二分查找法</strong>的思路在寻找这个最小的元素。<br>首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。<br>接着我们得到处在数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。<br>我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。<br>我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的两个指针，去得到和比较新的中间元素，循环下去。<br>按照上述的思路，我们的第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最后第一个指针将指向前面子数组的最后一个元素，而第二个指针会指向后面子数组的第一个元素。<br>也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rotateArray.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[begin]&lt;rotateArray[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(end - begin == <span class="number">1</span>)&#123;</span><br><span class="line">                middle = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[middle] &gt;= rotateArray[begin])</span><br><span class="line">            &#123;</span><br><span class="line">                begin = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[middle] &lt;= rotateArray[begin])&#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> rotateArray[middle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之线程</title>
      <link href="/2018/12/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/12/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p><strong>回顾进程</strong><br>在介绍线程之前，我们先来回顾下进程，进程的定义就是指一个具有独立功能的程序在某个数据集上的一次动态执行的过程，是系统进程资源分配和调度的基本单元。 一次任务的运行可以并发激活多个进程，这些进程相互合作完成该任务的一个最终目标。 操作系统对进程的描述：PCB（进程控制块）Linux下的进程描述——task_struct。   </p><p><strong>那么线程是什么呢？</strong>   </p><ul><li>线程是进程中的一条执行流，Linux下的线程是用进程的PCB模拟的，所以Linux下的线程也叫轻量级进程。 <strong>进程是资源分配的基本单位,</strong> 那么<strong>线程就是CPU调度的基本单位。</strong> </li><li>一个进程至少有一个线程，因此我们的进程其实就是线程组。进程id = 线程组id，所以才说Linux下的进程是线程组，资源分配的基本单位，并且进程中的线程共享大部分进程的资源。</li><li>Linux下的线程共用进程的虚拟地址空间，与进程内的其他线程共享进程的资源,共享代码段，数据段。</li><li>文件描述符表，信号处理方式，工作目录用户id</li><li>线程不仅共享进程的这些资源，并且还独自有一些资源：栈，上下文数据。</li></ul><p><strong>有了进程为什么还要线程呢？</strong><br>线程的优缺点正好说明了我们操作系统为什么还要线程。   </p><blockquote><p>优点：</p><ul><li>线程的创建和销毁成本更低。</li><li>线程的调度切换成本也会更低</li><li>线程间通信更加方便</li><li>线程执行的力度更加细致<br>缺点 </li><li>缺乏访问控制：进程是访问的基本粒度，在一个线程中调用可能会对整个进程造成影响</li><li>多个线程对临界资源进行操作时会造成数据混乱</li><li>性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享一个处理器。如果密集型线程数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加额外的同步和调度开销，而可用的资源不变。</li><li>调试难度大大提高：编写与调试一个多线程程序比单线程程序困难的多。</li></ul></blockquote><p>即便是线程有一些缺点，但它的作用依然非常强大，任然引用与一些项目中。</p><p>进程的一些特征：<br>我们知道，进程有进程的标识符pid，那么线程也有自己的标识符tid</p><h3 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h3><p>1.pthread_create函数<br>功能：创建线程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line">    函数参数解释：</span><br><span class="line">      <span class="keyword">pthread_t</span> *tid：一个进程内的各个线程是由线程ID标识的，如果新线程创建成功，返回tid指针。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr：每个线程有多个属性，包括优先级、初始栈大小、是否是一个守护线程等等。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *)：线程启动函数，线程从调用这个函数开始，或显示结束（调用pthread_exit()），或隐式结束（让该函数返回）。</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *arg：线程执行func函数的传递参数。</span><br></pre></td></tr></table></figure></p><p>2.pthread_join函数 功能：等待一个线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line">      <span class="keyword">void</span> **status：二级指针，如果status指针非空，那么所等待线程的返回值将存放在status指向的位置。</span><br></pre></td></tr></table></figure></p><p>3.pthread_self函数  功能：返回线程ID<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      跟进程比较，相当于getpid。</span><br></pre></td></tr></table></figure></p><p>4.pthread_detach函数 功能：线程分离<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;　　</span><br><span class="line">      线程或者是可汇合的（joinable），或者是脱离的（detach）。当可汇合的线程终止时，线程ID和退出状态将保留，知道另外一个线程调用pthread_join。脱离的线程终止时，释放所有的资源，因此我们不能等待它终止。若要一个线程知道另一个线程的终止时间，我们就要保留第二个线程的可汇合性。</span><br></pre></td></tr></table></figure></p><p>5.pthread_exit函数  功能：线程终止<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> **status)</span></span>;　　</span><br><span class="line">      若线程未脱离，那么它的线程ID和退出状态将保留到另外一个线程调用pthread_join为止。</span><br></pre></td></tr></table></figure></p><p>下面我们演示一个线程的创建<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> *tid = (<span class="keyword">pthread_t</span>*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child~~~%p\n"</span>, *tid);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//void pthread_exit(void *retval);</span></span><br><span class="line">        <span class="comment">//用于退出自己，可以返回一个数据</span></span><br><span class="line">        <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//演示多个线程的并行</span></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="comment">//int pthread_create(pthread_t *thread, pthread_attr_t *attr,</span></span><br><span class="line">    <span class="comment">//  void *(*start_routine) (void *), void *arg);</span></span><br><span class="line">    <span class="comment">//  thread: 用于获取线程id（用户态的线程id）</span></span><br><span class="line">    <span class="comment">//  attr：  设置线程属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//  start_routine：线程入口函数，线程所运行的代码</span></span><br><span class="line">    <span class="comment">//  arg：   线程入口函数的参数</span></span><br><span class="line">    <span class="comment">//  返回值：成功：0     失败：非0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)&amp;tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cancel(tid);  <span class="comment">//用于取消标识符为tid线程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//pthread_t pthread_self(void);</span></span><br><span class="line">        <span class="comment">//获取线程自身的线程id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am main~~~~!%d---%p\n"</span>, pid, pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个线程分离演示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int pthread_detach(pthread_t thread);</span></span><br><span class="line">    <span class="comment">//  分离指定的线程，被分离的线程退出时自动被回收资源</span></span><br><span class="line">    <span class="comment">//  因为资源立即被回收，所以不会保存返回值，也就无法被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定要分离的线程id</span></span><br><span class="line">    <span class="comment">//pthread_t pthread_self(void)</span></span><br><span class="line">    <span class="comment">//  获取自身线程 id</span></span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">"laozaotai!!\n"</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line">    <span class="comment">//这是一个阻塞函数，如果线程没有退出就一直等待</span></span><br><span class="line">    <span class="comment">//这里等待的线程必须是处于joinable属性才可以被等待</span></span><br><span class="line">    <span class="comment">//  thread: 指定等待的线程id</span></span><br><span class="line">    <span class="comment">//  retval：获取线程的退出返回值</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="keyword">if</span> (err == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread is detached!!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child thread:%s\n"</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>一个线程的作用不大，但是一堆线程能干大事，了解王者荣耀的人可能会知道，王者荣耀采用了多线程开发技术，多线程模式，这个模式的作用可以让玩家在团战中帧率更高，打起来更加的流畅，这就是多线程的一个好处。   </p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>因为线程是CPU调度的基本单位，因此多个线程就有可能同时争抢临界资源，那么这种情况就有可能导致数据的二义性。打个比方：当两个线程同时向一个文件修改数据时，那么这个文件的数据到底让那个线程修改？这就是一个线程安全问题。</p><p>为了解决线程安全问题，我们引入了线程的同步与互斥   </p><ul><li><p>互斥：保证数据同一时间唯一的访问，那么我们就可以用一个锁来锁住当前线程，不让其它线程进行访问，即互斥锁   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init  <span class="comment">//初始化   </span></span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock   </span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock </span><br><span class="line">pthread_mutex_timedlock <span class="comment">//指定一段时间内获取锁</span></span><br></pre></td></tr></table></figure></li><li><p>死锁：在使用互斥锁的同时，有可能会发生死锁，在前面有关于<a href="https://LiuZiQiao.github.io/2018/11/28/Linux下的死锁/">死锁问题</a>的文章,这里就不做赘述了</p></li><li><p>同步：保证对临界资源访问的时序性，即我们需要条件变量通知线程或等待线程，满足操作条件，才可以操作，不满足则需要等待，而条件满足就需要其它线程修改条件，并且通知一下等待的进程    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init<span class="comment">//初始化</span></span><br><span class="line">pthread_cond_destroy</span><br><span class="line">pthread_cond_broadcast  <span class="comment">//唤醒多个线程，广播唤醒</span></span><br><span class="line">pthread_cond_wait<span class="comment">//等待</span></span><br><span class="line">pthread_cond_timedwait</span><br><span class="line">pthread_cond_signal  <span class="comment">// 唤醒第一个等待的线程，通知一个线</span></span><br></pre></td></tr></table></figure></li></ul><p>下面演示一个互斥锁使用场景，抢票<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">yellow_cow</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line">        <span class="comment">//lock 阻塞加锁，trylock 非阻塞加锁，timedlock 限时阻塞加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"cow %d get ticket:%d\n"</span>, id, ticket);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在任何有可能退出的地方都必须在退出前解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">4</span>, i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  互斥锁变量的初始化</span></span><br><span class="line">    <span class="comment">//int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span></span><br><span class="line">    <span class="comment">//  const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line">    <span class="comment">//  这种初始化，在使用结束后必须要释放</span></span><br><span class="line">    <span class="comment">//  mutex:  互斥锁变量</span></span><br><span class="line">    <span class="comment">//  attr：  属性，通常置NULL</span></span><br><span class="line">    <span class="comment">//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,yellow_cow,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line">    <span class="comment">//  销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim中Ctrl+s问题</title>
      <link href="/2018/12/03/Ctrl-s%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/03/Ctrl-s%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20181203234814813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br>习惯了在IDE环境下写代码而突然换到VIM中的人看过来，这是需要注意的坑，我们习惯在VIM中写完进行<code>CTRL + S</code>进行保存，然后就卡住不动了，你最有可能的操作就是关闭当前打开的VIM，但是关闭后我们的代码就没有了，哈哈，刚写的代码没了你是什么心情，我就是一遍一遍的踩到这个坑才研究了下<code>CTRL + S</code>在VIM中的作用，其实在VIM中<code>CTRL + S</code>是锁住的意思，锁住当前页面，我们用<code>CTRL + q</code>解除就可以了，这下你就不会在傻乎乎的关闭了。<br>q解除就可以了，这下你就不会在傻乎乎的关闭了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串替换</title>
      <link href="/2018/12/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/"/>
      <url>/2018/12/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。</p><p>给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。</p><p>测试样例：</p><blockquote><p>“A%sC%sE”,7,[‘B’,’D’,’F’]<br>返回：”ABCDEF”</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>思路：定义一个新的字符串来接收返回的字符串，接收过程中将%s去掉即可。话不多说，上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">formatString</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; arg, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">string</span> strRet;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;A.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'%'</span> &amp;&amp; A[i+<span class="number">1</span>] == <span class="string">'s'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               strRet += arg[index++];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                strRet += A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;m;++index)</span><br><span class="line">        &#123;</span><br><span class="line">            strRet += arg[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信红包</title>
      <link href="/2018/12/02/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85/"/>
      <url>/2018/12/02/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</p><p>给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。</p><p>若没有金额超过总数的一半，返回0。</p><p>测试样例：</p><blockquote><p>[1,2,3,2,2],5<br>返回：2</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>方法一：C++中学过map的人可能做这个题会非常简单，利用map键值对的巧妙来对数据的处理。以下就是根据map<int,int>的第一个int用来存储被计数的值，右边来存放出现的个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m[gifts[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second &gt; n/<span class="number">2</span>) <span class="comment">//second就是m的第二个参数，即第二个int</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> e.first;  <span class="comment">//同理，first是第一个int了</span></span><br><span class="line"></span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></int,int></p><p>方法二：当然，非常了解C++库中函数的人可能会想到一个非常简单的方法，利用STL中的算法count函数计数功能，三两行代码就能解决这个问题。利用出现次数超过总元素个数一半知道这个数一定会是中位数，当然，前提是这个数组有序。我们看下面的具体代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sort(gifts.begin(),gifts.end());</span><br><span class="line">        <span class="keyword">int</span> ret = count(gifts.begin(),gifts.end(),gifts[n/<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; n/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> gifts[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法三：在上面两种特殊方式做出的基础上，我们思考了用普通的算法来求解该问题，我们的思路是首先对数组里的数进行一个判断，找出出现次数最多的那个数，然后再对它进行计数判断。以下就是具体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gifts, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gift = gifts[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                gift = gifts[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == gift)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下死锁的产生，预防，避免，检测及解除</title>
      <link href="/2018/11/28/Linux%E4%B8%8B%E7%9A%84%E6%AD%BB%E9%94%81/"/>
      <url>/2018/11/28/Linux%E4%B8%8B%E7%9A%84%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h3><p><img src="https://img-blog.csdnimg.cn/2018112821520271.png" alt="1"><br>所谓死锁就是指在多道程序系统中，一组进程中的每个进程都无期限的等待被该组进程中的另一个进程所占有且永远不会被释放的资源，这种现象称系统处于死锁状态，简称死锁。处于死锁状态的进程成为死锁进程。 如上面的图。    </p><p>　　系统发生死锁会大量浪费系统资源甚至会导致整个系统崩溃</p><h4 id="死锁的产生的原因"><a href="#死锁的产生的原因" class="headerlink" title="死锁的产生的原因"></a>死锁的产生的原因</h4><p>产生死锁的原因主要有两个：一是竞争资源，系统提供的资源有限，不能满足每个进程的需求；二是多道程序运行时，进程的推进顺序不合理。<br><strong>这里的资源我们作如下解释</strong><br>系统资源分为两类：<strong>永久性资源</strong>(可重生资源)，是指那些可供进程重复利用，长期存在的资源，如内存，CPU等硬件资源，以及数据集文件，共享程序代码等软件资源。<strong>临时性资源</strong>(消耗性资源)，是指由某个进程产生，只为另一个进程使用一次，或经过短暂时间后便不可再使用资源，如I/O和时钟中断，消息等。<br>    <strong>两种资源都可能导致死锁。</strong></p><h4 id="死锁的产生必要条件"><a href="#死锁的产生必要条件" class="headerlink" title="死锁的产生必要条件"></a>死锁的产生必要条件</h4><p>对于永久性资源，产生死锁有以下四个必要条件：<br>1.互斥条件:进程独占所分配的资源且排斥其他进程使用。进程互斥使用资源，即任意时刻一个进程被进程使用，其他进程申请一个正在被占有的资源时，申请者要等待直至资源被占有者释放。<br>2.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由使用者自愿释放。<br>3.请求与保持：进程已经得到至少一个资源时，又提出新的资源请求，而该资源又被其他进程所占有，此时进程会等待直至得到所需资源，在等待期间会继续占有已经得到的资源。<br>4.循环等待条件：在发生死锁时，必然存在一个进程等待队列p1,p2,p3,…,pn，其中p1等待p2占有的资源，p2等待p3占有的资源，…， pn等待p1占有的资源，形成一个进程等待环路。环路中每个进程已占有的资源同时被另一个进程所申请，即前一个进程占有后一个进程所申请的资源。</p><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>解决死锁方法可分为两中：一是不让死锁发生；二是等死锁发生后再解决，具体有以下四种方法</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>通过破坏产生死锁的必要条件（除第一个互斥条件外的其他条件）来防止死锁发生。此方法会导致系统资源利用率过低。</p><p>1.破坏“不可剥夺”条件<br>在允许进程动态申请资源的前提下做出如下规定：一个进程在申请新资源的要求不能立即得到满足，该进程进入等待状态。而处于等待状态下的进程的全部资源可以被他人剥夺，被剥夺的资源重新放到资源表中。</p><p>　　该方法适合那些状态是容易保存和恢复的资源，例如，CPU、内存等。但此方法实现起来较为复杂，且代价很大。因为一个资源在使用一段时间后被强制剥夺会造成前阶段工作失效，甚至可能出现某个进程反复申请和释放资源的情况，使得进程执行无限期推迟，还增加了系统开销，延长了进程的周转时间，降低了系统的吞吐量和性能。    </p><p>2.破坏“请求和保持”条件<br>实现这一操作可以用两种方法。<br>方法一：每个进程在执行前必须申请它所需的全部资源，仅当系统能满足进程的资源申请并把资源一次性分配给进程后，进程才能执行。这是静态资源分配策略。这种方法的缺点是会严重浪费系统资源，降低资源利用率。</p><p>方法二：仅当进程没有占有资源时才允许他去申请资源，如果进程已占用了某些资源而又要申请新的资源，那他必须先归还所占有的资源再申请新的资源。   </p><p>3.破坏“循环等待”条件<br>　采用资源有序分配策略，基本思想是将系统中所有的资源顺序编号，一般原则是紧缺、稀有的资源编号较大。进程申请资源时，必须严格按照编号顺序进行，否则不予分配。即一个进程只有得到编号较小的资源后，才能申请编号较大的资源。释放资源时应先释放编号较大的资源。<br>　　此方法硬性规定申请资源，会给用户编程带来限制，增加了资源使用者的不便；此外如何合理的编号也是一件让人头疼的事。如有进程违反了规定也会造成死锁。 </p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>上述几种死锁预防策略增加了较强的限制条件，从而实现较为简单，但严重影响了系统性能，所以在实际应用中这几种方法使用少之又少，更好地方法是死锁避免。</p><p>　　死锁避免的基本思想：系统对进程发出的每个系统能满足的资源申请进行动态检测，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，反之予以分配。</p><ol><li>安全与不安全状态<br>　　由于避免死锁策略中允许进程动态地申请资源，所以系统要提供某种方法，在分配资源前，先分析资源分配的安全性。当估计到可能有死锁发生时及时设法避免。<br>　　如果操作系统能保证所有进程能在有限时间内获得需要的全部资源，则称系统处于“安全状态”，否则就是不安全的。<br>　　所谓的安全状态是指，如果系统的所有进程构成了一个安全序列，则系统处于安全状态。那么什么又是安全序列呢？如果一个进程序列：p1,p2,…,pnp1,p2,…,pn，对于其中每个进程 pi(1&lt;=i&lt;=n)pi(1&lt;=i&lt;=n)，它以后尚需的资源总量不超过系统当前剩余资源量与所有进程当前占有资源总量之和，那么这个进程序列便称为安全序列。</li></ol><p>2.银行家算法<br>　　银行家算法是最经典的死锁避免算法之一。把系统比作银行家，系统资源比作周转资金，申请资源的进程比作向银行家带款的客户。那么银行家就要保证两件事：一是银行家能贷款给若干客户，满足客户对资金的需求；二是银行家可以安全地收回其全部贷款而不至于破产。为此，银行家做出如下规定：</p><p>当一个客户对资金的最大需求量不超过银行家现有资金总量时才可以接纳该客户。</p><p>客户可以分期贷款，但贷款总量不能超过该客户对资金的最大需求量。</p><p>当银行家现有资金不能满足客户尚需的贷款额度时，对客户的贷款可延迟支付，但必须保证客户在有限的时间内得到贷款。</p><p>当客户得到所需的全部资金后，必须在有限的时间内归还所有资金。</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>上述的死锁避免和死锁预防都是以牺牲系统效率和浪费资源为代价，不符合我国传统勤俭节约的美德，我们要采取更好地方法——系统为进程分配资源时，不采取任何限制措施来保证系统不进入死锁状态，即允许死锁发生，但系统会不断监督进程的进展路径，判断死锁是否真的发生，一旦判断发生死锁，则采取专门的措施解决死锁，并以最小的代价使整个系统恢复正常，这就是死锁检测和解除。</p><p>　　死锁检测的实质是确定是否存在“循环等待”条件，检测算法确定死锁发生并识别出与死锁有关的进程和资源。下面介绍一种检测机制：</p><p>为每个进程和资源指定唯一编号。<br>设置一张资源分配表，表中包含“资源号”和占有该资源的“进程号”两项。资源分配表记录了每个资源正在被那进程占有。<br>设置一张进程等待表，表中包含“进程号”和该进程所等待的“资源号”两项。<br>死锁检测算法：当任一进程申请一个已被其他进程占有的资源时，通过反复查找资源分配表和进程等待表 ，来确定该进程对这个资源的申请是否会导致环路，若是，便确定出现死锁。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>要解除死锁就要剥夺资源，那就要考虑如下几个问题：</p><p>选择牺牲一个进程，即要剥夺哪个进程的哪些资源？</p><p>被牺牲的进程重新运行或回退到某一点继续运行。</p><p>如何保证不发生“饿死现象”，即如何保证不会总是剥夺同一个进程的资源，从而导致该进程处于“饥饿状态”。</p><p>“最小代价”，即最经济合算的算法，使得进程回退带来的开销最小。要考虑到如下几个因素：</p><ul><li>进程优先级</li><li>进程运行了多久？距离完成任务还要多久？</li><li>该进程使用的资源的种类和数目，这些资源剥夺难度如何？</li><li>为完成该进程还需要多少资源？<br>有多少进程要被撤销？</li><li>该进程被重新启动的次数？</li></ul><p>死锁解除法归为两大类。</p><ul><li>剥夺资源。<br>　　使用挂起/激活机制挂起一些进程，剥夺他们的资源给死锁进程，用来解除死锁，等死锁解除后再激活被挂起的资源。剥夺的顺序以花费最小资源数为依据。每次剥夺后需再次调用死锁检测算法。被重新激活的挂起进程必须重新申请资源。为安全的释放资源，该进程必须返回到分配资源前的某一点。常用方法有：</li></ul><p>还原算法，恢复计算结果和状态。<br>设置检查点，用来恢复分配前的状态。</p><ul><li>撤销进程。（简单粗暴）<br>　　撤销死锁进程，把它们占有的资源分配给死锁进程，直至死锁结束。可以撤销所有死锁进程或逐个撤销死锁进程，每撤销就检测死锁是否存在，若不存在就停止撤销。</li></ul><p>衡量撤销代价的标准： </p><ol><li>被撤销进程的优先数 </li><li>不同类型的进程的撤销代价 </li><li>重启进程并运行到当前撤销点所需的代价</li></ol><p>　　由于衡量标准过多，为了简化，把系统的资源分成四个等级，对于不同级别下出现的死锁，采取不同的方法。</p><p>内部资源：由操作系统使用，PCB表等——利用资源编号预防死锁。</p><p>内存：由用户使用——采用抢占式预防。</p><p>作业资源：可分配的设备和文件——可采用死锁避免措施。</p><p>对换空间：每个用户作业在辅助存储器上的空间——采用预先分配方式。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于MVC用java实现的通用系统后端</title>
      <link href="/2018/11/25/%E5%9F%BA%E4%BA%8EMVC%E7%94%A8java%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%9A%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF/"/>
      <url>/2018/11/25/%E5%9F%BA%E4%BA%8EMVC%E7%94%A8java%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%9A%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装教程</title>
      <link href="/2018/11/15/mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/15/mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>MySQL安装有两种方式，一种是免安装直接下载安装包解压配置即可使用，另外一种就是下载安装</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">MySQL下载地址</a><br><a href="https://pan.baidu.com/s/13KGXf1UwLSfxs_-x7UGdqA" target="_blank" rel="noopener">连接工具下载</a>    <strong>提取码：fquf</strong> </p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>具体安装见<br><a href="https://blog.csdn.net/qq_39478237/article/details/84102513" target="_blank" rel="noopener">https://blog.csdn.net/qq_39478237/article/details/84102513</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决MySQL第一次连接失败</title>
      <link href="/2018/11/15/%E8%A7%A3%E5%86%B3MySQL%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/11/15/%E8%A7%A3%E5%86%B3MySQL%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上一篇讲了MySQL数据库的安装，安装之后我们用Navicat工具连接时可能会出现以下这种情况，就这种情况给出了解决办法</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>Navicat for MySQL 连接数据库时报错 client dose not support authentication protocol requested by server;consider</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><img src="https://img-blog.csdnimg.cn/20181115123652200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/20181115123816493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></p><p><strong>命令如下</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、use mysql;</span><br><span class="line">2、alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;********&apos;;</span><br><span class="line">3、flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++浅谈new delete</title>
      <link href="/2018/11/11/C++%E6%B5%85%E8%B0%88new%E3%80%81delete/"/>
      <url>/2018/11/11/C++%E6%B5%85%E8%B0%88new%E3%80%81delete/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在C语言的学习中，我用知道动态内存开辟是使用malloc函数来进行开辟一段连续的空间，释放则是用free来进行释放，而学习了C++我们知道，在C++中开辟内存是使用new，释放则也与之对应的delete，下面我们就来说说malloc/free与new/delete之间的区别以及底层实现原理</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在C语言库中函数原型如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="malloc-free使用"><a href="#malloc-free使用" class="headerlink" title="malloc/free使用"></a>malloc/free使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));     <span class="comment">//指向整型的指针p指向一个大小为100字节的内存的地址</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)                           <span class="comment">//使用之前一定要判断释放申请成功</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"application memory error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);    <span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>与之还以两个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><p>calloc 函数和malloc的区别就是申请好空间会初始化成0，另外calloc函数在使用时需要传入元素个数和元素字节大小</p><p>recalloc函数用于修改一个原先已经分配好的内存块的大小，可以使一块内存扩大或缩小，如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，且不进行初始化。如果缩小内存，则原来内存块从尾部进行删减。如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。</p><h3 id="new-delete使用"><a href="#new-delete使用" class="headerlink" title="new/delete使用"></a>new/delete使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针p</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">//对指针p指向的地址的值进行了初始化为0</span></span><br><span class="line"><span class="keyword">int</span> *P = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);<span class="comment">//初始化为1024</span></span><br></pre></td></tr></table></figure><p>　　当动态创建的对象用完后必须释放内存，避免造成内存泄漏，可以用delete来完成，new和delete是成对使用的，如下命令释放p指向的int型对象所占用的内存空间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>C++中允许动态创建const对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  *p=<span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);  <span class="comment">//动态创建的const对象必须进行初始化，并且进行初始化后的值不能再改变。</span></span><br></pre></td></tr></table></figure></p><h4 id="new-delete-使用"><a href="#new-delete-使用" class="headerlink" title="new[]/delete[]使用"></a>new[]/delete[]使用</h4><p>当创建一个动态数组对象和进行内存释放时，执行以下语句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[];               <span class="comment">//指针p所指向的数组未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[n];             <span class="comment">//指针p指向长度为n的数组，未初始化</span></span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[]();            <span class="comment">//指针p所指向的地址初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> [] p;                   <span class="comment">//回收p所指向的数组</span></span><br></pre></td></tr></table></figure></p><h3 id="区别及原理"><a href="#区别及原理" class="headerlink" title="区别及原理"></a>区别及原理</h3><h4 id="new-delete原理"><a href="#new-delete原理" class="headerlink" title="new/delete原理"></a>new/delete原理</h4><p>首先我们查看new/delete底层是如何实现的：<br><img src="https://img-blog.csdnimg.cn/20181122220739123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="1">   </p><p>通过上面的图我们不难看出其实new并不直接开辟空间，它也是通过operator new 来获取内存的，而operator new 实质上还是调用malloc来开辟空间的。同样的道理，delete也不是直接释放空间。</p><h4 id="new-delete-原理"><a href="#new-delete-原理" class="headerlink" title="new[]/delete[]原理"></a>new[]/delete[]原理</h4><p>上面理解了new/delete之后再来看new[]/delete[]也非常容易了，其实原理是一样的，当使用new[]/delete[]也是调用new/delete来实现的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure></p><p>delete[] 实际做了这样几件事：</p><ul><li>一次调用p指向对象数组中的每个对象的析构函数，一共10次</li><li>调用operator delete<a href=""></a>,它将在调用operator delete</li><li>底层free执行operator delete表达式<br><img src="https://img-blog.csdnimg.cn/20181122220840212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2"></li></ul><p><strong>稍作总结</strong>：</p><ol><li>operator new/operator delete，operator new[]/operator delete[],malloc/free等用法一样</li><li>它们只负责分配空间/释放空间，不会调用对象构造函数，析构函数来初始化和清理对象</li><li>实际operator new和operator delete 是对malloc和free的一层封装</li></ol><p><strong>注意点</strong><br>可能你对上面还有些许疑惑，下面的解释可能会解开你的疑惑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array* p = <span class="keyword">new</span> Array[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p>执行这两条语句的时候实际上调用operator                   new<a href="10*sizeof(Array"></a>+4)分配大小为10*sizeof(Array)+4空间，其中多的四个字节空间用于存放N(10)这个数字以便于delete中调用析构函数析构对象（调用析构函数的次数），空间申请好了之后调用构造函数创建对象。delete[] p执行的时候首先取N(10)对象个数，然后调用析构函数析构对象，最后用operator delete[]函数释放空间。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>先来一个问题</strong><br>有了malloc/free为何还要new/delete ？<br>malloc和free无法满足对动态对象的要求：在创建对象的同时自动调用构造函数，对象销毁时自动调用析构函数。由于malloc/free是库函数不是操作符，不在编辑器的权限之内，而C++中需要需要new操作符来自动调用构造函数来申请空间初始化，以及需要一个能够完成清理与释放内存的delete操作符   </p><p>共同点：<br>    malloc/free  new delete都是从堆上申请空间，并且需要用户手动释放<br>不同点：<br>1.malloc和free是函数，new delete是操作符<br>2.malloc申请空间不会初始化，new 可以初始化<br>3.malloc申请空间时需要计算所需的空间大小并传递，new只需要给类型就可以<br>4.mallco申请空间失败时返回NULL，因此在使用时需要进行判空操作 ，new不需要，new需要捕获异常<br>5.malloc返回值是void*，使用时需要进行强转，new不需要，只需要给空间的类型即可<br>6.申请自定义类型对象时，mallco/free只会开辟空间和释放空间，不会调用构造函数与析构函数，而new在申请空间后调用构造函数完成对象初始化，delete释放空间前会调用析构函数完成资源清理<br>7.new/delete比malloc/free效率稍微低些，因此new/delete底层封装了malloc/free</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++函数重载与引用剖析</title>
      <link href="/2018/11/11/C++%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%BC%95%E7%94%A8%E5%89%96%E6%9E%90/"/>
      <url>/2018/11/11/C++%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%BC%95%E7%94%A8%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在介绍重载与引用之前，我们回顾以下C语言中函数，学过C语言我们都知道，定义一个函数可以给参数可以选择不给参数，这取决于我们调用这个函数时使用的功能，然而我们在C++中有一个叫缺省参数的概念。</p><p>缺省参数：声明或定义函数时为函数的参数指定一个默认值，在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参，并且，函数参数是从右开始匹配(printf函数就是从右向左压栈，打印的时候从左向右)</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>首先：重载是在同一作用域内的几个函数名字相同，但形参列表不同，我们称之为函数的重载。例如以下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这些函数接受参数类型不同，但是执行的操作非常相似，当我们调用这些函数的时候，编译器会根据我们传入的实参类型来自动匹配调用函数。</p><p><strong>那么问题来了，在C语言中函数是否能进行重载吗？</strong><br>毋庸置疑，答案是不行的，C语言中函数是不能进行重载的。这是为什么呢？让我们一探究竟。</p><p>从代码的编译到运行，在VC6.0或VS这种编译器下，它是系统直接完成了翻译与链接，直接生成了运行结果。<br>编译器内部完成了翻译部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>预处理   </span><br><span class="line">   <span class="number">1</span>）头文件展开   </span><br><span class="line">   <span class="number">2</span>）宏的替换   </span><br><span class="line">   <span class="number">3</span>）去注释   </span><br><span class="line">   <span class="number">4</span>）条件编译      </span><br><span class="line"><span class="number">2.</span>编译过程：将高级语言转为汇编语言   </span><br><span class="line"><span class="number">3.</span>汇编过程：汇编语言转为二进制程序</span><br></pre></td></tr></table></figure></p><p>链接部分：所引用的数据链接进来<br>比如一个函数的声明如下：<br>void  function(int x,int y)；</p><p>在c语言中，编译器在编译后在库中的名字为_function<br>在c++中，编译器在编译后在库中的名字为_function_int_int</p><p>还有一个函数的声明如下：<br>void function（float x,float y)；<br>在C语言中，编译器在编译后在库中的名字为_function<br>在c++ 中，编译器在编译后在库中的名字为_function_float_float<br>通过以上规律我们发现：<br>在链接时，都是找名字进行链接的,就比如以上两个函数，<br>在C语言中两个的名字一样，就会在链接中报错。<br>在c++ 中它们的名字不一样，所以就不会报错。<br>c++ 中函数名字的修饰规则，将参数的类型增加到最终的名字中，编译期间按照函数类型以及传入的参数类型将函数名修饰，如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?@TestFunc@@YAAA@Z</span><br><span class="line">?@TestFunc@@YANH@Z</span><br><span class="line">?@TestFunc@@YHHH@Z</span><br></pre></td></tr></table></figure></p><p>extern”C”  按照C来编译   </p><p>当然，我们的main函数是不能被重载的啦</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>有的人小时候因为名字太长或者叫起来不太方便就被起过小名或者绰号，这样方便其他人叫，那么我们的C++ 中的引用也是这样来定义引用的，是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><h4 id="引用创建及使用"><a href="#引用创建及使用" class="headerlink" title="引用创建及使用"></a>引用创建及使用</h4><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; r = i;</span><br><span class="line"><span class="keyword">double</span>&amp; s = d;</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"value of i:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"value of reference:"</span>&lt;&lt;r &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">d = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"value of d:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"value of reference:"</span>&lt;&lt;s &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>上面的代码编译执行的结果如下：</p><p>value of i：5<br>value of reference：5<br>value of d：3.14<br>value of reference：3.14</p><p>当引用作为参数来传递参数时，我们如下使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">swap(a,b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>上面的代码执行运行的结果为6 5<br>我们知道，我们在C语言中交换两个变量使用指针来进行两个变量的交换，但上面的引用也完成了这样的功能，他们之间有何区别以及优缺点呢？   </p><h4 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h4><p>先来说说引用底层实现原理<br>指针和引用在底层的处理方式完全一致，引用在底层就是按照指针来处理的<br>下面演变过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;   </span><br><span class="line"><span class="keyword">int</span>&amp; ra = a;   -----&gt; T* <span class="keyword">const</span>   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; cra = a;  ----&gt;  <span class="keyword">const</span>  T* <span class="keyword">const</span></span><br></pre></td></tr></table></figure></p><ul><li>相同点：<br>都是地址的概。<br>指针指向一块内存，它的内容是所指内存的地址；<br>引用是某块内存的别名。 </li><li>不同的：<br>1.指针是一个实体，而引用是一个别名<br>2.引用使用无需解引用，指针使用时需要解引用<br>3.引用只能在定义时被初始化一次，之后不可变；指针可变<br>4.引用没有const，指针有const，const的指针不可变<br>5.”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof”指针”得到的是指针本身(所指向的变量或对象的地址)的大小<br>6.指针可以为空，引用不能为空<br>7.指针和引用自增(++)运算意义不一样   </li></ul><p><strong>最需要注意的地方：当被问到函数传参有几种方式时，我们应该回答两种，值传递和址传递，但是你得分清楚，引用传递才是正真的址传递，而指针传递不是址传递，因为指针也是值，是一个地址但是本身也是一个指针变量值！！！</strong><br>我们还需要注意：如果引用的方式作为函数的返回值类型，不能返回栈上的空间<br>返回的变量的生命周期一定要比函数的周期长<br><strong>优缺点</strong><br>使用引用的好处：<br>1.当传递一对象时，效率明显提高</p><p>2.安全   </p><p>缺点：<br>1.使用时需要初始化   </p><p>2.当引用一个指针时，指针置为空时非常危险</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统之基础IO</title>
      <link href="/2018/11/09/Linux%E5%9F%BA%E7%A1%80IO/"/>
      <url>/2018/11/09/Linux%E5%9F%BA%E7%A1%80IO/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>学过C语言的都知道，在C语言中IO其实就是文件操作，像fopen，fwrite，fread，fseek，fprintf，fclose等都是C语言库函数中的系统调用接口，如下图是常用<br><img src="https://img-blog.csdnimg.cn/20181110112204660.png" alt="1"><br>先回顾下这些标准c库中文件I/O的接口的使用</p><h3 id="回顾C库中的IO"><a href="#回顾C库中的IO" class="headerlink" title="回顾C库中的IO"></a>回顾C库中的IO</h3><blockquote><p>   FILE <em>fopen(const char </em>path, const char <em>mode);<br>    size_t fread(void </em>ptr, size_t size, size_t nmemb, FILE <em>stream);<br>    size_t fwrite(const void </em>ptr, size_t size, size_t nmemb,</p></blockquote><p>它的返回值：文件流指针，这个文件流指针指向的是</p><p><a href="">2</a> </p><table><thead><tr><th>文件流指针</th><th>stdin</th><th>stdout</th><th>stderr</th><th>FILE*</th></tr></thead><tbody><tr><td>文件描述符</td><td>0</td><td>1</td><td>2</td><td>3</td></tr></tbody></table><p>一个进程运行起来之后默认打开了三个文件，关于文件描述符我在后面有介绍<br>下面演示一个C语言库中函数的使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">"./test.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span>  (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fopen error!!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">"apple!!"</span>;</span><br><span class="line">    fwrite(ptr, <span class="built_in">strlen</span>(ptr), <span class="number">1</span>, fp);</span><br><span class="line">    fseek(fp, <span class="number">10</span>, SEEK_END);</span><br><span class="line">    fwrite(ptr, <span class="built_in">strlen</span>(ptr), <span class="number">1</span>, fp);</span><br><span class="line">    </span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fread(buff, <span class="number">1024</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buff:[%s]\n"</span>, buff);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"\n%s-%d-%s\n"</span>, <span class="string">"apple"</span>, <span class="number">3</span>, <span class="string">"i love to eat!!"</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="系统IO"><a href="#系统IO" class="headerlink" title="系统IO"></a>系统IO</h3><p>以下是一些系统调用IO接口</p><pre><code>int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);ssize_t write(int fd, const void *buf, size_t count);int creat(const char *pathname, mode_t mode);off_t lseek(int fd, off_t offset, int whence);//off_t lseek(int fd, off_t offset, int whence);//  fd: 文件描述符//  offset：偏移值//  whence：偏移起始位置//      SEEK_SET    文件起始位置//      SEEK_CUR    当前读写位置//      SEEK_END    文件末尾位置fileno将文件流指针转换成文件描述符fdopen 将文件描述符转换成文件流指针</code></pre><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p><strong>文件描述符是一个数字，那么一个数字是如何描述文件的呢？</strong><br>一个进程要对所有打开的文件进行管理，先将文件描述起来，然后组织管理<br>进程中对文件进程描述的 结构体叫file(struct file)<br>进程使用了一个结构体数组来组织这些描述，而文件的描述符就是这个结构体数组的下标<br>pcb中对文件的描述的一个机构图（file)数组的下标<br>系统调用open返回的是文件描述符：int<br>而c库中fopen返回的是一个文件流指针：FILE*</p><p>文件描述分配符规则：<br>寻找最小下未使用的下标</p><p>==文件描述符fd返回值：正确：非负值（文件描述符） 错误：-1==</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>我们所说的缓冲区（print),用户态的一个缓冲区，是文件流指针自带的fprint，fwrite这些库函数<br>都是先把数据写入到缓冲区中，等缓冲区写满或者一些其他条件满足后才真正写入到文件中，<br>而系统调用没有这个用户态的缓冲区，（是直接写入到文件中）  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      open    close   read    write   lseek</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;   // 文件控制头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line">    <span class="comment">//  pathname:   要打开的文件名</span></span><br><span class="line">    <span class="comment">//  flags：选项标志</span></span><br><span class="line">    <span class="comment">//      O_RDONLY    只读 </span></span><br><span class="line">    <span class="comment">//      O_WRONLY    只写</span></span><br><span class="line">    <span class="comment">//      O_RDWR      读写</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      O_CREAT     文件不存在则创建，存在则打开</span></span><br><span class="line">    <span class="comment">//      O_EXCL      与O_CREAT同用，若文件存在则报错</span></span><br><span class="line">    <span class="comment">//      O_TRUNC     打开文件的同时，清空文件原有内容</span></span><br><span class="line">    <span class="comment">//      O_APPEND    追加</span></span><br><span class="line">    <span class="comment">//  mode:文件权限，用于创建文件的时候</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    fd = open(<span class="string">"./tmp.txt"</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ssize_t write(int fd, const void *buf, size_t count);</span></span><br><span class="line">    <span class="comment">//  fd: 文件描述符</span></span><br><span class="line">    <span class="comment">//  buf：要写入的数据</span></span><br><span class="line">    <span class="comment">//  count：要写入的数据长度</span></span><br><span class="line">    <span class="comment">//  返回值：实际的写入数据长度</span></span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="string">"apple!!\n"</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> wlen = write(fd, ptr, <span class="built_in">strlen</span>(ptr));</span><br><span class="line">    <span class="keyword">if</span> (wlen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"write error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read：返回实际读取到的数据长度</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">ssize_t</span> rlen = read(fd, buff, <span class="number">1024</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rlen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf:[%s]\n"</span>, buff);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h4><p>原理：将原本描述符所对应的下标的文件修改成另外一个文件，描述符没有变，但是真正通过描述符操作的这个文件已经改变了   </p><blockquote><p>int dup2(int oldfd, int newfd);</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  演示文件描述符分配规则的demo</span></span><br><span class="line"><span class="comment"> *      1. 文件描述符是一个数字，并且这个数字是一个结构体数组的下标</span></span><br><span class="line"><span class="comment"> *  分配规则：</span></span><br><span class="line"><span class="comment"> *      寻找最小的未使用的下标</span></span><br><span class="line"><span class="comment"> *  一个进程运行起来之后，默认打开的三个文件：</span></span><br><span class="line"><span class="comment"> *      标准输入    标准输出    标准错误</span></span><br><span class="line"><span class="comment"> *      stdin       stdout      stderr</span></span><br><span class="line"><span class="comment"> *      0           1           2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"./tmp.txt"</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd:%d\n"</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Linux下的文件系统"><a href="#Linux下的文件系统" class="headerlink" title="Linux下的文件系统"></a>Linux下的文件系统</h3><p>linux文件系统是由两层结构构建：第一层是虚拟文件系统（VFS），第二层是各种不同的具体文件系统。</p><p>VFS是把各种具体的文件系统的公共部分抽取出来，形成一个抽象层，是系统内核的一部分。它位于用户程序和具体的文件系统中间。它对用户</p><p>程序提供了标准的文件系统的调用接口，对具体的文件系统，它通过一系列的对不同文件系统公用的函数指针来实际调用具体的文件系统函数，完成实际<br>的各有的操作。任何使用文件系统的程序必须经过这层接口来使用它。通过这种方式，VFS就对用于屏蔽了底层文件系统的实现细节和差异。</p><p>  <img src="https://img-blog.csdnimg.cn/20181110112624493.png" alt="2"></p><p>通过 cat /proc/filesystems命令可以查看系统支持哪些文件系统。</p><p>open是系统调用级别的操作，调用VFS_open  -&gt; 底层的open（包括驱动的open，比如字符设备驱动里面的</p><p>file_opreations里面的open等。联想一下）</p><h4 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h4><p>软硬链接区别：   </p><ul><li>1、可以针对目录创建，硬链接不可</li><li>2、软链接是一个新的文件，而硬链接是源文件的一个别名（跟源文件使用相同的结点inode结点）</li><li>3、软链接可以划分区建立，但是硬链接可以</li><li>4、源文件删除后，软链接找不到，但是硬链接没有影响，仅仅是链接数减一</li><li></li></ul><h4 id="动态库-静态库"><a href="#动态库-静态库" class="headerlink" title="动态库/静态库"></a>动态库/静态库</h4><blockquote><pre><code>  动静态库链接：gcc默认链接方式：动态链接 ---- 链接是动态库静态链接需要加 -static 的gcc链接选项 ---- 链接是静态库如何自己生成一个动态库程序的编译过程：预处理--》编译--》汇编--》链接生成一个库其实就是将所有代码打包起来，最终得到一个库文件</code></pre><p>区别：</p><ul><li>使用静态库时将静态库中代码全部拿过来   </li><li>动态库使用时记录地址信息<pre><code>生成动态库：gcc  -- share test.c -o libtest.so生成静态库：ar cr libtest.a test.c编译选项：-fPIC   ：产生位置无关代码</code></pre></li></ul></blockquote><p>如何链接一个可执行程序：<br>gcc main.c -o main -L./  -ltest   </p><ul><li>-L 用于指定库的查找路径   </li><li>-l 用于指定链接库的名称   </li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="/2018/11/07/Linux%E4%BF%A1%E5%8F%B7/"/>
      <url>/2018/11/07/Linux%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BitMap算法基本操作</title>
      <link href="/2018/11/05/BitMap%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/05/BitMap%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>上篇我们讲了BitMap是如何对数据进行存储的，没看过的可以看一下<a href="https://LiuZiQiao.github.io/2018/11/03/BitMap算法/">【BitMap算法介绍】</a></p><p>这篇我们来讲一下BitMap这个数据结构的代码实现。</p><h3 id="回顾下数据的存储原理"><a href="#回顾下数据的存储原理" class="headerlink" title="回顾下数据的存储原理"></a>回顾下数据的存储原理</h3><p>一个二进制位对应一个非负数n，如果n存在，则对应的二进制位的值为1，否则为0。</p><p>这个时候，我们的第一个问题：</p><p>我们在使用byte,int,short,long等这些数据类型在存储数据的时候，他们最小的都要占用一个字节的内存，也就是8个bit，也就是说，最小的操作单位是8个bit。根本就没有可以一个一个bit位操作的数据类型啊。</p><p>在Java的bitMaP实现中，它采用的是用一个long数据来进行存储的。一个long占用8个字节，即64bit，所以一个long可以存储64个数。例如 arr 是一个long 类型的数组，则 arr[0]可以存 0 ~ 63，arr[1]可以存64 ~127，以此类推。</p><p>不过，我们就采用byte数组的来存吧。一个byte占用一个字节，即8bit，可以存8个数字。</p><p>当然，你要采用long数组来存也可以。在实现上可以说是一样的。</p><p>例如我们要存储(1,3,5,7,8,10)时，他们的内存如下所示。<br><img src="https://img-blog.csdnimg.cn/20181106164623290.png" alt="1"><br>下面我们就来讲讲如何对一个一个位进行操作的。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="如何向bitmap中添加一个数值"><a href="#如何向bitmap中添加一个数值" class="headerlink" title="如何向bitmap中添加一个数值"></a>如何向bitmap中添加一个数值</h4><p>我们先来说说如何在bitmap中如何添加一个数值的问题，例如我们我们要添加n=14。</p><p>这个其实很简单，我们先找到n在arr数组中的下标index，显然index = 1。然后再找到n在arr[index]中的位置position，显然这里position = 6。</p><p>这里还是可以很容易找出index和position的公式的。即</p><p>index = n / 8 = n &gt;&gt; 3。</p><p>position = n % 8 = n &amp; 0x07。</p><p>接下来我们把1向右移动position个二进制位，然后把所得的结果和arr[index]做“或(or)”操作就可以了。如下图<br><img src="https://img-blog.csdnimg.cn/20181106164653491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3,size_16,color_FFFFFF,t_70" alt="2">    </p><p>这里有个需要注意的地方，在画图的时候，为了方便，我们是把左边的位当作低位，右边的位当作高位来算了。不过在实际的存储中，左边的才是存高位，而右边的存的是低位。所以在我们的代码实现中，我们所说的右移对应代码的左移。</p><h4 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据的操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用&gt;&gt;的操作是，运算会比较快</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把1右移和做or操作两步一起</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//即 &lt;&lt; 对应上图的右移，实际上&lt;&lt;是左移符。</span></span><br><span class="line"></span><br><span class="line">   arr[index] |= <span class="number">1</span> &lt;&lt; position;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了add操作，其他的操作差不多类似。</p><p>当然，我们实现的add操作只是简单的实现一下，假如你要严谨地实现的话，还是需要很多异常的判断的。例如判断这个数是否是非负数，判断arr数组是否下标越界，进行容量的扩充等等。有兴趣的可以严谨去实现一下。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>我们只需要把对应的二进制的1变成0就可以了。</p><p>我们可以把1右移(代码中对应左移)后的结果取反，然后与arr[index]做“与”操作就可以了。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">   arr[index] &amp;= ~(<span class="number">1</span> &lt;&lt; position);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="判断是否存在操作"><a href="#判断是否存在操作" class="headerlink" title="判断是否存在操作"></a>判断是否存在操作</h4><p>我们把1右移之后，把结果和arr[index]做“与”操作，如何结果不为0，则证明存在，否则就不存在。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (arr[index] &amp; (<span class="number">1</span> &lt;&lt; position)) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三个最基本的操作代码基本实现了。</p><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] arr;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//容量，即最多能够存多少个数据</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//一个byte可以存8个数据，capacity实际上指的是多少个bit</span></span><br><span class="line"></span><br><span class="line">       arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(capacity / <span class="number">8</span> + <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加数据的操作</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//用&gt;&gt;的操作是，运算会比较快</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//把1右移和做or操作两步一起</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//即 &lt;&lt; 对应上图的右移，实际上&lt;&lt;是左移符。</span></span><br><span class="line"></span><br><span class="line">       arr[index] |= <span class="number">1</span> &lt;&lt; position;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">       arr[index] &amp;= ~(<span class="number">1</span> &lt;&lt; position);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> index = n &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> position = n &amp; <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> (arr[index] &amp; (<span class="number">1</span> &lt;&lt; position)) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>大家看了以上的代码，有没发现一些问题呢？</p><p>例如我们只在bitmap存储1个数，并且存的数值是2000000000，我们就会在第2000000000个二进制把0改为1。也就是说arr数组的大小至少为2000000000/8+1。可是这时候前面的二进制位并没有存数据，那不是超级超级浪费资源？</p><p>所以说，像我们上面的那种写法可以说是暴力写法，没有经过任何优化，实际上，在Java自带的bitMap中是有很多优化的，并不会像我们上面实现的代码一样那么浪费空间资源。有兴趣的可以研究下我的上一篇中的java写法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BitMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BitMap算法介绍</title>
      <link href="/2018/11/03/BitMap%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/03/BitMap%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h3><p>我们先来看个简单的问题。</p><p>假如给你20亿个非负数的int型整数，然后再给你一个非负数的int型整数 t ，让你判断t是否存在于这20亿数中，你会怎么做呢？</p><p>有人可能会用一个int数组，然后把20亿个数给存进去，然后再循环遍历一下就可以了。</p><p>想一下，这样的话，时间复杂度是O(n)，所需要的内存空间</p><p>4byte * 20亿，一共需要80亿个字节，</p><p>大概需要8GB的内存空间，显然有些计算机的内存一次是加载不了这么这么多的数据的。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h4><p>按照上面的做法，时间复杂度是O(n)，内存是8GB，实际上我们是可以把时间复杂度降低到O(1)的。</p><p>例如我们可以这样来存数据，把一个int非负整数n作为数组下标，如果n存在，则对应的值为1，如果不存在，对应的值为0。例如数组arr[n] = 1，表示n存在，arr[n] = 0表示n不存在。</p><p>那么，我们就可以把20亿个数作为下标来存，之后直接判断arr[t]的值，如果arr[t] = 1，则代表存在，如果arr[t] = 0，则代表不存在。这样，我们就可以把时间复杂度降低到O(1)。不过空间复杂度我们并没有降低。还稍微大了点。</p><p>由于int非负整数一共有 2^31 个，所以数组的大小需要 2^31 这么大。</p><p>这里可能有人说也可以用HashSet来存啊，时间复杂度也是近似O(1)。不过这里需要说明的是，HashSet里面存的必须是对象，也就是说需要把int包装成Integer，显然一个对象的话是更花销内存的，需要对象头啊什么的…..</p><h4 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h4><p>大家想一个问题，对于一个数，实际上我们只需要两种状态，就是这个数存在和不存在这两种可能。上面我们用1代表存在，用0代表不存在。</p><p>也就是说，我们是可以不用int型的数组来存储的，一个int型占用4个字节，即32个二进制位，一共可以表示40亿多个状态。用int型的来存两个状态，多浪费。</p><p>所以我们可以考虑用boolean型的来存的，boolean貌似就占用一个字节(java中的boolena貌似是占用一个字节)。而一个boolean有true和false两种状态，所以也是成立的。这样子的话占用的内存就是2GB的内存了。</p><p>这样，就可以降低到之前的四分之1内存了。</p><h4 id="最终优化：bitmap"><a href="#最终优化：bitmap" class="headerlink" title="最终优化：bitmap"></a>最终优化：bitmap</h4><p>大家再想一个问题，虽然boolean是表示两种状态，但是boolean实际上占用了8bit啊，按道理8bit是可以表示128种状态的。而被我们拿来表示两个状态，是否也有点浪费了呢？</p><p>我们都知道，一个二进制位，有0和1两种状态，所以说，其实我们是可以用一个二进制位来代表一个int型的数是否存在的。例如对于1，3，5，7这四个数，如果存在的话，则可以这样表示：<br><img src="https://img-blog.csdnimg.cn/20181103234743957.png" alt="1"></p><p>1代表这个数存在，0代表不存在。例如表中01010101代表1，3，5，7存在，0，2，4，6不存在。</p><p>那如果8，10，14也存在怎么存呢？如图，8，10，14我们可以存在第二个字节里</p><p><img src="https://img-blog.csdnimg.cn/20181103234803139.png" alt="2"></p><p>以此类推。这样子，我们又可以把内存降低到之前的8分之一了。</p><p>这种采用一个二进制位来存储数据的方法，我们也叫做bitmap算法。</p><p>可能有人会问，假如我要添加一个数n，我知道它要存在第n个位那里，把第n个二进制改为1，可是我要怎么操作呢？</p><p><strong>==这个对于bitmap算法是如何存储的，如何进行增删操作的，我会在之后的文章里讲，这篇就大概介绍下bitmap算法。==</strong></p><p>Java中有自带的bitmap实现，今天我们就用Java中自带的bitmap来做道题练练手。我们换道类似题目吧，不知道你一眼是否就能想到用bitmap算法来做。</p><p><strong>题目描述：</strong></p><p>现在有五十亿个int类型的正整数，要从中找出重复的数并返回。</p><p>判断50亿个数有哪些是重复和刚才上面那个判断是否存在，其实是一样的。我们采用bitmap算法来做。不过这里50亿个数，别人肯定是以文件流的形式给你的。这样我们为了方便，我们就假设这些数是以存在int型数组的形式给我们的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//为了方便，假设数据是以数组的形式给我们的</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//用来把重复的数返回，存在Set里，这样避免返回重复的数。</span></span><br><span class="line"></span><br><span class="line">       Set&lt;Integer&gt; output = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       BitSet bitSet = <span class="keyword">new</span> BitSet(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> value = arr[i];</span><br><span class="line"></span><br><span class="line">           <span class="comment">//判断该数是否存在bitSet里</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (bitSet.get(value)) &#123;</span><br><span class="line"></span><br><span class="line">               output.add(value);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">               bitSet.set(value, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           i++;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> output;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">       Set&lt;Integer&gt; t2 = test(t);</span><br><span class="line"></span><br><span class="line">       System.out.println(t2);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:</p><p>[3, 4]</p><p>当然，bitmap算法的应用不仅仅是节省内存，它还有很多其他的优点。之后有机会就拿一些其他的应用来写篇文章。</p><p>本次讲解到此结束。如果喜欢，可以分享给更多的小伙伴哦。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BitMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux编程之进程(二)</title>
      <link href="/2018/10/30/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%BA%8C/"/>
      <url>/2018/10/30/Linux%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>在上一篇关于进程的博客中阐述了进程的概念，总结了进程的状态以及进程如何描述，这篇博客就总结下进程的创建、等待、终止以及进程等待的作用。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>上一篇博客中讲了关于fork函数的使用，其实fork函数就是进程创建的一个重要手段，下面演示进程的创建<br>直接上代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//pid_t fork(void);</span></span><br><span class="line">    <span class="comment">//创建一个新进程，通过复制调用进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is chilld %d!!\n"</span>, getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is parent %d----child:%d\n"</span>, getpid(), pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid:%d\n"</span>, pid);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="进程的等待"><a href="#进程的等待" class="headerlink" title="进程的等待"></a>进程的等待</h3><p>Q:什么叫进程的等待？进程为什么要等待？进程等待的方式？<br>A:(1)一个进程退出之后因为要保存自己退出的原因，因此不会释放所有的资源，它等待父进程查看它的退出原因，然后释放所有资源。<br>假如父进程根本不管，那么这个子进程就成了僵尸进程，造成资源泄漏<br>(2)为了防止僵尸进程的出现，父进程应该等待子进程退出<br>(3)第一种方式：==wait==函数，目的是等待任意一个子进程的退出，因此wait是一个阻塞型函数，如果没有子进程退出，将一直等待下去，直到子进程退出<br>第二种方式：waitpid 它是一个阻塞/非阻塞可选的函数<br>函数原型：==waitpid(pid_t pid, int *status, int options);==</p><ul><li>pid:    -1:等待任意子进程 &gt;0 等待指定的子进程</li><li>status: 获取退出状态码</li><li>options：0：阻塞    WNOHANG：非阻塞</li><li>返回值：-1:出错  ==0：没有子进程退出 &gt;0：退出的子进程pid<br>下面演示进程等待<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">99</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> id = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if ((id = wait(NULL)) &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">        perror("wait error");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((id = waitpid(pid, &amp;status, WNOHANG)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//回过头再判断一下有没有子进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if ((status &amp; 0x7f) == 0) &#123;</span></span><br><span class="line"><span class="comment">        printf("child exit status:[%d]\n", (status &gt;&gt; 8)&amp;0xff);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child exit status:[%d]\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child :%d eixt %d\n"</span>, id, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程退出的场景：</p><ul><li>运行完毕，结果正确</li><li>运行完毕，结果不正确</li><li>代码异常终止<br>常见退出方法<br>正常退出：<br>1）main函数中return<br>2）exit是温和退出，退出前温和的释放资源，刷新缓冲区<br>3）_exit是暴力退出，直接释放资源，不会刷新缓冲区<br>上面的代码中我们看到exit这样的函数，接下来就说说exit函数和_exit<br><code>_exit</code>函数：void _exit(int status);<br>参数：status定义了进程的终止状态，父进程通过wait来获取该值<br><code>exit</code>函数：void exit(int status)；<br>该函数在调用exit之前还做了一些事：<br>1.执行用户通过atexit或on_exit定义的清理函数<br>2.关闭所有打开的流，所有的缓存数据均被写入<br>3.调用_exit<br>总结来说：exit会释放资源退出，_exit立即退出。</li></ul><p>还有一种我们常用的return n 退出，它就和exit(n)等同，因为调用main函数的运行时函数会将main的返回值当做exit的参数</p><h3 id="进程程序替换"><a href="#进程程序替换" class="headerlink" title="进程程序替换"></a>进程程序替换</h3><p>程序替换的是代码段所指向的物理内存区域，相当于让虚拟地址空间中的代码地址指向了物理内存的另一端代码位置，这样的话虚拟地址空间中原先的数据区域以及堆栈都会重新初始化，因为现在的代码运行的根本不是复制的那些数据<br>但是这个进程pcb还是原来的pcb<br>execl函数族：   </p><table><thead><tr><th>c</th><th>p</th><th>e</th></tr></thead><tbody><tr><td>execl</td><td>execlp</td><td>execle </td></tr><tr><td>execv</td><td>execvp</td><td>execve </td></tr></tbody></table><p>l和v的区别：l是参数平铺一个一个通过exec函数参数赋予，v参数直接使用字符串指针数组</p><p>execl/execv 需要我们给出要替换的程序的全路径名<br>execlp/execvp  只需要给出替换的程序的名称就行<br>execle     重新 自己组织环境变量，不使用现有的<br>下面演示一个exec函数的使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exec.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">        <span class="comment">//int execl(const char *path, const char *arg, ...);</span></span><br><span class="line">        <span class="comment">//execl("/bin/ls", "ls", "-l", "-a", NULL);</span></span><br><span class="line">        <span class="comment">//int execlp(const char *file, const char *arg, ...);</span></span><br><span class="line">        <span class="comment">//execlp("/home/san/workspace/36/pctrl/test" "test", NULL);</span></span><br><span class="line">        <span class="comment">//int execle(const char *path, const char *arg, ..., </span></span><br><span class="line">        <span class="comment">//  char * const envp[]);</span></span><br><span class="line">        <span class="comment">//  添加参数的时候记住要有一个NULL表示参数的结尾</span></span><br><span class="line">        <span class="comment">//  NULL之后还有一个参数是用于设置环境变量的</span></span><br><span class="line">        <span class="comment">//      并且这个函数会清空所有的环境变量，因为这个接口就是</span></span><br><span class="line">        <span class="comment">//      让我们用户自己来设置环境变量的</span></span><br><span class="line">        <span class="keyword">char</span> *ptr = <span class="string">"PATH=hehe---he----hehe!!"</span>;</span><br><span class="line">        <span class="keyword">char</span> *env[<span class="number">3</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        env[<span class="number">0</span>] = ptr;</span><br><span class="line">        execle(<span class="string">"/code/day10_30/test"</span>, <span class="string">"test"</span>, <span class="literal">NULL</span>, </span><br><span class="line">                env);</span><br><span class="line">        perror(<span class="string">"execle error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这句代码实际上是根本不会执行的，因为代码段已经被替换了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hehe!!!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想了解exec函数原型可以自行在Linux下man</p><h3 id="Myshell实现"><a href="#Myshell实现" class="headerlink" title="Myshell实现"></a>Myshell实现</h3><p>学了进程的创建，等待，终止，我们可以自行做一个简易的shell工具，它的功能就是解释我们输入的命令 ，初步看起了像shell<br>实现步骤：<br>1.键盘接收输入信息<br>2.创建子进程<br>3.程序替换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myshell.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"minishell: "</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%[^\n]%*c"</span>, cmd) != <span class="number">1</span>) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将获取到的命令解析一下，然后创建子进程进行程序替换</span></span><br><span class="line">        <span class="keyword">char</span> *ptr = cmd;</span><br><span class="line">        <span class="keyword">char</span> *argv[<span class="number">32</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">        argv[argc++] = ptr;</span><br><span class="line">        <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">//ls       -l</span></span><br><span class="line">            <span class="comment">//int isspace(int c);</span></span><br><span class="line">            <span class="comment">//用于判断一个字符是否是:\t \n \r 空格 </span></span><br><span class="line">            <span class="comment">//解析一个字符串时候这里就是对空格的判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isspace</span>(*ptr)) &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>) &#123;</span><br><span class="line">                    *ptr++ = <span class="string">'\0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argv[argc++] = ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要等待的原因：</span></span><br><span class="line">        <span class="comment">//1. 避免产生僵尸子进程</span></span><br><span class="line">        <span class="comment">//2. 是为了等待子进程运行完毕，让程序逻辑更加完善</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序中可能你会对下面这个解释有疑问，因此在此做出解释(正则表达式)：</p><ul><li>^\n：scanf本身是遇到空格就要获取一次，这样的话就无法获取到一个完整的命令，因此‘%[^\n]’表示的是获取数据直到遇到\n为止   </li><li>%*c：将缓冲区中的字符都取出来，但是不要它，直接丢掉目的是为了将最后的\n从缓冲区取出来，防止陷入死循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实训日志</title>
      <link href="/2018/10/28/%E5%AE%9E%E8%AE%AD%E6%97%A5%E5%BF%97/"/>
      <url>/2018/10/28/%E5%AE%9E%E8%AE%AD%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>电子实训终于结束了。</p><p>体测累死了啊啊啊啊<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2018/10/23/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8Econst/"/>
      <url>/2018/10/23/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8Econst/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo搭建博客教程</title>
      <link href="/2018/10/19/github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2018/10/19/github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="Github-Pages介绍"><a href="#Github-Pages介绍" class="headerlink" title="Github Pages介绍"></a>Github Pages介绍</h3><p>本来用于介绍托管在Github上的项目，由于它的空间免费稳定，因此适合用来搭建博客。</p><p>每个帐号只能有一个仓库来存放个人主页，且仓库的名字必须是username/username.github.io。你可以通过<a href="http://username.github.io来访问你的个人主页" target="_blank" rel="noopener">http://username.github.io来访问你的个人主页</a></p><p>个人主页的网站内容是在master分支下</p><h3 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h3><p>Hexo是一个快速、简洁高效的博客框架，具有如下特点：   </p><ul><li>生成静态网页</li><li>支持Markdown</li><li>一键部署博客到Github Pages</li><li>丰富插件</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>下载git<br>  <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></li><li>安装git</li><li>下载node.js<br>  <a href="http://nodejs.org/download/" target="_blank" rel="noopener">http://nodejs.org/download/</a></li><li>安装node.js</li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在任意位置右键点击Git Bash Here</p><p>使用npm安装hexo，可以先切换npm源，加速安装过程</p><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>npm install -g hexo</p><p>【注】若安装不成功，可以使用npm install hexo –save再次安装</p><p>出现以下图示表示安装完成。</p><p>【注】若提示This package is no longer maintained，耐心等待安装即可。</p><h3 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h3><h4 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h4><p>在某一文件夹下如F:\hexo\blog，右键Git Bash Here，使用以下命令创建建立网站需要的文件   </p><blockquote><p>hexo init<br><img src="http://p15qizl76.bkt.clouddn.com/blog/171220/Fg6728KdiK.jpg?imageslim" alt="1"></p><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><p>npm install<br><img src="http://p15qizl76.bkt.clouddn.com/blog/171220/B7lkme9mkb.jpg?imageslim" alt="2"></p><h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><pre><code>hexo generate  #生成静态文件，会在当前目录下生成一个新的名为public的文件夹</code></pre></blockquote><h4 id="启动Hexo"><a href="#启动Hexo" class="headerlink" title="启动Hexo"></a>启动Hexo</h4><pre><code>hexo server -p 5000 #使用hexo server 默认端口4000，会无法访问localhost:4000，因此改为5000端口</code></pre><h4 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo help #查看帮助</span><br><span class="line">hexo -v #查看本地环境</span><br><span class="line">hexo init #初始化一个目录</span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span> #新建文章</span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span> #新建页面</span><br><span class="line">hexo gernerate #生成网页，可以在<span class="keyword">public</span>目录查看整个网站的文件</span><br><span class="line">hexo server #本地预览 Ctrl+C关闭</span><br><span class="line">hexo deploy #或hexo d 部署到远端如github、heroku</span><br><span class="line">hexo clean #清除缓存 建议每次执行命令前先清理缓存，每次部署前先删除 .deploy文件夹</span><br><span class="line"></span><br><span class="line">#常用缩写</span><br><span class="line">hexo n  #hexo <span class="keyword">new</span></span><br><span class="line">hexo g  #hexo generate</span><br><span class="line">hexo s  #hexo server</span><br><span class="line">hexo d  #hexo deploy</span><br><span class="line"></span><br><span class="line">#常用组合</span><br><span class="line">hexo d -g #生成部署</span><br><span class="line">hexo s -g #生成预览</span><br></pre></td></tr></table></figure><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><h4 id="注册github账号"><a href="#注册github账号" class="headerlink" title="注册github账号"></a>注册github账号</h4><pre><code>地址: https://github.com/</code></pre><p>输入账号、邮箱、密码,然后点击注册按钮.–&gt;之后验证邮箱</p><h4 id="创建页面仓库"><a href="#创建页面仓库" class="headerlink" title="创建页面仓库"></a>创建页面仓库</h4><p>创建一个仓库，需要和帐号对应，格式yourname.github.io，创建仓库<br><img src="http://upload-images.jianshu.io/upload_images/695365-65754452ea96e1cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="3"></p><p><img src="http://upload-images.jianshu.io/upload_images/695365-e4fb878d83a8a2e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="4"></p><h4 id="关联本地与github"><a href="#关联本地与github" class="headerlink" title="关联本地与github"></a>关联本地与github</h4><h5 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h5><blockquote><p>任意地方右键Git Bash Here,执行以下命令</p><p>ssh-keygen -t rsa -C “你的邮箱地址”</p></blockquote><p>出现Enter file in which to save the key (…..)直接回车选择默认位置</p><p> 出现Enter passphrase(empty for no passphrase)直接两次回车不设密码以及确认<br><img src="https://img-blog.csdn.net/2018102423354921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="5"></p><h5 id="在Github上添加SSH密钥"><a href="#在Github上添加SSH密钥" class="headerlink" title="在Github上添加SSH密钥"></a>在Github上添加SSH密钥</h5><p>打开id_rsa.pub，复制内容。</p><p>进入你的github页面，右上角找到setting，点击进去，找到ssh。</p><p>点击New SSH key<br><img src="http://p15qizl76.bkt.clouddn.com/blog/171220/8HbiiJFCgB.jpg?imageslim" alt="6"><br>填写后点击Add SSH key<br><img src="http://p15qizl76.bkt.clouddn.com/blog/171220/CgdkDEDim9.jpg?imageslim" alt="7"></p><h3 id="上传部署"><a href="#上传部署" class="headerlink" title="上传部署"></a>上传部署</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul><li>deploy #需要部署的文件</li><li>node_modules #Hexo插件</li><li>public #生成的静态网页文件</li><li>scaffolds #模板</li><li>source #博客正文和其他源文件</li><li>drafs #草稿</li><li>posts#文章</li><li>themes #主题</li><li>config.yml #配置文件</li></ul><p><img src="http://p15qizl76.bkt.clouddn.com/blog/171220/dLaLgf5B36.jpg?imageslim" alt="8"></p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>原理</p><ul><li>上述步骤中在Github上创建的那个仓库username.github.io，可以通过该链接访问</li><li>Hexo -g 会生成一个静态网站，第一次会生成一个public目录，这个静态文件可以直接访问</li><li>需要将Hexo生成的静态网站，提交(git commit)到github上</li></ul><p>过程</p><ul><li><p>需要在_config.yml中修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:    </span><br><span class="line">  type: git   //注意：冒号后面有英文空格</span><br><span class="line">  repository: http://github.com/username/username.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure><p>安装依赖包</p></li></ul><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p>配置好之后执行</p><blockquote><p>hexo genearte<br>hexo deploy</p></blockquote><p>【注】以上命令执行的环境必须在执行hexo init创建的文件夹下执行</p><p>执行完以上命令，会出现页面输入你的github用户名和密码，验证后就可以上传成功</p><p>访问 username.github.io，成功打开页面即部署成功</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><blockquote><p>hexo new “postname”</p></blockquote><p>该命令会自动在hexo/source/_post文件夹下创建一个名为postname的markdown文件，会自动在文件开头添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的题目</span><br><span class="line">tags: 你的标签</span><br><span class="line">category: 你的分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>填写tags,category，新建标签页面和分类页面后即可以显示相应的标签和分类   </p><h5 id="新建标签页面"><a href="#新建标签页面" class="headerlink" title="新建标签页面"></a>新建标签页面</h5><blockquote><p>hexo new page tags</p></blockquote><p>该命令会自动在hexo/source文件夹下创建tags文件夹并在该文件夹下创建index.md文件。</p><p>修改index.md文件，添加以下两项</p><blockquote><p>layout: tags<br>comments: false</p></blockquote><h5 id="新建分类页面"><a href="#新建分类页面" class="headerlink" title="新建分类页面"></a>新建分类页面</h5><blockquote><p>hexo new page categories</p></blockquote><p>该命令会自动在hexo/source文件夹下创建categories文件夹并在该文件夹下创建index.md文件</p><p>修改index.md文件，添加以下两项：</p><blockquote><p>layout: categories<br>comments: false</p></blockquote><p>最后我们hexo g -d  一把，打开自己的页面查看</p><p>以下是博主的博客链接 欢迎访问 <a href="https://liuziqiao.github.io">https://liuziqiao.github.io</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核初窥探-进程</title>
      <link href="/2018/10/16/Linux%E5%86%85%E6%A0%B8%E5%88%9D%E7%AA%A5%E6%8E%A2%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/10/16/Linux%E5%86%85%E6%A0%B8%E5%88%9D%E7%AA%A5%E6%8E%A2%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="Linux下多任务介绍"><a href="#Linux下多任务介绍" class="headerlink" title="Linux下多任务介绍"></a>Linux下多任务介绍</h3><p>首先，简单介绍下多任务系统，任务，进程，线程分别是什么？之间的区别是什么？从宏观角度理解后再针对每一个仔细探究   </p><ul><li><p>什么叫多任务系统：多任务系统指可以同一时间内运行多个应用程序，每个应用程序被称作一个任务。</p></li><li><p>任务定义:任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。</p></li><li><p>进程定义:进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的最小单元。</p></li><li><p>线程定义:线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以成为轻量级进程。</p><p> 看了定义，还是不太理解，那就通俗的说一下它们的区别吧。<br> ①通常一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是进程或线程。<br> ②一个进程可以拥有多个线程，每个线程必须有一个父进程。</p></li></ul><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>任务是一个逻辑概念，指有一个软件完成的任务，或者由一系列共同达到某一目的的操作。通常一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是一个进程或线程。任务、进程、线程之间的关系如图   </p><p><img src="https://img-blog.csdn.net/20181019235344883?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDc4MjM3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="1"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h4><p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行的过程，是系统进程资源分配和调度的基本单元。一次任务的运行可以并发激活多个进程，这些进程相互合作完成该任务的一个最终目标。<br>操作系统对进程的描述：PCB（进程控制块）Linux下的进程描述——task_struct     </p><p>进程具有并发性、动态性、交互性、独立性、异步性等主要特性   </p><p>进程和程序之间的区别：程序是一段代码，是一些保存在存储器上的指令有序集合，没有执行的概念；而进程是一个动态的概念，是程序执行的过程，包括动态创建、调度、消亡的整个过程，它是程序执行和资源管理的最小单位。</p><h4 id="Linux下的进程结构"><a href="#Linux下的进程结构" class="headerlink" title="Linux下的进程结构"></a>Linux下的进程结构</h4><p>  进程不但包括程序指令和数据，还包括程序计数器和处理器的所有寄存器及存储临时数据的进程堆栈，因此，正在执行的进程包括处理器当前的一切活动   </p><p>  内核将所有进程存放在双向循环链表（进程链表）中，其中链表的头是init_task描述符。链表的每一项都是类型为 task_struct，称为进程描述符的结构，该结构包含了一个进程相关的所有信息，定义在<include linux="" sched.h="">文件中。task_struct内核结构比较大，它能完整的描述一个进程，如进程的状态、进程的基本信息、进程标识符、内存相关信息、父进程相关信息、与进程相关的终端信息、当前工作目录、打开的文件信息、所接收的信号信息等。</include></p><p>task_struct结构体中最重要的两个域：state（进程状态）和pid（进程标识符），下面就详细说说这两个</p><h4 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h4><p>Linux内核通过唯一的进程标识符 PID 来标识每个进程(就和文件描述符一样)。PID存放在进程描述符的 pid 字段中，新创建的 PID 通常是前一个进程的 PID 加1，不过PID的值有上限（最大值=PID_MAX_DEFAULT-1，通常为32767），读者可以查看/proc/sys/kernel/pid_max 来确定该系统的进程数上限。</p><p>   当系统启动后，内核通常作为某一个进程的代表。一个指向task_struct的宏current用来记录正在运行的进程。current经常作为进程描述符结构指针的形式出现在内核代码中，例如，current-&gt;pid 表示处理器正在执行的进程的PID。当系统需要查看所有的进程时，则调用for_each_process()宏，这将比系统搜索数组的速度要快的多。</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>进程的信息可以通过/proc系统文件夹查看   </p><ul><li>如：要获取PID为1 的进程，我们需要查看 /proc/1这个文件夹</li><li><p>大多数进程信息同样可以使用top和ps这些用户级工具来获取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过系统调用获取进程标识符<br><strong>在Linux中获得当前进程号的（PID）和父进程号（PPID）的系统调用函数分别为 getpid() 和 getppid()。</strong>   </p></li></ul><p>下面演示在Linux中获取进程pid<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getpid获取当前进程ID</span></span><br><span class="line"><span class="comment">//getppid获取父进程ID</span></span><br><span class="line"><span class="comment">//pid_t是C语言中用户自定义类型</span></span><br><span class="line"><span class="comment">//在sys/types.h中定义</span></span><br><span class="line"><span class="comment">//进程标识符演示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid:%d\n"</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ppid:%d"</span>,getppid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>  Linux中的进程有以下几种状态:</p><p>   ● 运行状态（TASK_RUNNING）:进程当前正在运行，或者正在运行队列中等待调度。</p><p>   ● 可中断的阻塞状态（TASK_INTERRUPTIBLE）：进程处于阻塞(睡眠)状态，正在等待某些事件发生或能够占用某些资源。处在这种状态下的进程可以被信号中断。接收到信号或被显式的唤醒呼叫（如调用 wake_up 系列宏:wake_up、wake_up_interruptible等）唤醒之后，进程将转变为 TASK_RUNNING 状态。</p><p>   ● 不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）:此进程状态类似于可中断的阻塞状态（TASK_INTERRUPTIBLE），只是它不会处理信号，把信号传递到这种状态下的进程不能改变它的状态。在一些特定的情况下（进程必须等待，直到某些不能被中断的事件发生），这种状态是很有用的。只有在它所等待的事件发生时，进程才被显示的唤醒呼叫唤醒。</p><p>   ● 可终止的阻塞状态（TASK_KILLABLE）:该状态的运行机制类似于TASK_UNINTERRUPTIBLE，只不过处在该状态下的进程可以响应致命信号。它可以替代有效但可能无法终止的不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）,以及易于唤醒但安全性欠佳的可中断的阻塞状态TASK_INTERRUPTIBLE）。</p><p>   ● 暂停状态（TASK_STOPPED）:进程的执行被暂停，当进程收到 SIGSTOP、SIGSTP、SIGTTIN、SIGTTOU等信号时，就会进入暂停状态。</p><p>   ● 跟踪状态（TASK_TRACED）:进程的执行被调试器暂停。当一个进程被另一个监控时（如调试器使用ptrace()系统调用监控测试程序），任何信号都可以把这个进程置于跟踪状态。</p><p>   ● 僵尸状态（EXIT_ZOMBIE）:子进程先于父进程退出，它要保留退出原因在pcb中，因此退出后不会自动释放所有资源，子进程退出后操作系统通知父进程说子进程退出了，需要去获取原因，然后释放子进程资源。假如父进程不管子进程的退出状态，那么这个子进程将进入僵死状态，成为僵尸进程。</p><p>   ● 僵尸撤销状态（EXIT_DEAD）:这是最终状态，父进程调用 wait 函数族“收尸”后，进程彻底由系统删除。</p><h4 id="进程的创建、执行、终止"><a href="#进程的创建、执行、终止" class="headerlink" title="进程的创建、执行、终止"></a>进程的创建、执行、终止</h4><h5 id="fork函数认识"><a href="#fork函数认识" class="headerlink" title="fork函数认识"></a>fork函数认识</h5><ul><li>运行man fork</li><li>fork 有两个返回值,若直线成功，在父进程中返回子进程的pid，在子进程中返回0</li><li><p>父子进程代码共享，数据各自开辟空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/typees&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello proc:%d,ret:%d\n"</span>,getpid(),ret);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fork 之后通常要用if分流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child:%d,ret:%d\n"</span>,getpid(),ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am father :%d,ret:%d\n"</span>,getpid(),ret);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>僵尸进程的危害：资源泄漏<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zombie.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;<span class="keyword">else</span> ifpid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is child\n"</span>);    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>父进程先于子进程退出，子进程将成为孤儿进程,当子进程成为孤儿进程时，Init进程将会回收，也就是说，父进程将变成init进程，init将负责释放资源<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//orphan.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is parent，%d\n"</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is child,%d\n"</span>,getpid());        </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04安装教程</title>
      <link href="/2018/10/15/Ubuntu18-04%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/10/15/Ubuntu18-04%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>Ubuntu 叫法很多（友帮拓、优班图、乌班图），是一个一琢磨应用为主的开源GUN/Linux操作系统，接下来记录了在VMware Workstation Pro 中安装Ubuntu 18.04</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="下载安装VMware虚拟机"><a href="#下载安装VMware虚拟机" class="headerlink" title="下载安装VMware虚拟机"></a>下载安装VMware虚拟机</h4><p>VMware下载地址：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a><br>安装过程中可能会出现需要激活，这里有我用的激活码<br>链接：<a href="https://pan.baidu.com/s/1VzC5w_Ini4SU0TwpC87Geg" target="_blank" rel="noopener">https://pan.baidu.com/s/1VzC5w_Ini4SU0TwpC87Geg</a><br>提取码：nhom<br>安装完毕之后</p><h4 id="下载Ubuntu-18-04LTS"><a href="#下载Ubuntu-18-04LTS" class="headerlink" title="下载Ubuntu 18.04LTS"></a>下载Ubuntu 18.04LTS</h4><p>进入官网：<a href="https://www.ubuntu.com/" target="_blank" rel="noopener">https://www.ubuntu.com/</a><br>或者直接进入下载页面：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a><br>选择相应的版本进行下载</p><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><h4 id="创建新的虚拟机"><a href="#创建新的虚拟机" class="headerlink" title="创建新的虚拟机"></a>创建新的虚拟机</h4><p>1、 打开VMware Workstation<br><img src="https://img-blog.csdn.net/20180610193243886" alt="1"><br>2、选择自定义(高级)，然后下一步<br><img src="https://img-blog.csdn.net/20180610193508149" alt="2"><br>3、默认，直接下一步<br><img src="https://img-blog.csdn.net/20180610193706658" alt="3"><br>4、选择“稍后安装操作系统”，然后下一步<br><img src="https://img-blog.csdn.net/20180610193751797" alt="4"><br>5、客户机操作系统选择Linux，版本选择“Ubuntu 64”，下一步<br><img src="https://img-blog.csdn.net/20180610193904307" alt="5"><br>6、根据自身电脑情况，给虚拟机命名和指定安装位置（建议不要放在系统盘），然后下一步<br><img src="https://img-blog.csdn.net/20180610194240208" alt="6"><br>7、根据电脑配置为虚拟机配置处理器和内存大小，默认即可<br><img src="https://img-blog.csdn.net/20180610195053728" alt="7"><br><img src="https://img-blog.csdn.net/20180610195124226" alt="8"><br>8、选择网络类型默认为“使用网络地址转换(NAT)”即可，下一步<br><img src="https://img-blog.csdn.net/20180610195546393" alt="9"><br>9、选择I/O控制器类型和磁盘类型，这两步都默认选择，下一步<br><img src="https://img-blog.csdn.net/20180610195912938" alt="10"><br><img src="https://img-blog.csdn.net/20180610195933859" alt="11"><br>10、根据自身设置磁盘大小（建议60G+），选择“将虚拟磁盘存储为单个文件”，下一步<br><img src="https://img-blog.csdn.net/20180610200118583" alt="12"><br>11、选择下一步即可，然后选择“自定义硬件”<br><img src="https://img-blog.csdn.net/20180610200431726" alt="13"><br>12、弹出框中选择CD/DVD（STAT），然后在右边选择使用ISO映像文件，此时选择我们下载好的镜像文件的路径，然后点击关闭，完成即可<br><img src="https://img-blog.csdn.net/20180610201122123" alt="14"><br>13、开启虚拟机，开启过程可能会报错，如果你是第一次安装，那就需要开启电脑虚拟化支持，关机并开机，开机过程中按F10（根据自己电脑的按键，我这里是F10键），进入boss页面后找到虚拟化支持开启。重启后再进入虚拟机开启虚拟机<br><img src="https://img-blog.csdn.net/20180610201701798" alt="15"><br>14、此时你将看到下面页面，选择中文即可<br><img src="https://img-blog.csdn.net/20180610202441243" alt="16"><br>15、默认汉语，选择继续，在选择正常安装，点击继续<br><img src="https://img-blog.csdn.net/20180610203622745" alt="17"><br><img src="https://img-blog.csdn.net/20180610203856154" alt="18"><br>16、默认选项点击现在安装<br><img src="https://img-blog.csdn.net/20180610203935245" alt="19"><br>17、弹出确认框，点击继续，在默认城市，点击继续 <img src="https://img-blog.csdn.net/20180610204141526" alt="20"><br><img src="https://img-blog.csdn.net/20180610204314399" alt="21"><br>18、设置用户名和密码（建议密码设置简单6位即可，每次开机或登录将使用密码），点击继续<br><img src="https://img-blog.csdn.net/20180610204450783" alt="22"><br>19、接着进入安装界面，下面会显示安装进度<br><img src="https://img-blog.csdn.net/20180610204732619" alt="23"><br>20、接下来你可以去喝杯，因此次过程比较缓慢<br>21、安装完成后点击“现在重启”<br><img src="https://img-blog.csdn.net/20180610204836829" alt="24"><br>22、重启之后进入登录页面<br>23、然后打开浏览器检查网络是否连接成功<br><img src="https://img-blog.csdn.net/20180610210401357" alt="25"></p><h3 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h3><p>Ubuntu安装成功，你会发现VMware全屏时，Ubuntu桌面在VMware中不能全屏显示，因此我们需要安装VMware Tools 工具<br>1、此时可以点击界面底部提醒我们安装VMware Tools的弹框的“安装Tools”按钮，或者，点击VMware 导航栏上的“虚拟机”，然后在下拉框中点击“安装VMware Tools”；<br><img src="https://img-blog.csdn.net/20180610211441253" alt="26"><br>2、完成后进入Ubuntu，桌面会出现VMware Tools的光盘，点击进入其中<br><img src="https://img-blog.csdn.net/20180610211921565" alt="27"><br>3、进入后看到一个压缩文件VMwareTools-10.25-8068393.tar.gz（中间数组不同的虚拟机版本可能会不同），复制文件到主目录下面（即home 个人用户名的目录下）<br><img src="https://img-blog.csdn.net/20180610212233588" alt="28"><br><img src="https://img-blog.csdn.net/20180610212938367" alt="29"><br>4、按【Ctrl+Alt+T】调出终端命令界面，输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf VMware Tools-10.25-8068393.tar.gz</span><br></pre></td></tr></table></figure></p><p>然后回车，解压文件是快捷方式输入括号里的【tar -zxvf V】后按Tab 会自动补全文件名字<br><img src="https://img-blog.csdn.net/20180610213100618" alt="30"><br>5、解压完成后会出现一个vmware-tools-distrib的文件<br><img src="https://img-blog.csdn.net/20180610214634905" alt="31"><br>6、输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd vmware-tools-distrib</span><br></pre></td></tr></table></figure></p><p>回车后输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./vmware-install.pl</span><br></pre></td></tr></table></figure></p><p>回车后输入密码，然后就开始安装，遇到yes就输入yes，其他一律回车<br>7、如图显示VMware tools安装成功<br><img src="https://img-blog.csdn.net/20180610220242127" alt="32"><br>以上就是博主整个安装Ubuntu 18.04LTS的过程</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列实现栈</title>
      <link href="/2018/10/14/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2018/10/14/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="利用两个队列实现一个栈"><a href="#利用两个队列实现一个栈" class="headerlink" title="利用两个队列实现一个栈"></a>利用两个队列实现一个栈</h3><p><strong>要求：</strong><br>Push：往非空队列里插入（如果两个队列都是空，选第一个插入）</p><p>Pop：从非空队列中 move  size - 1 个元素到 空队列中，pop 剩下的一个</p><p>Top: 从非空队列中 move  size - 1 个元素到 空队列中，返回剩下的一个的值，<br>     把剩下的一个也放入另一个队列中</p><h3 id="实现部分"><a href="#实现部分" class="headerlink" title="实现部分"></a>实现部分</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>以下代码基于队列的基本操作Queue.h，关于Queue.h请自行在本博客中查找<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Queue queue1;</span><br><span class="line">Queue queue2;</span><br><span class="line">&#125;QStack;</span><br></pre></td></tr></table></figure></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStackInit</span><span class="params">(QStack *pQS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueueInit(&amp;(pQS-&gt;queue1));</span><br><span class="line">QueueInit(&amp;(pQS-&gt;queue2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStackDestory</span><span class="params">(QStack *pQS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueueDestroy(&amp;(pQS-&gt;queue1));</span><br><span class="line">QueueDestroy(&amp;(pQS-&gt;queue2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStackPush</span><span class="params">(QStack *pQS,QDataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue *pNotEmpty = &amp;(pQS-&gt;queue2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (QueueEmpty(pNotEmpty))    <span class="comment">// 如果队列二为空，则不为空的就假设为队列一，就将队列一中的插入队列二</span></span><br><span class="line">&#123;</span><br><span class="line">pNotEmpty = &amp;(pQS-&gt;queue1);<span class="comment">//如果队列二不为空，则直接将队列一中的插入队列二</span></span><br><span class="line">&#125;</span><br><span class="line">QueuePush(pNotEmpty,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStackPop</span><span class="params">(QStack *pQS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue *pEmpty = &amp;(pQS-&gt;queue1);</span><br><span class="line">Queue *pNotEmpty = &amp;(pQS-&gt;queue2);</span><br><span class="line"><span class="keyword">if</span> (QueueEmpty(pNotEmpty)) <span class="comment">//假设队列二是空，如果队列二空，则不空的就是队列一</span></span><br><span class="line">&#123;</span><br><span class="line">pEmpty = &amp;(pQS-&gt;queue2);</span><br><span class="line">pNotEmpty = &amp;(pQS-&gt;queue1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (QueueSize(pNotEmpty) &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">QDataType data = QueueFront(pNotEmpty);</span><br><span class="line">QueuePop(pNotEmpty);</span><br><span class="line">QueuePush(pEmpty,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueuePop(pNotEmpty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取压入的元素"><a href="#获取压入的元素" class="headerlink" title="获取压入的元素"></a>获取压入的元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDataType <span class="title">QStackTop</span><span class="params">(QStack *pQS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QDataType data;</span><br><span class="line">QDataType r;</span><br><span class="line">Queue *pEmpty = &amp;(pQS-&gt;queue1);</span><br><span class="line">Queue *pNotEmpty = &amp;(pQS-&gt;queue2);</span><br><span class="line"><span class="keyword">if</span> (QueueEmpty(pNotEmpty)) <span class="comment">//假设队列二是空，如果队列二空，则不空的就是队列一</span></span><br><span class="line">&#123;</span><br><span class="line">pEmpty = &amp;(pQS-&gt;queue2);</span><br><span class="line">pNotEmpty = &amp;(pQS-&gt;queue1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (QueueSize(pNotEmpty) &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">data = QueueFront(pNotEmpty);</span><br><span class="line">QueuePop(pNotEmpty);</span><br><span class="line">QueuePush(pEmpty,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = QueueFront(pNotEmpty);</span><br><span class="line">QueuePop(pNotEmpty);</span><br><span class="line">QueuePush(pEmpty,r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">QStack qstack;</span><br><span class="line">QStackInit(&amp;qstack);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">QStackPush(&amp;qstack,i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"压入第%d ,压入 %d\n"</span>,i+<span class="number">1</span>,QStackTop(&amp;qstack));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Top = %d "</span>,QStackTop(&amp;qstack));</span><br><span class="line"><span class="comment">//QStackPop(&amp;qstack);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现队列</title>
      <link href="/2018/10/14/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2018/10/14/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>首先我们需要引入栈文件Stack.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.h"</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*两个栈实现一个队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queues</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Stack stack1;</span><br><span class="line">Stack stack2;</span><br><span class="line">&#125;Queues;</span><br></pre></td></tr></table></figure></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuesInit</span><span class="params">(Queues *pQs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackInit(&amp;(pQs-&gt;stack1));</span><br><span class="line">StackInit(&amp;(pQs-&gt;stack2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuesPush</span><span class="params">(Queues *pQs,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackPush(&amp;(pQs-&gt;stack1),data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuesPop</span><span class="params">(Queues *pQs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(&amp;(pQs-&gt;stack2)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(&amp;(pQs-&gt;stack1)))</span><br><span class="line">&#123;</span><br><span class="line">DataType data = StackTop(&amp;(pQs-&gt;stack1));</span><br><span class="line">StackPush(&amp;(pQs-&gt;stack2),data);</span><br><span class="line">StackPop(&amp;(pQs-&gt;stack1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">StackPop(&amp;(pQs-&gt;stack2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取队列队首元素"><a href="#获取队列队首元素" class="headerlink" title="获取队列队首元素"></a>获取队列队首元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">DataType <span class="title">QueuesFront</span><span class="params">(Queues *pQs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(&amp;(pQs-&gt;stack2)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ( !StackEmpty(&amp;(pQs-&gt;stack1)))</span><br><span class="line">&#123;</span><br><span class="line">DataType data = StackTop(&amp;(pQs-&gt;stack1));</span><br><span class="line">StackPush(&amp;(pQs-&gt;stack2),data);</span><br><span class="line">StackPop(&amp;(pQs-&gt;stack1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> StackTop(&amp;(pQs-&gt;stack2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQueues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Queues queues;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">QueuesInit(&amp;queues);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">QueuesPush(&amp;queues,arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,QueuesFront(&amp;queues));</span><br><span class="line">QueuesPop(&amp;queues);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算实现加减乘除</title>
      <link href="/2018/10/12/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/"/>
      <url>/2018/10/12/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>数据在计算机内存中是以二进制存储的。<br>几种常用的位运算：   </p><p>与运算&amp;： 对应位均为1时为1，其它为0。<br>或运算|： 对应位均为0时为0，其它为1。<br>异或运算^： 对应位不相同时为1，相同时为0.<br>按位取反~： 每一位取反<br>右移&gt;&gt;: 将二进制进行右移，低位丢掉，高位补零。<br>左移&lt;&lt;： 将二进制进行左移，低位补零，高位丢掉。   </p><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><p>以0111 + 0101为例，观察异或运算和与运算的结果</p><blockquote><p>0111 ^ 0101 = 0010; //结果的每一位等于对应位相加模二，刚好是不带进位的加法结果。</p><p>0111 &amp; 0101 = 0101; //结果的1表示对应位相加为2，0表示对应位相加小于二，刚好是进位标识。</p></blockquote><p>又因为进位是向高位进位，也就是说如果第二位是1，则表示在计算过程中要向第三位进位，所以可以将与运算结果左移一位后和异或运算的结果做加法。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  (b == <span class="number">0</span>) ?a: add(a^b, (a&amp;b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(b == 0)</span></span><br><span class="line"><span class="comment">return a;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">return add(a^b,(a&amp;b)&lt;&lt;1);</span></span><br><span class="line"><span class="comment">//异或结果 + 与运算结果左移一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="减"><a href="#减" class="headerlink" title="减"></a>减</h3><p>减法和加法相同，减去一个数相当于加上这个数的相反数，所以完全可以利用加法操作，唯一需要做的就是求出被减数的相反数。<br>求相反数的方法：每一位取反，末位加一。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求n的相反数</span></span><br><span class="line"><span class="comment">//~：按位取反</span></span><br><span class="line"><span class="comment">//add：加法操作，末位加一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negtive</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> add(~n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> add(a, negtive(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><p>平时在笔算乘法数据都是十进制的，而抛去思维定势，把数看成是二进制，也可以进行笔算乘法，像这样<br><img src="https://img-blog.csdn.net/20170607225733749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzUyNjEzMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="123"></p><p>根据算式可以知道，对于a * b，每次只需要将a左移一位乘上b的对应位，然后同上一次的结果做加法即可。<br>也就意味着当b的对应位为1时，对a左移一位然后同上一次的结果做加法。<br>如果b的对应位为0，只对a左移一位。<br>当然，上述这些运算不包括符号位，所以两个操作数都需要先转换成正数，符号需要单独考虑。对于4个字节（32位整数）来说，获取符号位只需要取出第31位的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取符号位，判断是正负</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSign</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &gt;&gt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PosAbs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getSign(n) &amp; <span class="number">1</span>) ? negtive(n) : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//如果两个数符号位不相容，则结果为负</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (getSign(a) ^ getSign(b))</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a = PosAbs(a);</span><br><span class="line">b = PosAbs(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b | <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//如果两个数符号位不相容，则结果为负</span></span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res = add(res, a);</span><br><span class="line">&#125;</span><br><span class="line">a = a &lt;&lt; <span class="number">1</span>;</span><br><span class="line">b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flag == <span class="number">1</span> ? negtive(res) : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> falg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (getSign(a) ^ getSign(b))</span><br><span class="line">falg = <span class="number">1</span>;</span><br><span class="line">a = PosAbs(a);</span><br><span class="line">b = PosAbs(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a&gt;=b)</span><br><span class="line">&#123;</span><br><span class="line">res = add(res, <span class="number">1</span>);</span><br><span class="line">a = Sub(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> falg == <span class="number">1</span> ? negtive(res) : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symmetric binary tree</title>
      <link href="/2018/10/09/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/"/>
      <url>/2018/10/09/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>思路：首先判断其根结点是否为空，然后判断左右结点是否对称，也就是左右结点是不是同时为空并且值相等</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> res = isTreeSymmetrical(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTreeSymmetrical</span><span class="params">(TreeNode* pHead1,TreeNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> &amp;&amp; pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((pHead1-&gt;val == pHead2-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> isTreeSymmetrical(pHead1-&gt;left,pHead2-&gt;right)&amp;&amp;isTreeSymmetrical(pHead1-&gt;right,pHead2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.TwoArrayIntesection</title>
      <link href="/2018/10/07/%20IntersectionofTwoArrays/"/>
      <url>/2018/10/07/%20IntersectionofTwoArrays/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Given two arrays, write a function to compute their intersection.</p><p>Example 1:</p><p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]<br>Example 2:</p><p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]<br>Note:</p><p>Each element in the result must be unique.<br>The result can be in any order.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet();</span><br><span class="line">Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">set1.add(nums1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (set1.contains(nums2[j])) &#123;</span><br><span class="line">set2.add(nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[set2.size()];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer n : set2) &#123;</span><br><span class="line">num[i] = n;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sum of the first n consecutive integers</title>
      <link href="/2018/10/06/%E6%B1%82%E5%89%8Dn%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C/"/>
      <url>/2018/10/06/%E6%B1%82%E5%89%8Dn%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>For 1 + 2 + 3 +… +n, you cannot use the multiplication/division, for, while, if, else, switch, case and other keywords and conditional judgment statement (A? B, C).</p><p>该题翻译过来就是求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。以下是给出的C解决方案</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>**思路：让其从最后一个数开始相加，直到n为0，则加完<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//辅助函数求和保存在i中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = i + n;</span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">return</span> Sum_Solution(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n==<span class="number">0</span> ? i : Sum(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表面试题</title>
      <link href="/2018/10/05/%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/10/05/%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>关于链表已经学了有一段时间了，今天抽空进行了整理，列出来常见的有关链表的面试题，以下想法如有瑕疵望批评指出，希望能给初学者带来一点参考和价值</p><h3 id="从尾到头打印单链表"><a href="#从尾到头打印单链表" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h3><h4 id="递归打印"><a href="#递归打印" class="headerlink" title="递归打印"></a>递归打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、从尾到头打印单链表 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReversePrint</span><span class="params">(ListNode *Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListReversePrint(Node-&gt;next);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d--&gt;"</span>,Node-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归打印"><a href="#非递归打印" class="headerlink" title="非递归打印"></a>非递归打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReveresePrint2</span><span class="params">(ListNode *Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *end = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (end != Node)</span><br><span class="line">&#123;</span><br><span class="line">ListNode *cur = Node;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != end)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d--&gt;"</span>,cur-&gt;data);</span><br><span class="line">end = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除一个无头单链表的非尾结点（不能遍历链表）"><a href="#删除一个无头单链表的非尾结点（不能遍历链表）" class="headerlink" title="删除一个无头单链表的非尾结点（不能遍历链表）"></a>删除一个无头单链表的非尾结点（不能遍历链表）</h3><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 删除一个无头单链表的非尾结点（不能遍历链表）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelNotFirst</span><span class="params">(ListNode **Node ,ListNode *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *del;</span><br><span class="line"><span class="keyword">if</span> (Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pos 位置为第一个结点时，修改指针</span></span><br><span class="line"><span class="keyword">if</span> (pos == *Node)</span><br><span class="line">&#123;</span><br><span class="line">*Node = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos 位置不是第一个结点时也不是最后一个结点时</span></span><br><span class="line">pos-&gt;data = pos-&gt;next-&gt;data;   <span class="comment">//先修改data的值</span></span><br><span class="line">del = pos-&gt;next;     <span class="comment">//将pos-&gt;next作为要删除的结点</span></span><br><span class="line">pos-&gt;next = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestListDelNotFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">ListPrint(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">ListDelNotFirst(<span class="built_in">list</span>,<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">ListPrint(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在无头单链表的一个结点前插入一个结点（不能遍历链表）"><a href="#在无头单链表的一个结点前插入一个结点（不能遍历链表）" class="headerlink" title="在无头单链表的一个结点前插入一个结点（不能遍历链表）"></a>在无头单链表的一个结点前插入一个结点（不能遍历链表）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.在无头单链表的一个结点前插入一个结点（不能遍历链表）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsertBefore</span><span class="params">(ListNode **Node ,ListNode *pos ,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *newNode;</span><br><span class="line"><span class="keyword">if</span> (*Node == <span class="literal">NULL</span> &amp;&amp; pos == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入的结点是在第一个结点上</span></span><br><span class="line"><span class="keyword">if</span> (pos == *Node)</span><br><span class="line">&#123;</span><br><span class="line">ListNode *newNode = CreateNode(data);</span><br><span class="line">newNode-&gt;next = *Node;</span><br><span class="line">*Node = newNode;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入的结点不是第一个结点时</span></span><br><span class="line">newNode = CreateNode(pos-&gt;data);</span><br><span class="line">newNode-&gt;next = pos-&gt;next;  <span class="comment">//后插</span></span><br><span class="line">pos-&gt;next = newNode;</span><br><span class="line">pos-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆置-反转单链表"><a href="#逆置-反转单链表" class="headerlink" title="逆置/反转单链表"></a>逆置/反转单链表</h3><h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>从第二个结点开始，将其删除，人挪活插在第一个结点处，直到链表结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReverse</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有一个结点</span></span><br><span class="line"><span class="keyword">if</span> ((*Node)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//至少两个结点</span></span><br><span class="line">ListNode *cur = *Node;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode *rm = cur-&gt;next;</span><br><span class="line">cur-&gt;next = rm-&gt;next;</span><br><span class="line">rm-&gt;next = *Node;</span><br><span class="line">*Node = rm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><p>改变每个结点的指针指向从而逆置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReverseRePoint</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Node)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *pre = *Node;</span><br><span class="line">ListNode *cur = (*Node)-&gt;next;</span><br><span class="line">pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode *temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line">pre =cur;</span><br><span class="line">cur = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*Node = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="找出两个链表里相同数据"><a href="#找出两个链表里相同数据" class="headerlink" title="找出两个链表里相同数据"></a>找出两个链表里相同数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 5.找出两个链表里相同数据</span><br><span class="line">void ListIntersection(ListNode *list1,ListNode *list2)</span><br><span class="line">&#123;</span><br><span class="line">ListNode *head1 = list1;</span><br><span class="line">ListNode *head2 = list2;</span><br><span class="line"></span><br><span class="line">DataType data;</span><br><span class="line"></span><br><span class="line">if (head1 ==NULL &amp;&amp; head2 == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (head1 != NULL &amp;&amp; head2 != NULL)</span><br><span class="line">&#123;</span><br><span class="line">if (head1-&gt;data &lt; head2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"> if (head1-&gt;data &gt; head2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (head1-&gt;data == head2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,head1-&gt;data);</span><br><span class="line">data = head1-&gt;data;</span><br><span class="line"></span><br><span class="line">while (head2 != NULL &amp;&amp; data == head2-&gt;data  )</span><br><span class="line">&#123;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">while (head1 != NULL &amp;&amp; data == head1-&gt;data )</span><br><span class="line">&#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestListInterstion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *list1 = <span class="literal">NULL</span>;</span><br><span class="line">ListNode *list2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;list1,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;list2,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">ListIntersection(list1,list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表实现约瑟夫环"><a href="#单链表实现约瑟夫环" class="headerlink" title="单链表实现约瑟夫环"></a>单链表实现约瑟夫环</h3><h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.单链表实现约瑟夫环</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ListJosephCircle</span><span class="params">(ListNode *<span class="built_in">list</span>,DataType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一步，变成环</span></span><br><span class="line">ListNode *tail = <span class="built_in">list</span>;</span><br><span class="line">ListNode *cur = <span class="built_in">list</span>;</span><br><span class="line">ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//第二步，找到第k个数</span></span><br><span class="line"><span class="keyword">while</span> ( cur-&gt;next != cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7 8 </span></span><br><span class="line"><span class="keyword">while</span> (--k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pre = cur;  <span class="comment">//记录剔除结点的前一个结点</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">&#123;</span><br><span class="line">pre = cur;  <span class="comment">//记录剔除结点的前一个结点</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre-&gt;next =cur-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"淘汰：%d\n"</span>,cur-&gt;data);</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line"></span><br><span class="line">cur = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestListJosephCircle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *list1 = <span class="literal">NULL</span>;</span><br><span class="line">ListNode *re;</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">5</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">ListPrint(list1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">re = ListJosephCircle(list1,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,re-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序的链表，合并后依然有序"><a href="#合并两个有序的链表，合并后依然有序" class="headerlink" title="合并两个有序的链表，合并后依然有序"></a>合并两个有序的链表，合并后依然有序</h3><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.合并两个有序的链表，合并后依然有序</span></span><br><span class="line"><span class="function">ListNode *<span class="title">ListMerge</span><span class="params">(ListNode *list1,ListNode *list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *cur1 = list1;</span><br><span class="line">ListNode *cur2 = list2;</span><br><span class="line">ListNode *result = <span class="literal">NULL</span>;<span class="comment">//结果链表</span></span><br><span class="line">ListNode *tail = <span class="literal">NULL</span>; <span class="comment">//结果链表中的最后一个结点，方便尾插</span></span><br><span class="line">ListNode *next = <span class="literal">NULL</span>;<span class="comment">//保存遍历过程中的下一个结点</span></span><br><span class="line">ListNode *node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 != <span class="literal">NULL</span> &amp;&amp; cur2 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur1-&gt;data &lt;= cur2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">node = cur1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">node =cur2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next = node-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = node;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">tail = node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == cur1)</span><br><span class="line">&#123;</span><br><span class="line">cur1 = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur2 = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个链表空了</span></span><br><span class="line"><span class="keyword">if</span> (cur1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next =cur2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur2 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next =cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMerge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *list1 = <span class="literal">NULL</span>;</span><br><span class="line">ListNode *list2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListNode *result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;list1,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;list1,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;list2,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;list2,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">result = ListMerge(list1,list2);</span><br><span class="line">ListPrint(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找单链表的中间结点，要求只能遍历一次链表"><a href="#查找单链表的中间结点，要求只能遍历一次链表" class="headerlink" title="查找单链表的中间结点，要求只能遍历一次链表"></a>查找单链表的中间结点，要求只能遍历一次链表</h3><p><strong>思路：定义快慢指针，当快指针走完时，慢指针刚好是在中间位置，好比是两人赛跑，跑的快点人的速度是慢的人的二倍</strong></p><h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.查找单链表的中间结点，要求只能遍历一次链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFindMidNode</span><span class="params">(ListNode *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *fast = <span class="built_in">list</span>;</span><br><span class="line">ListNode *slow = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,slow-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFindMid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">ListFindMidNode(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找单链表中的倒数第K个结点，要求只能遍历一次链表"><a href="#查找单链表中的倒数第K个结点，要求只能遍历一次链表" class="headerlink" title="查找单链表中的倒数第K个结点，要求只能遍历一次链表"></a>查找单链表中的倒数第K个结点，要求只能遍历一次链表</h3><p><strong>思路：定义快慢指针，快指针先走k步，满指针再开始走，快指针走完的时候就是慢指针走到倒数第k个结点处</strong></p><h4 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//9.查找单链表中的倒数第K个结点，要求只能遍历一次链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFindTailK</span><span class="params">(ListNode *<span class="built_in">list</span>,DataType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *fast = <span class="built_in">list</span>;</span><br><span class="line">ListNode *slow = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,slow-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFindTailK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">ListFindTailK(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除单链表中的倒数第K个结点"><a href="#删除单链表中的倒数第K个结点" class="headerlink" title="删除单链表中的倒数第K个结点"></a>删除单链表中的倒数第K个结点</h3><p><strong>思路：同查找倒数第k个结点一样，我们定义快慢指针进行异步，还需要定义一个pre来记录要删除结点的先驱，删除后需要指向被删除的下一个</strong></p><h4 id="具体代码-3"><a href="#具体代码-3" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10.删除单链表中的倒数第K个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelTailK</span><span class="params">(ListNode *<span class="built_in">list</span>, DataType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *fast = <span class="built_in">list</span>;</span><br><span class="line">ListNode *slow = <span class="built_in">list</span>;</span><br><span class="line">ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre = slow;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = slow-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(slow);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDelTailK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">ListPushBack(&amp;<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">ListPrint(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n删除倒数第%d个结点\n"</span>,<span class="number">3</span>);</span><br><span class="line">ListDelTailK(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"> ListDelNotFirst(<span class="built_in">list</span>,<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListPrint(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表基本操作</title>
      <link href="/2018/10/05/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/10/05/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>学习链表有段时间了，今天给大家整理了有关链表的基本操作，例如链表的创建、增、删、查等基本操作</p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br></pre></td></tr></table></figure><h3 id="头文件的定义"><a href="#头文件的定义" class="headerlink" title="头文件的定义"></a>头文件的定义</h3><p>其中包含了面试题的头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInit</span><span class="params">(ListNode **Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDestroy</span><span class="params">(ListNode **Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushFront</span><span class="params">(ListNode **Node,DataType data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushBack</span><span class="params">(ListNode **Node,DataType data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPopFront</span><span class="params">(ListNode **Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LIstPopBack</span><span class="params">(ListNode **Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">ListFind</span><span class="params">(ListNode *Node , DataType data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(ListNode **Node,ListNode *pos,DataType data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete</span><span class="params">(ListNode **Node,ListNode *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个无头单链表的非尾结点（不能遍历链表）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelNotFirst</span><span class="params">(ListNode **Node ,ListNode *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReversePrint</span><span class="params">(ListNode *Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListReveresePrint2</span><span class="params">(ListNode *Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPrint</span><span class="params">(ListNode *Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListIntersection</span><span class="params">(ListNode *list1,ListNode *list2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestListInterstion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">ListJosephCircle</span><span class="params">(ListNode *<span class="built_in">list</span>,DataType k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestListJosephCircle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">ListMerge</span><span class="params">(ListNode *list1,ListNode *list2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMerge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFindMidNode</span><span class="params">(ListNode *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFindMid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFindTailK</span><span class="params">(ListNode *<span class="built_in">list</span>,DataType k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFindTailK</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelTailK</span><span class="params">(ListNode *<span class="built_in">list</span>, DataType k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestDelTailK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="链表的具体基本操作-文件名-List-c"><a href="#链表的具体基本操作-文件名-List-c" class="headerlink" title="链表的具体基本操作 文件名(List.c)"></a>链表的具体基本操作 文件名(List.c)</h3><h4 id="链表的初始化及销毁"><a href="#链表的初始化及销毁" class="headerlink" title="链表的初始化及销毁"></a>链表的初始化及销毁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"List.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInit</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(Node != <span class="literal">NULL</span>);</span><br><span class="line">*Node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDestroy</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*Node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表结点的创建"><a href="#链表结点的创建" class="headerlink" title="链表结点的创建"></a>链表结点的创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ListNode * <span class="title">CreateNode</span><span class="params">(DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *newNode = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">assert(newNode);</span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushFront</span><span class="params">(ListNode **Node,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//assert(Node != NULL);</span></span><br><span class="line"></span><br><span class="line">ListNode *newNode = CreateNode(data); <span class="comment">// *newNode 用来存储新结点的地址</span></span><br><span class="line">newNode-&gt;next = *Node; <span class="comment">// 把头结点的地址赋给新结点 </span></span><br><span class="line"></span><br><span class="line">*Node = newNode;<span class="comment">// 把新结点的地址赋给头结点 （ *Node用来存储下一个结点的地址）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushBack</span><span class="params">(ListNode **Node,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *newNode = CreateNode(data);</span><br><span class="line"></span><br><span class="line">ListNode *cur = *Node;<span class="comment">//把头结点地址赋给cur</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*Node == <span class="literal">NULL</span>)<span class="comment">//判断头结点是否为空，如果为空，将新的结点赋给头结点（如果是空链表）</span></span><br><span class="line">&#123;</span><br><span class="line">*Node = newNode;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next !=<span class="literal">NULL</span>)<span class="comment">//如果头结点不为空，则将判断头结点指向下一个结点以及后面的结点是否为空</span></span><br><span class="line">&#123;<span class="comment">// 如果有空结点，则将赋给当前cur，</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;next = newNode;<span class="comment">//将新的结点地址赋给当前的下一结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头结点的删除"><a href="#头结点的删除" class="headerlink" title="头结点的删除"></a>头结点的删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPopFront</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//assert(Node != NULL);</span></span><br><span class="line"><span class="comment">//assert(*Node != NULL);</span></span><br><span class="line"></span><br><span class="line">ListNode *del = *Node;<span class="comment">// 将头结点的地址del，然后指向下一个结点并赋给Node，然后释放del（头结点存储在del中）</span></span><br><span class="line"></span><br><span class="line">*Node = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾结点的删除"><a href="#尾结点的删除" class="headerlink" title="尾结点的删除"></a>尾结点的删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPopBack</span><span class="params">(ListNode **Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*ListNode *del = *Node ;</span></span><br><span class="line"><span class="comment">while (del-&gt;next != NULL)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">del = del-&gt;next;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*Node = del-&gt;next; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">free(del);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode *del;</span><br><span class="line">ListNode *cur = *Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next-&gt;next != <span class="literal">NULL</span>)<span class="comment">// cur-&gt;next-&gt;next :头指针指向头结点，然后指向下一个结点</span></span><br><span class="line">&#123;<span class="comment">// 判断并找到最后一个结点的地址，赋给del</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">del = cur-&gt;next;</span><br><span class="line">cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ListFind</span><span class="params">(ListNode *Node , DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *cur;</span><br><span class="line"><span class="keyword">for</span> (cur = Node;cur != <span class="literal">NULL</span>;cur=cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data == cur-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结点前插入"><a href="#结点前插入" class="headerlink" title="结点前插入"></a>结点前插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某结点前插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(ListNode **Node,ListNode *pos,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *cur = *Node;</span><br><span class="line">ListNode *newNode;</span><br><span class="line"><span class="keyword">if</span> (*Node == pos)</span><br><span class="line">&#123;</span><br><span class="line">ListPopFront(Node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newNode = CreateNode(data);</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next =newNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除指定结点"><a href="#删除指定结点" class="headerlink" title="删除指定结点"></a>删除指定结点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete</span><span class="params">(ListNode **Node,ListNode *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *cur = *Node;</span><br><span class="line"><span class="keyword">if</span> (*Node == pos)</span><br><span class="line">&#123;</span><br><span class="line">ListPopFront(Node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的打印"><a href="#单链表的打印" class="headerlink" title="单链表的打印"></a>单链表的打印</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">ListPrint</span><span class="params">(ListNode *Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *cur = Node;</span><br><span class="line"><span class="keyword">if</span> (Node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d--&gt; "</span>,cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】跳台阶</title>
      <link href="/2018/10/02/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2018/10/02/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这是一个典型的斐波那契数问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归写法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jump(n - <span class="number">1</span>) + jump(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//非递归写法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = a+b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number&gt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = b; </span><br><span class="line">b = c;</span><br><span class="line">c = a + b;</span><br><span class="line">number--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fibonacci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb使用教程</title>
      <link href="/2018/10/02/gdb%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2018/10/02/gdb%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="GDB介绍"><a href="#GDB介绍" class="headerlink" title="GDB介绍"></a>GDB介绍</h3><p> GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VS等IDE的调试，但如果你是在UNIX平台下做软件，你会发现GDB这个调试工具有比VS的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。<br>一般来说，GDB主要帮忙你完成下面四个方面的功能：</p><ul><li>1、启动程序，按用户要求影响程序的运行行为</li><li>2、使运行程序在指定条件处停止（断点可以是条件表达式）</li><li>3、当程序被停住时，可以检查此时你的程序中出现的问题</li><li>4、动态的改变程序的执行环境，这样能纠正一个错误</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    result += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result[1-100]= %d\n"</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result[1-100]= %d\n"</span>,func(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成执行文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[liuxiaokun@localhost day10_1]$ cc test.c -o test</span><br></pre></td></tr></table></figure></p><h4 id="使用GDB调试"><a href="#使用GDB调试" class="headerlink" title="使用GDB调试"></a>使用GDB调试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[liuxiaokun@localhost day10_1]$ gdb test   ========&gt;&gt;&gt;启动GDB</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux (<span class="number">7.2</span><span class="number">-60.</span>el6_4<span class="number">.1</span>)</span><br><span class="line">Copyright (C) <span class="number">2010</span> Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version <span class="number">3</span> <span class="keyword">or</span> later &lt;http:<span class="comment">//gnu.org/licenses/gpl.html&gt;</span></span><br><span class="line">This is <span class="built_in">free</span> software: you are <span class="built_in">free</span> to change <span class="keyword">and</span> redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line"><span class="keyword">and</span> <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http:<span class="comment">//www.gnu.org/software/gdb/bugs/&gt;...</span></span><br><span class="line">Reading symbols from /home/liuxiaokun/code/C/day10_1/test...done.</span><br><span class="line">(gdb) l  ========&gt;&gt;&gt; l相当于<span class="built_in">list</span>从第一行列出源程序</span><br><span class="line"><span class="number">7</span>    &#123;</span><br><span class="line"><span class="number">8</span>sum += i;</span><br><span class="line"><span class="number">9</span>    &#125;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">return</span> sum;</span><br><span class="line"><span class="number">11</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">14</span>&#123;</span><br><span class="line"><span class="number">15</span>    <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">16</span>    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">(gdb)   ========&gt;&gt;&gt;直接回车，表示重复上一次命令</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line"><span class="number">18</span>    &#123;</span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line"><span class="number">20</span>    &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span>    <span class="built_in">printf</span>(<span class="string">"result[1-100]= %d\n"</span>,result);</span><br><span class="line"><span class="number">23</span>    </span><br><span class="line"><span class="number">24</span>    <span class="built_in">printf</span>(<span class="string">"result[1-100]= %d\n"</span>,func(<span class="number">250</span>));</span><br><span class="line"><span class="number">25</span>&#125;</span><br><span class="line">(gdb) <span class="keyword">break</span> <span class="number">19</span>  ========&gt;&gt;&gt;设置断点</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x40050b</span>: file test.c, line <span class="number">19.</span></span><br><span class="line">(gdb) <span class="keyword">break</span> func  ========&gt;&gt;&gt;设置断点，在函数的入口处</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x4004cb</span>: file test.c, line <span class="number">5.</span></span><br><span class="line">(gdb) info breakpoints  =========&gt;&gt;&gt;查看断点信息</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>       breakpoint     keep y   <span class="number">0x000000000040050b</span> in main at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">2</span>       breakpoint     keep y   <span class="number">0x00000000004004cb</span> in func at test.c:<span class="number">5</span></span><br><span class="line">(gdb) r     =======&gt;&gt;&gt;运行程序，run命令缩写</span><br><span class="line">Starting program: /home/liuxiaokun/code/C/day10_1/test </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span>   ========&gt;&gt;&gt;在断点处停住</span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc<span class="number">-2.12</span><span class="number">-1.132</span>.el6.x86_64</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) c   ========&gt;&gt;&gt;继续运行程序，<span class="keyword">continue</span>的缩写</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) p i  ========&gt;&gt;&gt;打印变量i的值，p是print的缩写</span><br><span class="line">$<span class="number">1</span> = <span class="number">5</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) p result</span><br><span class="line">$<span class="number">2</span> = <span class="number">28</span></span><br><span class="line">(gdb) bt ========&gt;&gt;&gt;查看函数堆栈</span><br><span class="line">#<span class="number">0</span>  main () at test.c:<span class="number">19</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  main () at test.c:<span class="number">17</span></span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  main () at test.c:<span class="number">19</span></span><br><span class="line">(gdb) finish    ========&gt;&gt;&gt;退出函数</span><br><span class="line"><span class="string">"finish"</span> <span class="keyword">not</span> meaningful in the outermost frame.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>result += i;</span><br><span class="line">(gdb) q     ==========&gt;&gt;&gt;退出gdb</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">Inferior <span class="number">1</span> [process <span class="number">4248</span>] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n)</span><br></pre></td></tr></table></figure><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><p>通过以上案例，我们对GDB有了大概的了解，接下来就系统的认识GDB吧</p><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的<br>-g 参数可以做到这一点。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -g test.c -o test</span><br><span class="line">&gt; g++ -g test.cpp -o test</span><br></pre></td></tr></table></figure></p><p>==如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。==</p><p><strong>启动gdb的方法有以下几种：</strong></p><ol><li>gdb <program><br>program<br>  就是可执行文件，一般就在当前目录下</program></li><li>gdb <program>  core<br> 用gdb同时调试一个运行程序和core文件，core==是非法执行后==core dump 后产生的文件</program></li><li>gdb <program> <pid><br> 如果是一个服务程序，就可以指定服务程序运行时的进程ID，gdb会自动的attach上去，并调试他，program应该在path环境变量中搜索得到   </pid></program></li></ol><p><strong>当然，gdb启动时我们可以加一些参数，详细的参数可以用gdb -help查看</strong></p><h5 id="GDB命令概貌"><a href="#GDB命令概貌" class="headerlink" title="GDB命令概貌"></a>GDB命令概貌</h5><p>启动gdb后，就你被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb的命令可以使用help命令来查看，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br></pre></td></tr></table></figure></p><p>gdb的命令有很多，所以gdb命令有分类，help只是列出了命令的种类，查看类中的命令使用==help <class>== 命令，如：==help breakpoint==，查看设置断点的所有命令 </class></p><p>gdb中，可以不用大全命令，只用命令的前几个字符就可以了，当然也可以两次Tab将命令补全，如果有重复，就会列出了</p><ul><li><p>示例一：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> func</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4004c8</span></span><br></pre></td></tr></table></figure></li><li><p>示例二：敲入b按两次TAB键，你会看到所有b打头的命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b</span><br><span class="line">backtrace  bookmark   <span class="keyword">break</span>      bt</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux -gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.ThreeSum</title>
      <link href="/2018/09/25/ThreeSum/"/>
      <url>/2018/09/25/ThreeSum/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums != <span class="keyword">null</span> &amp;&amp;nums.length &gt;<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先对数组进行排序</span></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">//我们假设取第 i 个数为结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第二个数的可能起始位置</span></span><br><span class="line"><span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//第三个数的可能起始位置</span></span><br><span class="line"><span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] + nums[k] == -nums[i]) &#123;</span><br><span class="line"><span class="comment">//当我们找到满足条件的解时，我们将结果添加到结果集里</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">list.add(nums[i]);</span><br><span class="line">list.add(nums[j]);</span><br><span class="line">list.add(nums[k]);</span><br><span class="line">result.add(list);</span><br><span class="line"><span class="comment">//移动位置寻找下一组解</span></span><br><span class="line">k--;</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个while是用来判断是否越界和判断移动后的数是否和之前的数相同，若相同则跳过该数</span></span><br><span class="line"><span class="keyword">while</span> (j&lt;k &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j&lt;k&amp;&amp;nums[k] == nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和大于 0，让k向前移动到小一点的数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[j]+nums[k]&gt;-nums[i]) &#123;</span><br><span class="line">k--;</span><br><span class="line"><span class="comment">//下面是用来判断是否越界和判断移动后的数是否和之前的数相同，若相同则跳过该数</span></span><br><span class="line"><span class="keyword">while</span> (j&lt;k&amp;&amp;nums[k] == nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和小于 0，让j向后移动到大一点的数</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="comment">//下面是用来判断是否越界和判断移动后的数是否和之前的数相同，若相同则跳过该数</span></span><br><span class="line"><span class="keyword">while</span> (j&lt;k&amp;&amp;nums[j] == nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向下一个要处理的数</span></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//从左向右找第一个与之前处理的数的不同的数的下标</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;nums.length-<span class="number">2</span>&amp;&amp;nums[i] == nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile工具使用</title>
      <link href="/2018/09/24/Makefile%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/24/Makefile%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>Makefile是一个c语言的编译工具。如果学过Java，可能会认识Maven工具，makefile也是类似的工作。<br>Makefile能帮助c语言建立自动化的编译。一旦写好，执行一个make命令就可以编译整个工程。当然编写Makefile文件的时候有很多知识点在里面。这篇文章主要讲解如何编写基础性以及常用的Makefile文件。</p><h3 id="没有Makefile工具时如何进行编译"><a href="#没有Makefile工具时如何进行编译" class="headerlink" title="没有Makefile工具时如何进行编译"></a>没有Makefile工具时如何进行编译</h3><p>首先我们看一个例子：<br>当前我们有3个文件，分别是test.h test.c main.c<br>在main.c中,头文件定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.h"</span></span></span><br></pre></td></tr></table></figure></p><p>在test.h中,头文件定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"test.c"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_print</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>在test.c中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is test.c \n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们编译运行程序时，我们使用的命令是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.h main.c -o main</span><br></pre></td></tr></table></figure></p><p>运行结果就是<br>    this is test.c   </p><p>对于小程序我们可以使用这样的命令，但是当我们这样运行一个大项目时，我们需要多少文件名来定义，此时Makefile就是一个很好的工具</p><h3 id="makefile简单示例"><a href="#makefile简单示例" class="headerlink" title="makefile简单示例"></a>makefile简单示例</h3><p>就如上面的三个文件<br>我们vim 一个名为Makefile的文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o:test.o main.c</span><br><span class="line">    gcc test.o main.c</span><br><span class="line">test.o:test.c</span><br><span class="line">    gcc -c test.c</span><br></pre></td></tr></table></figure></p><p>编辑好Makefile文件后，我们返回，执行make后，将会输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c   </span><br><span class="line">gcc test.o main.c</span><br></pre></td></tr></table></figure></p><p>这样是不是比原始的编译方便很多呢。其实也不是罪方便的，既然发明了make工具，那么肯定会让make工具更加方便开发人员使用的。</p><h3 id="Makefile具体使用"><a href="#Makefile具体使用" class="headerlink" title="Makefile具体使用"></a>Makefile具体使用</h3><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>伪目标：不管是不是最新的，都需要重新生成；使用.PHONY来声明一个目标是伪目标；执行伪目标的效果等于执行了某一个动作，并不产生目标文件。例如添加一个伪目标：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.o:test.o main.c</span><br><span class="line">    gcc test.o main.c</span><br><span class="line">test.o:test.c</span><br><span class="line">    gcc -c test.c</span><br><span class="line">clean :                                        【这是一个伪目标】</span><br><span class="line">        rm -f $(OBJECTS) main</span><br></pre></td></tr></table></figure></p><p>使用make来执行伪目标<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f test.o main.c main.o</span><br></pre></td></tr></table></figure></p><h4 id="Makefile自动变量"><a href="#Makefile自动变量" class="headerlink" title="Makefile自动变量"></a>Makefile自动变量</h4><table><thead><tr><th>选项名</th><th>作用</th></tr></thead><tbody><tr><td>$@</td><td>编写规则中啊哟生成的目标对象</td></tr><tr><td>$^</td><td>编写规则中所有依赖文件列表</td></tr><tr><td>$&lt;</td><td>编写规定中第一个依赖对象</td></tr></tbody></table><p>因此，上面的Makefile文件我们可以改下如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o:test.o main.c</span><br><span class="line">    gcc -g $^ -o $@</span><br><span class="line">test.o:test.c</span><br><span class="line">    gcc -g -c  $&lt; -o $@</span><br></pre></td></tr></table></figure></p><p>执行make，可以看到效果还是一样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c   </span><br><span class="line">gcc test.o main.c</span><br></pre></td></tr></table></figure></p><h4 id="编译生成多个可执行文件"><a href="#编译生成多个可执行文件" class="headerlink" title="编译生成多个可执行文件"></a>编译生成多个可执行文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bin=main main2   <span class="comment">//自定义变量bin</span></span><br><span class="line">src=main.o test.o</span><br><span class="line">all:$(bin)    <span class="comment">//重点</span></span><br><span class="line">main: $(src)</span><br><span class="line">    gcc -g $^ -o $@</span><br><span class="line">main2:$(bin)</span><br><span class="line">    gcc -g $&lt; -o $@</span><br><span class="line">main.o :main.c</span><br><span class="line">    gcc -g -c $&lt; -o $@</span><br><span class="line">main2.o :main2.c</span><br><span class="line">    gcc -g -c $&lt; -o $@</span><br><span class="line">clean :</span><br><span class="line">    rm -f $(src) $(bin)</span><br></pre></td></tr></table></figure><p>为了生成目标文件all，需要生成bin，也就是main main2.这样就生成了两个可执行文件，利用自定义变量可以简化这段Makefile，但是这样写看起来内容其实还是很多的，因此下面我将介绍make的内嵌函数</p><h4 id="make常用内嵌函数"><a href="#make常用内嵌函数" class="headerlink" title="make常用内嵌函数"></a>make常用内嵌函数</h4><p>首先看到make中函数的调用形式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(function arguments)   <span class="comment">//functions是函数名称，arguments是参数，使用$来调用</span></span><br></pre></td></tr></table></figure></p><p><strong><em>函数名与参数之间是空格</em></strong><br>以下三个重要的内嵌函数</p><ul><li><p>$(wildcard path)<br>  当前目录下匹配模式的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)  <span class="comment">// 在当前目录下搜索所以.c文件，文件名称保存到src中</span></span><br></pre></td></tr></table></figure></li><li><p>$(patsubst pattern,replacement,text)模式替换函数，就是把text中文件列表从模式pattern替换为replacement模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,$src)  <span class="comment">// 把src中的.c文件列表中的文件从.c替换为.o</span></span><br><span class="line">等价于：$(src:.c=.o)  <span class="comment">//这种方式更为常用</span></span><br></pre></td></tr></table></figure></li><li><p>shell函数<br>shell函数可以执行shell下的命令，同样是使用$来引用的，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(shell ls -d */)  <span class="comment">//将当前目录下的所有文件列出来</span></span><br></pre></td></tr></table></figure></li></ul><p>下面我们通过一个例子来使用上面三个函数。假设当前目录下有main.c文件，同时还有若干个目录，每个目录中都有各自的.c文件，利用所有的.c文件编译生成最后的main文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CC      = gcc</span><br><span class="line">CFLAGS  = -g</span><br><span class="line">BIN     = main</span><br><span class="line">SUBDIR  = $(shell ls -d */)     <span class="comment">// SUBDIR变量保存了子目录的列表</span></span><br><span class="line">ROOTSRC = $(wildcard *.c)       <span class="comment">//ROOTSRC保存了当前目录下的.c文件列表</span></span><br><span class="line">ROOTOBJ = $(ROOTSRC:%.c = %.o)  <span class="comment">//ROOTBOJ 保存了当前目录下.c文件同名的.o列表</span></span><br><span class="line">SUBSRC  = $(shell find $(SUBDIR) -name '*.c')       //SUBSRC 保存了所有子目录下的的.c文件</span><br><span class="line">SUBOBJ  = $(SUBSRC:%.c = %.o)       <span class="comment">//SUBOBJ保存了所有子目录下的.c文件同名的.o文件列表</span></span><br><span class="line">$(BIN):$(ROOTOBJ) $(SUBOBJ)         <span class="comment">//main的生成依赖与当前目录及所有子目录下的.o文件</span></span><br><span class="line">    $(CC) $(CFLAGS) -o $(BIN) $(ROOTOBJ) $(SUBOBJ)</span><br><span class="line">.o .c:</span><br><span class="line">    $(CC) $(CFLAGS) -c %&lt; -o $@</span><br><span class="line">clean:</span><br><span class="line">    rm -f $(BIN) $(ROOTOBJ) $(SUBOBJ)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用命令大全</title>
      <link href="/2018/09/23/vim%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2018/09/23/vim%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>不知不觉，vim已经使用快一年了，虽然不是经常使用，这就导致每次使用时一些命令还是模糊，需要查查文档才能正确使用，因此就这篇博客分享给学习Linux的小伙伴们。</p><h3 id="vim介绍"><a href="#vim介绍" class="headerlink" title="vim介绍"></a>vim介绍</h3><p>vim是程序员最喜欢的编辑器，也是Linux下第二强大的编辑器，虽然emacs是公认的世界第一，但我认为emacs并没有vim用起来高效。</p><h4 id="vim的几种模式"><a href="#vim的几种模式" class="headerlink" title="vim的几种模式"></a>vim的几种模式</h4><ul><li>正常模式：可以使用快捷键命令，或按输入命令</li><li>插入模式：可以输入文本，在正常模式下，按i，a，o等都可以进入插入模式</li><li>可视模式：正常模式下按v可进入可视模式，在可视模式下，移动光标可以选择文本，按v进入可视模式后，总是整行整行的选中。Ctrl+v进入可视块模式。</li></ul><h3 id="vim的安装"><a href="#vim的安装" class="headerlink" title="vim的安装"></a>vim的安装</h3><ol><li><p>在线安装<br>直接shell中输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim (ubuntu)</span><br><span class="line">yum install vim (redHat/Fedora/CentOS)</span><br></pre></td></tr></table></figure></li><li><p>手动下载编译安装<br>截止当前最新版本是7.4(vim-7.4.tar.bz2)，可在windows环境下载好，拷贝至linux环境安装，或直接linux命令行下载。这里给出 linux直接下载并编译安装（以下均为shell命令）：   </p></li></ol><ul><li>wget下载</li></ul><p>wget ftp://ftp.vim.org/ftp/pub/vim/unix/vim-7.4.tar.bz2<br>(或用ftp命令登陆ftp://ftp.vim.org，get命令获取)</p><ul><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bunzip2 vim-7.4.tar.bz2</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf vim-7.4.tar</span><br></pre></td></tr></table></figure></li><li><p>进入vim74（解压后的）目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --disable-selinux --enable-cscope</span><br><span class="line">(./configure -help 查看后面参数选项的含义)</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><p>只要不出现error即代表成功安装，也可直接用vim命令来检测，或whatis vim(whereis vim)查看。通常情况下，许多发行版会默认安装vim，则可省略上述步骤。</p><h3 id="vim的初始化配置-vimrc"><a href="#vim的初始化配置-vimrc" class="headerlink" title="vim的初始化配置.vimrc"></a>vim的初始化配置.vimrc</h3><ol><li>存放位置<br>linux环境下vim的初始化配置文件为.vimrc, 通常有两个:系统版本和用户版本，前者不同发行版linux会有不同，一般位于/etc/vimrc，是整个系统vim的默认配置；后者位于~/.vimrc，是当前用户的vim配置，会覆盖系统配置。<br>关于vim的其他配置参数文件位于/usr/local/share/vim/下，可进入vim，在命令模式下键入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:version （查看基本配置路径）</span><br><span class="line">:echo $VIM ( WINDOW用户在次目录下编辑文件_vimrc完成下面配置 )</span><br><span class="line">:echo $HOME（查看具体路径值）</span><br><span class="line"> ~/.vimrc有时并不存在，此时用户可以建立一个.vimrc，放入主目录以实现自己的vim配置。</span><br></pre></td></tr></table></figure></li></ol><h3 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h3><ul><li>vim -c cmd file：在打开文件前，先执行指定的命令</li><li>vim -r file：恢复上次异常退出的文件</li><li>vim -R file：以只读的方式打开文件，但可以强制保存</li><li>vim -M file：以只读方式打开文件，不可以强制保存</li><li>vim -y num file：将编辑窗口的大小设为num行</li><li>vim+file：从文件的末尾开始</li><li>vim+num file：从第num行开始</li><li>vim+/string file：打开file，并将光标停留在第一个找到的string上</li><li>vim -remote file：用已有的vim进程打开指定的文件。如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li></ul><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><ul><li>e file -关闭当前编辑的文件，并开启新的文件。如果当前文件的修改未保存，vi会警告</li><li>e! file -放弃当前文件的修改，编辑新的文件</li><li>e+n file -开始新的文件，并从第n行开始编辑</li><li>enew -编译一个未命名的新文档（Ctrl-W n）</li><li>e – 重新加载当前文档。</li><li>e! – 重新加载当前文档，并丢弃已做的改动。</li><li>e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li><li>f或ctrl+g –显示文档名，是否修改，和光标位置。</li><li>f filename – 改变编辑的文件名，这时再保存相当于另存为。</li><li>gf – 打开以光标所在字符串为文件名的文件。</li><li>w – 保存修改。</li><li>n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li><li>wq – 保存并退出。</li><li>ZZ – 保存并退出。</li><li>x – 保存并退出。</li><li>q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li><li>saveas newfilename – 另存为</li><li>browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上</li><li>browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：</li><li>set browsedir=last – 用上次访问过的目录（默认）；</li><li>set browsedir=buffer – 用当前文件所在目录；</li><li>set browsedir=current – 用当前工作目录；</li><li>Sex – 水平分割一个窗口，浏览文件系统；</li><li>Vex – 垂直分割一个窗口，浏览文件系统；</li></ul><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><h4 id="基本移动"><a href="#基本移动" class="headerlink" title="基本移动"></a>基本移动</h4><p><strong>在正常模式下</strong></p><ul><li>h或退格：左移一个字符</li><li>I或空格：右移一个字符</li><li>j：下移一行</li><li>k：上移一行</li><li>gj：移动到一段内的下一行</li><li>gk：移动到一段内的上一行</li><li>+或者enter：把光标移至下一行第一个非空白字符</li><li>-：把光标移至上一行第一个非空白字符</li><li>w：移动一个单词，可忽略一些标点</li><li>e：前移一个单词，光标停在下一个单词末尾</li><li>E：移动到下一个单词末尾，如果词末尾有标点，则移动到标点</li><li>b：后移一个单词，光标停在上一个单词开头</li><li>B：移动到上一个单词开头，忽略一些标点</li><li>ge：后移一个单词，光标停在上一个单词末尾</li><li>gE：同ge，不过单词包含单词相邻的标点</li><li>(: 前移1句。</li><li>): 后移1句。</li><li>{: 前移1段。</li><li>}: 后移1段。</li><li>fc: 把光标移到同一行的下一个c字符处</li><li>Fc: 把光标移到同一行的上一个c字符处</li><li>tc: 把光标移到同一行的下一个c字符前</li><li>Tc: 把光标移到同一行的上一个c字符后</li><li>;: 配合f &amp; t使用，重复一次</li><li>,: 配合f &amp; t使用，反向重复一次</li><li>0：移到首行</li><li>g0：移到光标所在行行首</li><li>^：移到本行第一个非空白字符</li><li>g^：同^，但是移到到当前第一个非空字符处</li><li>n|：光标移动到第n行</li><li>:n<cr> :移动到第n行</cr></li><li>:$<cr> :移动到最后一行</cr></li><li>H：把光标移动到最顶端一行</li><li>M：把光标移动到最中间一行</li><li>L：把光标移动到最底端一行</li><li>gg：到文件头部</li><li>G：到文件尾部</li></ul><h4 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h4><ul><li>Ctrl+f： 下翻一屏。</li><li>Ctrl+b: 上翻一屏。</li><li>Ctrl+d: 下翻半屏。</li><li>Ctrl+u: 上翻半屏。</li><li>Ctrl+e: 向下滚动一行。</li><li>Ctrl+y: 向上滚动一行。</li><li>n%: 到文件n%的位置。</li><li>zz: 将当前行移动到屏幕中央。</li><li>zt: 将当前行移动到屏幕顶端。</li><li>zb: 将当前行移动到屏幕底端。</li></ul><h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置Ctrl+o和Ctrl+i很像浏览器上的 后退 和 前进 。</p><ul><li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li><li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>`{a-z}: 移动到标记位置。</li><li>‘{a-z}: 移动到标记行的行首。</li><li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li><li>“: 移动到上次编辑的位置。”也可以，不过“精确到列，而”精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li><li>`”: 移动到上次离开的地方。</li><li>`.: 移动到最后改动的地方。</li><li>:marks 显示所有标记。</li><li>:delmarks a b – 删除标记a和b。</li><li>:delmarks a-c – 删除标记a、b和c。</li><li>:delmarks a c-f – 删除标记a、c、d、e、f。</li><li>:delmarks! – 删除当前缓冲区的所有标记。</li><li>:help mark-motions 查看更多关于mark的知识。</li></ul><h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><h4 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h4><ul><li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</esc></li><li>I: 在当前行第一个非空字符前插入；</li><li>gI: 在当前行第一列插入；</li><li>a: 在光标后插入；</li><li>A: 在当前行最后插入；</li><li>o: 在下面新建一行插入；</li><li>O: 在上面新建一行插入；</li><li>:r filename在当前位置插入另一个文件的内容。</li><li>:[n]r filename在第n行插入另一个文件的内容。</li><li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li></ul><h4 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h4><ul><li>c[n]w：改写光标后第n个次</li><li>c[n]I：改写光标后的n个字母</li><li>c[n]h：改写光标前的n个字母</li><li>[n]cc：修改当前[n]行</li><li>[n]s：以输入的文本替代光标之后1(n)个字符</li><li>[n]S：删除指定数目的行，并以所输入文本代替</li></ul><h3 id="剪切复制和寄存器"><a href="#剪切复制和寄存器" class="headerlink" title="剪切复制和寄存器"></a>剪切复制和寄存器</h3><h4 id="剪切和复制、粘贴"><a href="#剪切和复制、粘贴" class="headerlink" title="剪切和复制、粘贴"></a>剪切和复制、粘贴</h4><ul><li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li><li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li><li>y: 复制在可视模式下选中的文本。</li><li>yy or Y: 复制整行文本。</li><li>y[n]w: 复制一(n)个词。</li><li>y[n]l: 复制光标右边1(n)个字符。</li><li>y[n]h: 复制光标左边1(n)个字符。</li><li>yor D: 删除（剪切）当前位置到行尾的内容。</li><li>d[n]w: 删除（剪切）1(n)个单词</li><li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li><li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li><li>d0: 删除（剪切）当前位置到行首的内容</li><li>[n] dd: 删除（剪切）1(n)行。</li><li>:m,nd<cr> 剪切m行到n行的内容。</cr></li><li>d1G或dgg: 剪切光标以上的所有行。</li><li>dG: 剪切光标以下的所有行。</li><li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</cr></li><li>p: 在光标之后粘贴。</li><li>P: 在光标之前粘贴。</li></ul><p><strong><em>当然，我们也可以在视图模式下进行选择，然后进行复制剪切粘贴操作</em></strong></p><h4 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h4><ul><li>aw：一个词</li><li>as：一句</li><li>ap：一段</li><li>ab：一块<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4></li><li>a-z：都可以用作寄存器的名。“ayy把当前行的内容放入a寄存器。</li><li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。</li><li>:reg：显示所有寄存器的内容</li><li>“”：不加寄存器索引时，默认使用的寄存器</li><li>“<em>：当前选择缓冲区，”</em>yy吧当前行的内容放入当前缓冲区。</li><li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li></ul><h3 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h3><h4 id="一次编辑多个文件"><a href="#一次编辑多个文件" class="headerlink" title="一次编辑多个文件"></a>一次编辑多个文件</h4><pre><code>打开文件时：vi a.txt b.txt c.txt</code></pre><ul><li>使用：next(:n)编辑下一个文件</li><li>:2n编辑下2个文件</li><li>使用:previous或:N编辑上一个文件</li><li>使用:wnext，保存当前文件，并编辑下一个文件</li><li>使用:wprevious，保存当前文件，并编辑上一个文件</li><li>使用:args显示文件列表</li><li>:n filename或:args filename 指定新的文件列表</li><li>vi -o filename 在水平分割线的多个窗口编辑多个文件</li><li>vi -o filename 在垂直分割的多个窗口中编辑多个文件</li><li>vnew 在当前编辑文件时新增加一个编辑文件，:w filename 保存为filename的文件<h3 id="分屏编辑"><a href="#分屏编辑" class="headerlink" title="分屏编辑"></a>分屏编辑</h3></li><li>vim -o file1 file2 ：水平分割窗口，同时打开file1和file2</li><li>vim -O file1 file2 ：垂直分割窗口，同时打开file1和file2<h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4></li><li>split(:sp) 把当前窗水平分割成两个窗口。(Ctrl-W s 或Ctrl-W ctrl-S)如果是在终端下，Ctrl-S可能会冻结终端，Ctrl-Q继续</li><li>split filename  水平分割窗口，并在新窗口中显示另外一个文件</li><li>nsplit(:nsp) 水平分割出一个n行高的窗口</li><li>C-W C-^ 水平分割一个窗口，打开刚才编辑的文件<h4 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h4></li><li>:vsplit(:vsp) 把当前窗口分割成水平分布的两个窗口</li><li>:[N]vne[W] 垂直分割出一各新窗口</li><li>:vertical 水平分割的命令，相应的垂直分割<h4 id="关闭子窗口"><a href="#关闭子窗口" class="headerlink" title="关闭子窗口"></a>关闭子窗口</h4></li><li>:qall  关闭所有窗口，退出vim</li><li>:wall 保存所有修改过的窗口</li><li>:only 只保留当前窗口，关闭其它窗口</li><li>:close 关闭当前窗口，Ctrl-W c能实现同样的功能<h4 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h4></li><li>Ctrl+w+  当前窗口增高一行。也可用n增高n行</li><li>Ctrl+w-  当前窗口减少一行。也可用n减少n行</li><li>Ctrl+w_  当前窗口扩展到尽可能的大。也可用n设定行数</li><li>resize n 当前窗口n行高</li><li>Ctrl+w&lt; 当前窗口减少一列。也可用n减少n列</li><li>Ctrl+w&gt; 当前窗口增加一列。也可用n增加n列<h4 id="切换和移动窗口"><a href="#切换和移动窗口" class="headerlink" title="切换和移动窗口"></a>切换和移动窗口</h4></li><li>Ctrl+w Ctrl+w 切换到下一个窗口(Ctrl+w w)</li><li>Ctrl+w p 切换到前一个窗口</li><li>Ctrl+w h(l,j,k) 切换到左（右，下，上）面</li><li>Ctrl+w r 旋转窗口位置</li><li>Ctrl+w T 将当前的窗口移动到新的标签页上</li></ul><h3 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h3><h4 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h4><ul><li>~: 反转光标所在字符的大小写</li><li>可视模式下的U或u：把选中的文本变为大写或小写</li><li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。<h4 id="替换（正常模式）"><a href="#替换（正常模式）" class="headerlink" title="替换（正常模式）"></a>替换（正常模式）</h4></li><li>r: 替换光标处的字符，同样支持汉字。</li><li>R: 进入替换模式，按esc回到正常模式。</li></ul><h4 id="撤销与重做（正常模式）"><a href="#撤销与重做（正常模式）" class="headerlink" title="撤销与重做（正常模式）"></a>撤销与重做（正常模式）</h4><ul><li>[n] u: 取消一(n)个改动。</li><li>:undo 5 – 撤销5个改变。</li><li>:undolist – 你的撤销历史。</li><li>ctrl + r: 重做最后的改动。</li><li>U: 取消当前行中所有的改动。</li><li>:earlier 4m – 回到4分钟前</li><li>:later 55s – 前进55秒<h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4></li><li>–重复上一个编辑动作</li><li>qa：开始录制宏a（键盘操作记录）</li><li>q：停止录制</li><li>@a：播放宏a</li></ul><h3 id="编辑特殊文件"><a href="#编辑特殊文件" class="headerlink" title="编辑特殊文件"></a>编辑特殊文件</h3><h4 id="文件加解密"><a href="#文件加解密" class="headerlink" title="文件加解密"></a>文件加解密</h4><ul><li>vim -x file 开始编辑一个加密文件</li><li>:X 为当前文件设置加密</li><li>:set key= 去除文件的密码<h4 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h4></li><li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li><li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li><li>:set fenc或:setfileencoding，查看当前文件的编码。</li><li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li></ul><h3 id="编程辅助"><a href="#编程辅助" class="headerlink" title="编程辅助"></a>编程辅助</h3><ul><li>gd: 跳转到局部变量的定义处；</li><li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li>g;: 上一个修改过的地方；</li><li>g,: 下一个修改过的地方；</li><li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li><li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li><li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li><li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li><li>[{: 跳转到当前块开始处；</li><li>]}: 跳转到当前块结束处；</li><li>[/: 跳转到当前注释块开始处；</li><li>]/: 跳转到当前注释块结束处；</li><li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88.MergeTwoSortedArray</title>
      <link href="/2018/09/20/MergeTwoSortedArray/"/>
      <url>/2018/09/20/MergeTwoSortedArray/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>思路：申请一个大小是两个数组的临时空间用了存放排序后的元素，先对两个数组中的元素进行判断，小的放进临时数组中，直到一个数组放完后，把另外一个数组中的元素全部拷贝进去，最后将临时数组中的元素拷贝到原数组中。<br>以下是代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *tmp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(m+n));</span><br><span class="line">assert(tmp);</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>, m + n);</span><br><span class="line"><span class="keyword">while</span> (cur1 &lt; m &amp;&amp; cur2 &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums1[cur1] &lt; nums2[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[index] = nums1[cur1];</span><br><span class="line">index++;</span><br><span class="line">cur1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums1[cur1] &gt; nums2[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[index] = nums2[cur2];</span><br><span class="line">index++;</span><br><span class="line">cur2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums1[cur1] == nums2[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[index] = nums1[cur1];</span><br><span class="line">index++;</span><br><span class="line">tmp[index] = nums2[cur2];</span><br><span class="line">index++;</span><br><span class="line">cur1++;</span><br><span class="line">cur2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nums2没有元素，但nums1还有元素时，拷贝到tmp中</span></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt; m)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = nums1[cur1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nums1没有元素，但nums2还有元素时，拷贝到tmp中</span></span><br><span class="line"><span class="keyword">while</span> (cur2 &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = nums2[cur2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的元素放回nums1中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+n; i++)</span><br><span class="line">&#123;</span><br><span class="line">nums1[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放掉申请的空间</span></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看了上面的代码，发现又长又繁琐，我们对其简化后的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *nums1,<span class="keyword">int</span> m,<span class="keyword">int</span> *nums2,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = m + n - <span class="number">1</span>;</span><br><span class="line">--m, --n;</span><br><span class="line"><span class="keyword">while</span> (n&gt;=<span class="number">0</span> &amp;&amp; m&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">nums1[count--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">nums1[count--] = nums1[m--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80.RemoveDuplicates2</title>
      <link href="/2018/09/18/RemoveDuplicates2/"/>
      <url>/2018/09/18/RemoveDuplicates2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p><p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p><p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn\’t matter what you leave beyond the new length.   </p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>思路</strong>：这道题是继Remove Duplicates from Sorted Array有序数组中出去重复项，这里运行最多重复次数是二次，因此我们需要定义一个count来记录重复次数，count初始化为1，当出现一次时count减1，下次再重复出现时，快指针直接前进一步，如果这时不是重复的则count恢复为1，该数组是有序的，所以一旦不出现重复的数，后面的数一定比这个数大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j&lt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当nums[i]== nums[j]，count == 0时，此时这个数是第一次和后面的一个数相等</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">//此时判断是否与后面的数还能相等，相等时就 --count，</span></span><br><span class="line"><span class="comment">//否则不相等count还是1，说明这个数只出现两次</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">--count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时我们让第二次出现的这个数后移动一位，并放在这个数后面</span></span><br><span class="line">nums[++i] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26.RemoveDuplicates|</title>
      <link href="/2018/09/18/RemoveDuplicates1/"/>
      <url>/2018/09/18/RemoveDuplicates1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>For example,<br>Given input array nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn\’t matter what you leave beyond the new length.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>思路</strong>：这道题是让我们去掉数组里重复项，我们使用快慢指针来记录遍历的坐标，最开始两个指针指向第一个数，如果相同，快指针走一步，如果不同，都走一步，当快指针走完整个数组时，慢指针当前的坐标加1就是数组中不同数字的个数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numsSize &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsSize; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != nums[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySqrt</title>
      <link href="/2018/09/16/mySqrt/"/>
      <url>/2018/09/16/mySqrt/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>通过二分法来确定取值区间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> res = x;</span><br><span class="line"><span class="keyword">while</span> (res*res &gt; x)</span><br><span class="line">&#123;</span><br><span class="line">res = (res + x / res) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表(下)</title>
      <link href="/2018/09/14/%E5%93%88%E5%B8%8C%E8%A1%A8(%E4%B8%8B)/"/>
      <url>/2018/09/14/%E5%93%88%E5%B8%8C%E8%A1%A8(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="哈希冲突的开散列方式"><a href="#哈希冲突的开散列方式" class="headerlink" title="哈希冲突的开散列方式"></a>哈希冲突的开散列方式</h3><p>在我的博客<a href="hhttps://LiuZiQiao.github.io/2018/09/07/哈希表(上">哈希表上</a>中详细介绍了哈希的概念以及处理哈希冲突的闭散列方式。在本文章中，主要介绍处理哈希冲突的另一种方式：开散列(链地址)。</p><h4 id="开散列的概念"><a href="#开散列的概念" class="headerlink" title="开散列的概念"></a>开散列的概念</h4><p>开散列：又叫链地址法、开链法。首先对关键码集合用哈希函数计算哈希地址，具有相同哈希地址的关键码归于同一子集合中，每一个子集合称为一个桶，各个桶中的元素通过一个单链表的方式链接起来（可以头插的方式将桶中元素链接起来），链表的第一个节点存放在哈希表中。</p><h4 id="代码实现部分"><a href="#代码实现部分" class="headerlink" title="代码实现部分"></a>代码实现部分</h4><p>关于代码的编程思路，在具体代码中有详细的说明！</p><h5 id="头文件的定义"><a href="#头文件的定义" class="headerlink" title="头文件的定义"></a>头文件的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashBucket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KeyType size;</span><br><span class="line">KeyType capacity;</span><br><span class="line">Node ** <span class="built_in">array</span>;</span><br><span class="line">&#125;HashBucket;</span><br></pre></td></tr></table></figure><h5 id="初始化及销毁操作"><a href="#初始化及销毁操作" class="headerlink" title="初始化及销毁操作"></a>初始化及销毁操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashBucketInit</span><span class="params">(HashBucket *pHB,<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pHB-&gt;<span class="built_in">array</span> = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node*)* capacity);</span><br><span class="line">pHB-&gt;capacity = capacity;</span><br><span class="line">pHB-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++)</span><br><span class="line">&#123;</span><br><span class="line">pHB-&gt;<span class="built_in">array</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDestory</span><span class="params">(Node *first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (Node *cur = first; cur != <span class="literal">NULL</span>;cur = next)</span><br><span class="line">&#123;</span><br><span class="line">next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashBucketDestory</span><span class="params">(HashBucket *pHB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//需要先释放哈希桶 链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pHB-&gt;capacity; i++)</span><br><span class="line">&#123;</span><br><span class="line">ListDestory(pHB-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放哈希桶</span></span><br><span class="line"><span class="built_in">free</span>(pHB-&gt;<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">HashFind</span><span class="params">(HashBucket* pHB,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = key % pHB-&gt;capacity;</span><br><span class="line">Node *cur = pHB-&gt;<span class="built_in">array</span>[index];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashInsert</span><span class="params">(HashBucket *pHB, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"><span class="comment">//插入之前我们判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IsExtend</span><span class="params">(HashBucket *pHB)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHB-&gt;size&lt;pHB-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">HashBucket *newHB = <span class="literal">NULL</span>;</span><br><span class="line">HashBucketInit(newHB,pHB-&gt;capacity*<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pHB-&gt;capacity * <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Node *cur = pHB-&gt;<span class="built_in">array</span>[i]; cur != <span class="literal">NULL</span>;cur = cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">HashInsert(newHB,cur-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashBucketDestory(pHB);</span><br><span class="line">pHB-&gt;<span class="built_in">array</span> = newHB-&gt;<span class="built_in">array</span>;</span><br><span class="line">pHB-&gt;capacity = newHB-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和开放地址不同的是，此时的插入不需要考虑负载因子</span></span><br><span class="line"><span class="comment">//插入成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashInsert</span><span class="params">(HashBucket *pHB,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IsExtend(pHB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HashFind(pHB,key) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = key % pHB-&gt;capacity;</span><br><span class="line"></span><br><span class="line">Node *first = pHB-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">newNode-&gt;key = key;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">newNode-&gt;next = first;</span><br><span class="line">pHB-&gt;<span class="built_in">array</span>[index] = newNode;  <span class="comment">//将新插入的结点地址改为原来在这个位置结点的地址</span></span><br><span class="line">pHB-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashBucketRemove</span><span class="params">(HashBucket *pHB,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (HashFind(pHB, key) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> index = key % pHB-&gt;capacity;</span><br><span class="line"><span class="keyword">for</span> (Node *cur = pHB-&gt;<span class="built_in">array</span>[index];cur != <span class="literal">NULL</span>;cur = cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果要删除的结点是第一个结点</span></span><br><span class="line">pHB-&gt;<span class="built_in">array</span>[index] = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">pHB-&gt;size--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashBucketPrint</span><span class="params">(HashBucket *pHB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pHB-&gt;capacity;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHB-&gt;<span class="built_in">array</span>[i] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Node *cur = pHB-&gt;<span class="built_in">array</span>[i]; cur != <span class="literal">NULL</span>;cur = pre)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d --&gt; %p --&gt; %d\t"</span>,cur-&gt;key%pHB-&gt;capacity,cur,cur-&gt;key);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">pre = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试操作"><a href="#测试操作" class="headerlink" title="测试操作"></a>测试操作</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashBucketTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HashBucket hb;</span><br><span class="line">HashBucketInit(&amp;hb,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">11</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">13</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">12</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">22</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">23</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">16</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashInsert(&amp;hb, <span class="number">19</span>)==<span class="number">1</span> ? <span class="string">"插入成功"</span>:<span class="string">"插入失败"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HashBucketRemove(&amp;hb, <span class="number">19</span>) == <span class="number">0</span> ? <span class="string">"删除成功"</span> : <span class="string">"删除失败"</span>);</span><br><span class="line"></span><br><span class="line">HashBucketPrint(&amp;hb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseNum</title>
      <link href="/2018/09/13/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2018/09/13/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定一个 32 位有符号整数，将整数中的数字进行反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p><strong>注意:</strong></p><p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><strong>Java解决方案</strong><br>安照正常的思考，我们的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x!= <span class="number">0</span>) &#123;</span><br><span class="line">         </span><br><span class="line">temp = temp *<span class="number">10</span> +x%<span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt;Integer.MIN_VALUE||temp&gt;Integer.MAX_VALUE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入1245678993<br>输出了-296201875<br>细心的人就会发现，此时栈溢出了；   </p><p>原因是多乘了一次10，解决办法就是，先判断是否已经栈溢出，再进行乘以10<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x!= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp &lt;Integer.MIN_VALUE/<span class="number">10</span>||temp&gt;Integer.MAX_VALUE/<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">temp = temp *<span class="number">10</span> +x%<span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>C语言解决方案</strong><br>和java一样，先判断是否越界，再进行反转操作，这里我们需要引入头文件”limits.h”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//正数是否越界</span></span><br><span class="line"><span class="keyword">if</span> (temp &gt; <span class="number">0</span> &amp;&amp; ((temp == INT_MAX / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &gt; INT_MAX % <span class="number">10</span>) || temp &gt; INT_MAX / <span class="number">10</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负数是否越界</span></span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span> &amp;&amp; ((temp == INT_MIN / <span class="number">10</span> &amp;&amp; x % <span class="number">10</span> &lt; (<span class="keyword">unsigned</span>)INT_MIN % <span class="number">10</span>) || temp &lt; INT_MIN / <span class="number">10</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">temp = temp * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>445.AddTwoNumbers</title>
      <link href="/2018/09/12/AddTwoNumbers/"/>
      <url>/2018/09/12/AddTwoNumbers/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ListNode * <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *newNode = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">assert(newNode);</span><br><span class="line">newNode-&gt;val = data;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(ListNode **<span class="built_in">list</span>,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//if (*list == NULL)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">ListNode *newNode = CreateNode(data);</span><br><span class="line"></span><br><span class="line">newNode-&gt;next = *<span class="built_in">list</span>;</span><br><span class="line">*<span class="built_in">list</span> = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(  ListNode *list1,<span class="keyword">const</span> ListNode *list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">ListNode* l1 = list1;</span><br><span class="line">ListNode* l2 = list2;</span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">num1 = num1*<span class="number">10</span>+l1-&gt;val;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num1); <span class="comment">// 321</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l2 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">num2 = num2*<span class="number">10</span>+l2-&gt;val;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num2);  <span class="comment">// 654</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = num1 + num2;  <span class="comment">// 975</span></span><br><span class="line"></span><br><span class="line">ListNode *newNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (sum&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListInsert(&amp;newNode, sum %<span class="number">10</span>);</span><br><span class="line">sum = sum / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*int lg = 1;</span></span><br><span class="line"><span class="comment">int temp = sum;</span></span><br><span class="line"><span class="comment">while (temp &gt; 10) &#123;</span></span><br><span class="line"><span class="comment">temp = temp / 10;</span></span><br><span class="line"><span class="comment">lg *= 10;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">while (sum &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">ListInsert(&amp;newNode, sum/lg);</span></span><br><span class="line"><span class="comment">sum = sum - (sum / lg)*lg;</span></span><br><span class="line"><span class="comment">lg = lg / 10;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*while (sum&gt;9)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ListInsert(&amp;newNode,sum);</span></span><br><span class="line"><span class="comment">sum = sum % 10;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">ListInsert(&amp;newNode,sum);*/</span></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Print(sum/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,sum%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.买卖股票的最佳时机</title>
      <link href="/2018/09/12/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2018/09/12/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>C语言实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pricesSize; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j =i+<span class="number">1</span>; j &lt; pricesSize; j++)&#123;</span><br><span class="line">s = prices[j] - prices[i];</span><br><span class="line">max = (s &gt; max ? s : max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七大排序算法</title>
      <link href="/2018/09/11/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/11/%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>排序分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。<br>我们这里的八大排序就是内部排序。</p><p> <strong><em>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</em></strong></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>基本思想：</strong></p><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;<span class="built_in">array</span>[j])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;<span class="built_in">array</span>[i],&amp;<span class="built_in">array</span>[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="单向选择排序"><a href="#单向选择排序" class="headerlink" title="单向选择排序"></a>单向选择排序</h5><p><strong>基本思想：</strong></p><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。<br><strong>操作方法：</strong></p><p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</p><p>第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</p><p>以此类推…..</p><p>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，</p><p>直到整个序列按关键码有序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min])</span><br><span class="line">&#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != min)</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;<span class="built_in">array</span>[min],&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="双向选择排序"><a href="#双向选择排序" class="headerlink" title="双向选择排序"></a>双向选择排序</h5><p><strong>基本思路</strong><br>与单向选择排序一样，在从头部开始排序的同时，我们让其从末端也进行排序，当前后前后两个下标索引相遇就停止，具体代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> minSpace = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> maxSpace = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (minSpace &lt; maxSpace)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minPos = minSpace;</span><br><span class="line"><span class="keyword">int</span> maxPos = minSpace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = minSpace +<span class="number">1</span>; i &lt;= maxSpace; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[maxPos])</span><br><span class="line">&#123;</span><br><span class="line">maxPos = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[minPos])</span><br><span class="line">&#123;</span><br><span class="line">minPos = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(arr + minSpace,arr + minPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (minSpace == maxPos)</span><br><span class="line">&#123;</span><br><span class="line">maxPos = minPos;</span><br><span class="line">&#125;</span><br><span class="line">Swap(arr + maxSpace,arr + maxPos);</span><br><span class="line">minSpace++;</span><br><span class="line">maxSpace--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序:"></a>插入排序:</h4><p><strong>基本思想</strong><br>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p><p>要点：设立哨兵，作为临时存储和判断数组边界之用。<br>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp,i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[i];<span class="comment">//取出一个未排序的数</span></span><br><span class="line"><span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> ;j--) <span class="comment">//在排序序列中查找位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&lt;<span class="built_in">array</span>[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j]; <span class="comment">// 向后移动数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>] = temp;  <span class="comment">//将数据插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后的插入排序--折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, left, right, mid;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">key = <span class="built_in">array</span>[i];</span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">mid = left + (right - left);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[mid]&lt;= key)</span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = i; j&gt;left; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[left] = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d, i, j, x;</span><br><span class="line">d = size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(d&gt;=<span class="number">1</span>)  <span class="comment">//循环至增量为1时结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( i = d; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = arr[i];  <span class="comment">//获取序列中的下一个数据</span></span><br><span class="line">j = i - d;<span class="comment">// 序列中前一个数据的序号</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span>&amp;&amp;arr[j]&gt;x) <span class="comment">// 下一个数大于前一个数</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j + d] = arr[j];  <span class="comment">//将后一个数向前移动</span></span><br><span class="line">j = j - d;<span class="comment">//修改序号，继续向前比较</span></span><br><span class="line">&#125;</span><br><span class="line">arr[j + d] = x;  <span class="comment">//保存数据</span></span><br><span class="line">&#125;</span><br><span class="line">d /= <span class="number">2</span>;  <span class="comment">//缩小增量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序:树形选择排序，将带排序记录看成完整的二叉树，第一步：建立初堆，第二步：调整堆   </p><h5 id="方案一：降序排序，建立小堆"><a href="#方案一：降序排序，建立小堆" class="headerlink" title="方案一：降序排序，建立小堆"></a>方案一：降序排序，建立小堆</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步：调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调整为小根堆，从小到大</span></span><br><span class="line"><span class="keyword">int</span> rc = arr[s];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * s; j &lt;= n; j *= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j&lt;n &amp;&amp; arr[j]&gt;arr[j + <span class="number">1</span>])<span class="comment">//判断左右子数大小</span></span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (rc &lt;= arr[j])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">arr[s] = arr[j];</span><br><span class="line">s = j;</span><br><span class="line">&#125;</span><br><span class="line">arr[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：建初堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//小根堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">HeapAdjust(arr, i, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CreatHeap(arr, n);<span class="comment">//第一步，建立初堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = arr[<span class="number">1</span>];<span class="comment">//堆顶与最后一个元素互换</span></span><br><span class="line">arr[<span class="number">1</span>] = arr[i];</span><br><span class="line">arr[i] = x;</span><br><span class="line">HeapAdjust(arr, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案二：升序排序，建立大堆"><a href="#方案二：升序排序，建立大堆" class="headerlink" title="方案二：升序排序，建立大堆"></a>方案二：升序排序，建立大堆</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size, <span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>right = <span class="number">0</span>;;</span><br><span class="line"><span class="keyword">int</span> maxChild = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">left = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">right = <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line"><span class="comment">//判断左孩子是否越界</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断左右孩子谁是最大的</span></span><br><span class="line">maxChild = left;   <span class="comment">//假设是左孩子</span></span><br><span class="line"><span class="keyword">if</span> (right &lt;size &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">&#123;</span><br><span class="line">maxChild = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断最大的是不是在根处，不是的话进行交换</span></span><br><span class="line"><span class="keyword">if</span> (arr[root] &gt;= arr[maxChild])</span><br><span class="line">&#123;  <span class="comment">//判断是否满足大堆性质</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;arr[root],&amp;arr[maxChild]);</span><br><span class="line"></span><br><span class="line">root = maxChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立初堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">AdjustDown(arr, size, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;arr[<span class="number">0</span>],&amp;arr[size-j<span class="number">-1</span>]);</span><br><span class="line">AdjustDown(arr,size-j<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>思路：利用递归的方法递归划分一个无序数组，直到每个数组只有一个元素时，对相邻的两个数组进行归并。</p><h5 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：合并两个有序数组为一个数组</span></span><br><span class="line"><span class="keyword">void</span> _MergeArray(<span class="keyword">int</span> arr[], <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="keyword">int</span>* tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur1 = begin;</span><br><span class="line"><span class="keyword">int</span> cur2 = mid;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt; mid &amp;&amp; cur2 &lt; end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur1] &lt; arr[cur2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[index] = arr[cur1];</span><br><span class="line">index++;</span><br><span class="line">cur1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[index] = arr[cur2];</span><br><span class="line">index++;</span><br><span class="line">cur2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当cur1指向的数组元素都比较完后，cur2指向的数组还有元素时，将cur2指向的全部元素拷贝到tmp中</span></span><br><span class="line"><span class="keyword">while</span> (cur1 &lt; mid)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[cur1++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur2 &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">tmp[index++] = arr[cur2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后将tmp中的元素全部拷贝到原来的数组中</span></span><br><span class="line"><span class="built_in">memcpy</span>(arr + begin, tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对无序数组进行划分为只有一个元素的数组后再对数组进行归并</span></span><br><span class="line"><span class="keyword">void</span> _MergeSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> *tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (end - begin &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">_MergeSort(arr,begin,mid,tmp);</span><br><span class="line">_MergeSort(arr, mid, end, tmp);</span><br><span class="line">_MergeArray(arr,begin,mid,end,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">_MergeSort(arr, <span class="number">0</span>, size, tmp);</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *tmp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; gap &lt; size; gap*=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;i &lt; size; i +=<span class="number">2</span>* gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> begin = i;</span><br><span class="line"><span class="keyword">int</span> mid = gap + i;</span><br><span class="line"><span class="keyword">if</span> (mid &gt; size)</span><br><span class="line">&#123;</span><br><span class="line">mid = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end = i + <span class="number">2</span> * gap;</span><br><span class="line"><span class="keyword">if</span> (end &gt; size)</span><br><span class="line">&#123;</span><br><span class="line">end = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_MergeArray(arr,begin,mid,end,tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="方法一：左右指针法"><a href="#方法一：左右指针法" class="headerlink" title="方法一：左右指针法"></a>方法一：左右指针法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右指针法，选的基准值放在最右边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partion</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];</span><br><span class="line"><span class="keyword">int</span> begin = left;</span><br><span class="line"><span class="keyword">int</span> end = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp;arr[begin] &lt;= pivot)</span><br><span class="line">&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp;arr[end] &gt;= pivot)</span><br><span class="line">&#123; </span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (begin == end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(arr + begin,arr + end);</span><br><span class="line">&#125;</span><br><span class="line">Swap(arr + begin, arr + right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二：挖坑法"><a href="#方法二：挖坑法" class="headerlink" title="方法二：挖坑法"></a>方法二：挖坑法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖坑法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partion2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];</span><br><span class="line"><span class="keyword">int</span> begin = left;</span><br><span class="line"><span class="keyword">int</span> end = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; arr[begin] &lt;= pivot)</span><br><span class="line">&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin == end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[end] = arr[begin];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; arr[end] &gt;= pivot)</span><br><span class="line">&#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[begin] = arr[end];</span><br><span class="line">&#125;</span><br><span class="line">arr[begin] = pivot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法三：前后指针法"><a href="#方法三：前后指针法" class="headerlink" title="方法三：前后指针法"></a>方法三：前后指针法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后指针法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partion3</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];</span><br><span class="line"><span class="keyword">int</span> part = left;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cur = left; cur &lt;= right; cur++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur] &lt; pivot)</span><br><span class="line">&#123;</span><br><span class="line">Swap(arr + cur, arr + part);</span><br><span class="line">part++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(arr + right, arr + part);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _QuickSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];  <span class="comment">//选取最右边的一个作为基准值</span></span><br><span class="line"><span class="keyword">int</span> part = Partion3(arr,left,right);</span><br><span class="line">_QuickSort(arr,left,part<span class="number">-1</span>);</span><br><span class="line">_QuickSort(arr,part+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_QuickSort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/2018/09/10/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8A/"/>
      <url>/2018/09/10/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h3><p>和Windows操作系统软件一样，Linux也是一个操作系统软件。但是和Windows不同的是，Linux是一套开放源代码程序的、并可以自由传播的类Unix操作系统软件（Unix系统是Linux系统的前身，具备很多优秀特性）。其在设计之初，就是基于Intel x86系列CPU架构的计算机的。它是一个基于POSIX的多用户、多任务并且支持多线程和多CPU的操作系统。</p><p>Linux是由世界各地成千上万的程序员设计和开发实现的。当初开发Linux系统的目的就是建立不受任何商业化软件版权制约的、全世界都能自由使用的类Unix操作系统兼容产品。在过去的20年里，Linux系统主要应用于服务器端、嵌入式开发和个人PC桌面三大领域，其中服务器端领域是重中之重。</p><p>大型、超大型互联网企业（百度、Sina、淘宝等）都在使用Linux系统作为其服务器端的程序运行平台，全球及国内排名前十的网站使用的主流系统几乎都是Linux系统。</p><p><strong>Linux操作系统之所以如此流行，是因为它具有如下一下特点：</strong></p><ul><li>开发源代码的程序，可自由修改。</li><li>Unix系统兼容，具备Unix几乎所有优秀特性。</li><li>可自由传播，无任何商业化版权制约。</li><li>适合Intel等x86 CPU系列架构的计算机。</li></ul><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line"></span><br><span class="line">/bin 存放必要的命令</span><br><span class="line"></span><br><span class="line">/boot 存放内核以及启动所需的文件等</span><br><span class="line"></span><br><span class="line">/dev 存放设备文件</span><br><span class="line"></span><br><span class="line">/etc 存放系统的配置文件</span><br><span class="line"></span><br><span class="line">/home 用户文件的主目录，用户数据存放在其主目录中</span><br><span class="line"></span><br><span class="line">/lib 存放必要的运行库</span><br><span class="line"></span><br><span class="line">/mnt 存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下。</span><br><span class="line"></span><br><span class="line">/proc 存放存储进程和系统信息</span><br><span class="line"></span><br><span class="line">/root 超级用户的主目录</span><br><span class="line"></span><br><span class="line">/sbin 存放系统管理程序</span><br><span class="line"></span><br><span class="line">/tmp 存放临时文件的目录</span><br><span class="line"></span><br><span class="line">/usr 包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档。</span><br><span class="line"></span><br><span class="line">/var 包含系统产生的经常变化的文件</span><br></pre></td></tr></table></figure><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls: 列出目录   </span><br><span class="line">-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)   </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)   </span><br><span class="line">-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)   </span><br><span class="line"></span><br><span class="line">cd：切换目录   </span><br><span class="line">pwd：显示目前的目录   </span><br><span class="line">mkdir：创建一个新的目录   </span><br><span class="line">创建多个层次文件时，需要加  -p</span><br></pre></td></tr></table></figure><p><strong><em>示例</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory `test1/test2/test3/test4&apos;: </span><br><span class="line">No such file or directory       &lt;== 没办法直接创建此目录啊！</span><br><span class="line">[root@localhost]# mkdir -p test1/test2/test3/test4</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir：删除一个空的目录   </span><br><span class="line">cp: 复制文件或目录</span><br></pre></td></tr></table></figure><h4 id="一些常用参数"><a href="#一些常用参数" class="headerlink" title="一些常用参数"></a>一些常用参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-a：相当于 -pdr的意思，至于pdr请参考下列说明；(常用)</span><br><span class="line"> </span><br><span class="line">-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</span><br><span class="line"> </span><br><span class="line">-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</span><br><span class="line"> </span><br><span class="line">-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</span><br><span class="line"> </span><br><span class="line">-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；</span><br><span class="line"> </span><br><span class="line">-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</span><br><span class="line"> </span><br><span class="line">-r：递归持续复制，用於目录的复制行为；(常用)</span><br><span class="line"> </span><br><span class="line">-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</span><br><span class="line"> </span><br><span class="line">-u：若 destination 比 source 旧才升级 destination ！</span><br><span class="line">- rm: 移除文件或目录</span><br></pre></td></tr></table></figure><p><strong>选项与参数：</strong></p><p>-f ：就是 force的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！   </p><ul><li>mv (移动文件与目录，或修改名称)<br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)   </li></ul><h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cat  由第一行开始显示文件内容   </span><br><span class="line">tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！   </span><br><span class="line">nl   显示的时候，顺道输出行号！   </span><br><span class="line">more 一页一页的显示文件内容   </span><br><span class="line">空白键 (space)：代表向下翻一页；   </span><br><span class="line">Enter         ：代表向下翻『一行』；   </span><br><span class="line">/字串            ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；   </span><br><span class="line">:f            ：立刻显示出档名以及目前显示的行数；  </span><br><span class="line">q            ：代表立刻离开more，不再显示该文件内容。   </span><br><span class="line">b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。   </span><br><span class="line">less 与 more 类似，但是比 more 更好的是，他可以往前翻页！   </span><br><span class="line">空白键    ：向下翻动一页；   </span><br><span class="line">[pagedown]：向下翻动一页；   </span><br><span class="line">[pageup]  ：向上翻动一页；   </span><br><span class="line">/字串     ：向下搜寻『字串』的功能；   </span><br><span class="line">?字串     ：向上搜寻『字串』的功能；   </span><br><span class="line">n         ：重复前一个搜寻 (与 / 或 ? 有关！)   </span><br><span class="line">N         ：反向的重复前一个搜寻 (与 / 或 ?    有关！)   </span><br><span class="line">q         ：离开 less 这个程序；   </span><br><span class="line"></span><br><span class="line">head 只看头几行 </span><br><span class="line">head [参数]...[文件]</span><br><span class="line">tail 只看尾巴几行</span><br><span class="line">-f 循环读取</span><br><span class="line">-n&lt;行数&gt;显示行数</span><br></pre></td></tr></table></figure><h4 id="时间相关的指令"><a href="#时间相关的指令" class="headerlink" title="时间相关的指令"></a>时间相关的指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date 显示</span><br><span class="line">date 用法：date[OPTION]...[+FORMAT]</span><br></pre></td></tr></table></figure><p><strong>Cal指令</strong><br>命令格式 ： cal[参数][月份][年份]<br><strong>find指令</strong>：（非常重要） -name<br>语法：find pathname -option<br>功能：用于在文件树中查找文件，并作出相应的处理<br><strong>grep 指令</strong><br>语法：grep[选项]搜寻字符串 文件<br>功能：在文件中搜索字符串，将找到的行打印出来<br><strong>常用选项</strong>：</p><ul><li>-i:忽略大小写的不同，所以大小写视为相同</li><li>-n:顺便输出行号</li><li>-v:反向选择，亦即显示出没有’搜寻字符串’内容的那一行    </li></ul><p><strong>zip/unzip指令</strong><br>语法：zip压缩文件.zip目录或文件<br>功能：将目录或文件压缩成zip格式</p><p>常用选项：</p><ul><li>-r递归处理，将指令目录下的所有文件和子目录一并处理   </li></ul><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将test目录压缩： zip test.zip test/*</span><br><span class="line">解压到tmp目录：unzip test.zip -d /tmp</span><br></pre></td></tr></table></figure></p><p><strong>tar指令</strong><br>tar [-cxtzjvf]文件与目录…参数：</p><ul><li>-c:建立一个压缩文件的参数指令（create）；</li><li>-x:解压一个压缩文件的参数指令；</li><li>-t:查看tarfile里面的文件；</li><li>-z:是否同时具有gzip的属性，是否需要用gzip压缩</li><li>-j:是否同时具有bzip2的属性，是否需要用bzip2压缩</li><li>-v:压缩过程中显示文件</li><li>-f:使用档名，f用在最后</li><li>-C:解压到指定目录<h4 id="重要的几个热键"><a href="#重要的几个热键" class="headerlink" title="重要的几个热键"></a>重要的几个热键</h4></li></ul><p>[ctrl]-c:让当前程序停止<br>[ctrl]-d:通常代表着：键盘输入结束的意思<br>[Tab]:按键具有命令补全和档案补齐功能</p><h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><p>shutdown [选项]<br>常见选项：</p><ul><li>-h：将系统服务停止后，立即关机</li><li>-r:在将系统服务停止之后就重新启动</li><li>-t sec:-t后面加秒数，意思是过几秒关机的意思</li></ul><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h5 id="du命令：du-选项-文件"><a href="#du命令：du-选项-文件" class="headerlink" title="du命令：du [选项] 文件"></a>du命令：du [选项] 文件</h5><blockquote><p>功能该命令是显示指定文件以及下的所有文件占用系统数据块的情况，如果没有文件，默认为是当前工作目录</p></blockquote><ul><li><p>-a     显示所有文件对系统数据块的使用情况</p></li><li><p>-b     显示数据块大小时以字节为基本单位</p></li><li><p>-c     除了显示文件对系统数据块的使用情况外还显示出文件的总和</p></li><li><p>-s     只显示文件数据块总大小，不显示文件名</p></li><li><p>-x     只显示当前目录，但不统计子目录</p></li></ul><h5 id="df命令：du-选项-文件名"><a href="#df命令：du-选项-文件名" class="headerlink" title="df命令：du [选项] 文件名"></a>df命令：du [选项] 文件名</h5><blockquote><p>功能该命令与du命令相似，只不过是df计算的是当前文件所以数据快的使用情况（包括前不久删除的文件），而du只是计算当前存在的所有文件的数据快的使用情况</p></blockquote><ul><li><p>-a     递归显示各文件及其子目录的数据块利用</p></li><li><p>-h     方便阅读时显示</p></li><li><p>-H     和-h一样，只不过1k = 1000;而不是1024</p></li><li><p>-i     显示inode信息</p></li><li><p>-k     区块为1024字节</p></li><li><p>-T     文件系统类型</p></li></ul><h6 id="top命令"><a href="#top命令" class="headerlink" title="top命令:"></a>top命令:</h6><blockquote><p>功能：相当于windows下的资源管理器，可以查看当前CPU的使用情况，各进程的状况</p></blockquote><ul><li>-b     批处理</li></ul><ul><li>-I     忽略过失</li></ul><ul><li><p>-c     显示完整的治命令</p></li><li><p>-s     保密模式</p></li></ul><h5 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h5><blockquote><p>功能:显示所有内存利用率。包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统使用的缓冲区等。</p></blockquote><ul><li><p>-b     以bype为单位显示</p></li><li><p>-k     以KB为单位显示</p></li><li><p>-m     以MB为单位显示</p></li><li><p>-o     不显示缓冲区</p></li><li><p>-t     显示内存总和列</p></li></ul><h5 id="pstack命令"><a href="#pstack命令" class="headerlink" title="pstack命令"></a>pstack命令</h5><blockquote><p> 功能:进程跟踪</p><h5 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h5><p>功能:切换用户(由root用户向普通用户切换时不需要密码，由普通用户向root用户切换时需要密码)</p></blockquote><p><strong>password命令用来修改用户命令，但需要注意，root用户可以修改任何用户的密码，但普通用户只能修改自己的密码</strong></p><h5 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h5><blockquote><p>useradd 选项 用户名</p></blockquote><p>添加新的用户账号使用useradd命令</p><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul><h5 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h5><blockquote><p> sudo命令以系统管理者的身份执行指令，也就是说，经由sudo所执行的指令就好像是root亲自执行。</p><p>使用权限：在/ etc / sudoers中有出现的使用者。</p></blockquote><ul><li>-V显示版本编号</li><li>-h会显示版本编号及指令的使用方式说明</li><li>-l显示出自己（执行sudo的使用者）的权限</li><li>-v因为sudo在第一次执行时或是在N分钟内没有执行（N预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</li><li>-k将会强迫使用者在下一次执行sudo时问密码（不论有没有超过N分钟）</li><li>-b将要执行的指令放在背景执行</li><li>-p prompt可以更改问密码的提示语，其中％u会代换为使用者的帐号名称，％h会显示主机名称</li><li>-u username / #uid不加此参数，代表要以root的身份执行指令，而加了此参数，可以以username的身份执行指令（#uid为该用户名的使用者号码）</li><li>-s执行环境变数中的SHELL所指定的shell，或是/ etc / passwd里所指定的shell</li><li>-H将环境变数中的HOME（家目录）指定为要变更身份的使用者家目录（如不加-u参数就是系统管理者root）</li><li>command要以系统管理者身份（或以-u更改为其他人）执行的指令</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表(上)</title>
      <link href="/2018/09/07/%E5%93%88%E5%B8%8C%E8%A1%A8(%E4%B8%8A)/"/>
      <url>/2018/09/07/%E5%93%88%E5%B8%8C%E8%A1%A8(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="哈希冲突的闭散列处理方式"><a href="#哈希冲突的闭散列处理方式" class="headerlink" title="哈希冲突的闭散列处理方式"></a>哈希冲突的闭散列处理方式</h3><h4 id="哈希的概念"><a href="#哈希的概念" class="headerlink" title="哈希的概念"></a>哈希的概念</h4><p>在顺序搜索以及二叉树搜索树中，元素存储的位置与元素的关键码之间没有对应的关系，因此查找一个元素时，必须要经过关键码的多次比较，搜索效率取决于搜索过程中元素的比较次数。<br>理想的搜索方法是：可以不经过任何的比较，一次直接从中找到要搜索的元素。如果构造一种存储结构，通过某种函数使得元素的存储位置与元素的关键码之间有一一映射的关系，那么在查找过程中通过该哈希函数可以直接找到该元素。当向该存储结构中：</p><p>（1）插入元素时：根据某种函数利用待插元素的关键码计算出该元素的存储位置并按照此位置进行存放。</p><p>（2）搜索元素时：根据某种函数利用待搜索元素的关键码计算出该元素应该存储的位置，在该位置取出元素与搜索元素比较，若相等时则表示搜索成功，否则搜索失败。<br><strong>该方式即为哈希（散列）方法，哈希方法中使用的某种函数称为哈希（散列）函数，构造出来的存储结构称为哈希（散列）表。</strong></p><p><strong><em>举个例子</em></strong><br>数租={1,3,5,6,8}    哈希函数：Hash(key)=key%10<br>将key值代入到哈希函数中，从而取出该key值的存储位置，此时，搜索指定元素如8时，直接利用哈希函数计算出存储位置下标，将其对应的值与要搜索的值8比较，相等时，表示找到了，否则没找到。通过上述操作可以看出，搜索的速度非常快。</p><p>但是存在这样一个问题：当向数据集合中插入元素11时，将元素11存储在哪儿？依旧利用key=11计算出Hash(11)=11%10=1，那么原本应该存储在下标为1的位置，但是此时下标为1的位置已经有存储的元素1，对于出现的这种现象我们称为哈希冲突！<br><strong>处理哈希冲突有两种常见的处理方式</strong></p><h4 id="闭散列处理哈希冲突"><a href="#闭散列处理哈希冲突" class="headerlink" title="闭散列处理哈希冲突"></a>闭散列处理哈希冲突</h4><ul><li>闭散列：也叫开放地址法，当发生哈希冲突时，如果哈希表未被装满，说明哈希表中必然还有空位置，那么就可以把key存放在表中的“下一个”空位中。那么下一个空位置如何查找呢？</li></ul><p>我们用<strong>线性探测</strong>的方式寻找下一个空位置。下面举例介绍如何线性探测寻找下一个空位置去处理哈希冲突：</p><p>设关键码集合={1,3,5,6,8,11,12}，哈希表的大小为11，哈希函数的设计用<strong>除留余数法</strong>，即哈希函数为Hash(Key)=Key%10；<br>通过计算，<br>我们将1存放在下标为1的位置，<br>      3存放在下标为3的位置，<br>      5存放在下标为5的位置，<br>            ……<br>      12存放是应存放在下标为1的位置，但是该位置已经存放了1，我们就探测1的下一位置是否为空，即2的位置存放11；    </p><h4 id="代码实现部分"><a href="#代码实现部分" class="headerlink" title="代码实现部分"></a>代码实现部分</h4><h5 id="头文件定义"><a href="#头文件定义" class="headerlink" title="头文件定义"></a>头文件定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">EXIST,</span><br><span class="line">DELETE,</span><br><span class="line">EMPTY</span><br><span class="line">&#125;State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HashFunc)</span><span class="params">(KeyType key,<span class="keyword">int</span> capacity)</span></span>;  <span class="comment">//定义函数指针，参数类型为KeyType</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashElem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line">State state;</span><br><span class="line">&#125;HashElem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HashElem *table;   </span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//数据个数</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">//容量</span></span><br><span class="line">HashFunc hashfunc; <span class="comment">//哈希函数</span></span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure><h5 id="初始化及销毁"><a href="#初始化及销毁" class="headerlink" title="初始化及销毁"></a>初始化及销毁</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化/销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashInit</span><span class="params">(HashTable *pH,HashFunc hashfunc,<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pH-&gt;table = (HashElem*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashElem)*capacity);</span><br><span class="line">assert(pH-&gt;table);</span><br><span class="line"></span><br><span class="line">pH-&gt;size = <span class="number">0</span>;</span><br><span class="line">pH-&gt;hashfunc = hashfunc;</span><br><span class="line">pH-&gt;capacity = capacity;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++)</span><br><span class="line">&#123;</span><br><span class="line">pH-&gt;table[i].state = EMPTY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashDestroy</span><span class="params">(HashTable *pH)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(pH-&gt;table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p><strong><em>插入之前，我们需要判断是否需要扩大容量，减小哈希冲突的概率</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashInsert</span><span class="params">(HashTable *pH, KeyType key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsExpand</span><span class="params">(HashTable *pH)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pH-&gt;size &lt;=  pH-&gt;capacity * <span class="number">0.8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable newHT;</span><br><span class="line">HashInit(&amp;newHT,pH-&gt;hashfunc, pH-&gt;capacity * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pH-&gt;capacity * <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pH-&gt;table[i].state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line">HashInsert(&amp;newHT, pH-&gt;table[i].key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pH-&gt;table);   <span class="comment">//释放原来的table</span></span><br><span class="line">pH-&gt;table = newHT.table; <span class="comment">//将新的table地址赋给</span></span><br><span class="line">pH-&gt;capacity = newHT.capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashInsert</span><span class="params">(HashTable *pH,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IsExpand(pH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  index = pH-&gt;hashfunc(key, pH-&gt;capacity);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pH-&gt;table[index].key == key &amp;&amp; pH-&gt;table[index].state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pH-&gt;table[index].state != EXIST)</span><br><span class="line">&#123;</span><br><span class="line">pH-&gt;table[index].key = key;</span><br><span class="line">pH-&gt;table[index].state = EXIST;</span><br><span class="line">pH-&gt;size++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index = (index + <span class="number">1</span>) % pH-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashFind</span><span class="params">(HashTable *pH,KeyType  key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = pH-&gt;hashfunc(key,pH-&gt;capacity);</span><br><span class="line"><span class="keyword">while</span> (pH-&gt;table[index].state != EMPTY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pH-&gt;table[index].key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">index = (index + <span class="number">1</span>) % pH-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashRemove</span><span class="params">(HashTable *pH,KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = pH-&gt;hashfunc(key,pH-&gt;capacity);</span><br><span class="line"><span class="keyword">while</span> (pH-&gt;table[index].state != EMPTY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pH-&gt;table[index].key == key &amp;&amp; pH-&gt;table[index].state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line">pH-&gt;table[index].state = DELETE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">index = (index + <span class="number">1</span>) % pH-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打印出key所对应的value以及状态"><a href="#打印出key所对应的value以及状态" class="headerlink" title="打印出key所对应的value以及状态"></a>打印出key所对应的value以及状态</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintKeyValue</span><span class="params">(HashTable *pH)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"index --&gt; value --&gt;state\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pH-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = pH-&gt;hashfunc(pH-&gt;table[i].key,pH-&gt;capacity);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d --&gt; %d  --&gt;%d\n"</span>,index,pH-&gt;table[index].key,pH-&gt;table[index].state);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>测试部分我就不在这里放了，有兴趣的话可以自行测试</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象之集合框架</title>
      <link href="/2018/09/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/09/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="一、集合框架的由来"><a href="#一、集合框架的由来" class="headerlink" title="一、集合框架的由来"></a>一、集合框架的由来</h3><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li><p>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p></li><li><p>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p></li><li><p>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</p></li></ul><p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管Map不是集合，但是它们完全整合在集合中。</p><h3 id="二、数组与集合的区别"><a href="#二、数组与集合的区别" class="headerlink" title="二、数组与集合的区别"></a>二、数组与集合的区别</h3><p><strong>数组的特点：</strong></p><ol><li>只能存储同一种数据类型的数据。</li><li>一旦初始化，长度固定。 </li><li>数组中的元素与元素之间的内存地址是连续的。</li></ol><blockquote><p>注意： Object类型的数组可以存储任意类型的数据。</p><p>集合：集合是存储对象数据的集合容器。</p></blockquote><p><strong>集合比数组的优势:</strong></p><ol><li>集合可以存储任意类型的对象数据，数组只能存储同一种数据类型 的数据。</li><li>集合的长度是会发生变化的，数组的长度是固定的</li></ol><h3 id="三、collection之继承体系"><a href="#三、collection之继承体系" class="headerlink" title="三、collection之继承体系"></a>三、collection之继承体系</h3><p>Collection<e>接口是所有单列集合的共同父接口，下面列出了常用的Collection子类集合及其继承关系。   </e></p><h4 id="集合框架概述"><a href="#集合框架概述" class="headerlink" title="集合框架概述"></a>集合框架概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection   </span><br><span class="line">    |-----List有序(存储顺序和取出顺序一致)，可重复</span><br><span class="line">    |----ArrayList，线程不安全，底层使用数组实现，查询快，增删慢。效率高。</span><br><span class="line">            每次容量不足时，自增长度的一半，如下源码可知</span><br><span class="line">                  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    |----LinkedList ， 线程不安全，底层使用链表实现，查询慢，增删快。效率高</span><br><span class="line"> </span><br><span class="line">    |----Vector ， 线程安全，底层使用数组实现，查询快，增删慢。效率低         每次容量不足时，默认自增长度的一倍（如果不指定增量的话），如下源码可知</span><br><span class="line">                   <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    |-----Set   元素唯一一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 <span class="keyword">null</span> 元素。</span><br><span class="line"> </span><br><span class="line">    |--HashSet 底层是由HashMap实现的，通过对象的hashCode方法与equals方法来保证插入元素的唯一性，无序(存储顺序和取出顺序不一致)。</span><br><span class="line"> </span><br><span class="line">    |--LinkedHashSet 底层数据结构由哈希表和链表组成。哈希表保证元素的唯一性，链表保证元素有序。(存储和取出是一致)</span><br><span class="line"> </span><br><span class="line">    |--TreeSet 基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 元素唯一。</span><br></pre></td></tr></table></figure><h3 id="四、Collection泛型接口"><a href="#四、Collection泛型接口" class="headerlink" title="四、Collection泛型接口"></a>四、Collection泛型接口</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function">             确保此 collection 包含指定的元素（可选操作）。    </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">   将指定collection中的所有元素都添加到此collection 中（可选操作）。    </span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             移除此 collection 中的所有元素（可选操作）。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">             如果此 collection 包含指定的元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">             如果此 collection 包含指定 collection 中的所有元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">             比较此 collection 与指定对象是否相等。 </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             返回此 collection 的哈希码值。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             如果此 collection 不包含元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function">    Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             返回在此 collection 的元素上进行迭代的迭代器。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">             从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">             移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。 </span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">             仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             返回此 collection 中的元素数。 </span></span><br><span class="line"><span class="function">    Object[] <span class="title">toArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">             返回包含此 collection 中所有元素的数组。 </span></span><br><span class="line"><span class="function">   &lt;T&gt; T[] </span></span><br><span class="line"><span class="function">    <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure><h4 id="collection方法简单示例："><a href="#collection方法简单示例：" class="headerlink" title="collection方法简单示例："></a>collection方法简单示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//集合转数组遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>));<span class="comment">//Object obj = new Student("张三",23);</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">25</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="number">26</span>));</span><br><span class="line"></span><br><span class="line">Object[] arr = coll.toArray();<span class="comment">//将集合转换成数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">Student s = (Student)arr[i];<span class="comment">//强转成Student</span></span><br><span class="line">System.out.println(s.getName() + <span class="string">","</span> + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//集合的遍历之迭代器遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c.add(<span class="string">"a"</span>);</span><br><span class="line">c.add(<span class="string">"b"</span>);</span><br><span class="line">c.add(<span class="string">"c"</span>);</span><br><span class="line">c.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">Iterator it = c.iterator();<span class="comment">//获取迭代器的引用</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//集合中的迭代方法(遍历)</span></span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、List泛型接口"><a href="#五、List泛型接口" class="headerlink" title="五、List泛型接口"></a>五、List泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;  //超级接口</span></span><br></pre></td></tr></table></figure><h4 id="方法概述："><a href="#方法概述：" class="headerlink" title="方法概述："></a>方法概述：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          向列表的尾部追加指定的元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          在列表的指定位置插入指定元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          追加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          从列表中移除所有元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          如果列表包含指定的元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          如果列表包含指定 collection 的所有元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          比较指定的对象与列表是否相等。 </span></span><br><span class="line"><span class="function"> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回列表中指定位置的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回列表的哈希码值。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          返回列表中首次出现指定元素的索引，如果列表不包含此元素，则返回 -1。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          如果列表不包含元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回以正确顺序在列表的元素上进行迭代的迭代器。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          返回列表中最后出现指定元素的索引，如果列表不包含此元素，则返回 -1。 </span></span><br><span class="line"><span class="function"> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回列表中元素的列表迭代器（以正确的顺序）。 </span></span><br><span class="line"><span class="function"> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回列表中元素的列表迭代器（以正确的顺序），从列表的指定位置开始。 </span></span><br><span class="line"><span class="function"> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          移除列表中指定位置的元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          移除列表中出现的首个指定元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          从列表中移除指定 collection 中包含的所有元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          仅在列表中保留指定 collection 中所包含的元素（可选操作）。 </span></span><br><span class="line"><span class="function"> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          用指定元素替换列表中指定位置的元素（可选操作）。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回列表中的元素数。 </span></span><br><span class="line"><span class="function"> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span></span><br><span class="line"><span class="function">          返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 </span></span><br><span class="line"><span class="function"> Object[] <span class="title">toArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回以正确顺序包含列表中的所有元素的数组。 </span></span><br><span class="line"><span class="function">&lt;T&gt; T[] </span></span><br><span class="line"><span class="function"> <span class="title">toArray</span><span class="params">(T[] a)</span> </span></span><br><span class="line"><span class="function">          返回以正确顺序包含列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span><br></pre></td></tr></table></figure><h4 id="list方法简单示例："><a href="#list方法简单示例：" class="headerlink" title="list方法简单示例："></a>list方法简单示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">25</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="number">26</span>));</span><br><span class="line"></span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Student s = (Student) iterator.next(); <span class="comment">//向下转型</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">Iterator iterator  = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发修改异常产生的原因及解决方案"><a href="#并发修改异常产生的原因及解决方案" class="headerlink" title="并发修改异常产生的原因及解决方案"></a>并发修改异常产生的原因及解决方案</h4><blockquote><p>假设有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”java”元素,具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"world"</span>);</span><br><span class="line">list.add(<span class="string">"d"</span>);</span><br><span class="line">list.add(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String str = (String)it.next();</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">"world"</span>)) &#123;</span><br><span class="line">list.add(<span class="string">"javaee"</span>);<span class="comment">//这里会抛出ConcurrentModificationException并发修改异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>运行上面代码发生ConcurrentModificationException并发修改异常，查看迭代器源代码如下。</strong><br><strong><em>产生原因：迭代器是依赖于集合而存在的，在判断成功后，集合的中新添加了元素，而迭代器却不知道，迭代器的内容不发生改变。所以就报错了，这个错叫并发修改异常。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>解决办法及代码如下：<br>迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)<br>集合遍历元素，集合修改元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ListIterator lit = list.listIterator();<span class="comment">//如果想在遍历的过程中添加元素,可以用ListIterator中的add方法</span></span><br><span class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</span><br><span class="line">String str = (String)lit.next();</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">"world"</span>)) &#123;</span><br><span class="line">lit.add(<span class="string">"javaee"</span>);</span><br><span class="line"><span class="comment">//list.add("javaee");</span></span><br><span class="line">&#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解：(ListIterator)   </p><ol><li>boolean hasNext()是否有下一个</li><li>boolean hasPrevious()是否有前一个</li><li>Object next()返回下一个元素</li><li>Object previous();返回上一个元素</li></ol></blockquote><h3 id="六、ArrayList类"><a href="#六、ArrayList类" class="headerlink" title="六、ArrayList类"></a>六、ArrayList类</h3><h4 id="方法摘要："><a href="#方法摘要：" class="headerlink" title="方法摘要："></a>方法摘要：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="构造方法摘要"><a href="#构造方法摘要" class="headerlink" title="构造方法摘要"></a>构造方法摘要</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">ArrayList() </span><br><span class="line">          构造一个初始容量为 <span class="number">10</span> 的空列表。 </span><br><span class="line">ArrayList(Collection&lt;? extends E&gt; c) </span><br><span class="line">          构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 </span><br><span class="line">ArrayList(<span class="keyword">int</span> initialCapacity) </span><br><span class="line">          构造一个具有指定初始容量的空列表。 </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将指定的元素追加到此列表的尾部。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          将指定的元素插入此列表中的指定位置。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          按照指定 Collection 的迭代器所返回的元素顺序，将该 Collection 中的所有元素追加到此列表的尾部。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          从指定的位置开始，将指定 Collection 中的所有元素插入到此列表中。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          移除此列表中的所有元素。 </span></span><br><span class="line"><span class="function"> Object <span class="title">clone</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此 ArrayList 实例的浅表复制。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          如果此列表中包含指定的元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span></span><br><span class="line"><span class="function">          如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。 </span></span><br><span class="line"><span class="function"> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回此列表中指定位置上的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          搜索给定参数第一次出现的位置，使用 equals 方法进行相等性测试。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          测试此列表中是否没有元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          返回指定的对象在列表中最后一次出现的位置索引。 </span></span><br><span class="line"><span class="function"> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          移除此列表中指定位置上的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          从此列表中移除指定元素的单个实例（如果存在），此操作是可选的。 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span></span><br><span class="line"><span class="function">          移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          用指定的元素替代此列表中指定位置上的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此列表中的元素数。 </span></span><br><span class="line"><span class="function"> Object[] <span class="title">toArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回一个按照正确的顺序包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="function">&lt;T&gt; T[] </span></span><br><span class="line"><span class="function"> <span class="title">toArray</span><span class="params">(T[] a)</span> </span></span><br><span class="line"><span class="function">          返回一个按照正确的顺序包含此列表中所有元素的数组；返回数组的运行时类型就是指定数组的运行时类型。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          将此 ArrayList 实例的容量调整为列表的当前大小。 </span></span><br><span class="line"><span class="function">从类 java.util.AbstractList 继承的方法 </span></span><br><span class="line"><span class="function">equals, hashCode, iterator, listIterator, listIterator, subList </span></span><br><span class="line"><span class="function">  从类 java.util.AbstractCollection 继承的方法 </span></span><br><span class="line"><span class="function">containsAll, removeAll, retainAll, toString </span></span><br><span class="line"><span class="function">  从类 java.lang.Object 继承的方法 </span></span><br><span class="line"><span class="function">finalize, getClass, notify, notifyAll, wait, wait, wait </span></span><br><span class="line"><span class="function">  从接口 java.util.List 继承的方法 </span></span><br><span class="line"><span class="function">containsAll, equals, hashCode, iterator, listIterator, listIterator, removeAll, retainAll, subList</span></span><br></pre></td></tr></table></figure><p><strong>ArrayList示例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arr.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">23</span>));</span><br><span class="line">arr.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(arr);</span><br><span class="line"></span><br><span class="line">Iterator it = arr.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Student student = (Student) it.next();</span><br><span class="line">System.out.println(student.getName()+<span class="string">"..."</span>+student.getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arr.add(<span class="string">"a"</span>);</span><br><span class="line">arr.add(<span class="string">"b"</span>);</span><br><span class="line">arr.add(<span class="string">"c"</span>);</span><br><span class="line">arr.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(arr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="七、LinkedList类"><a href="#七、LinkedList类" class="headerlink" title="七、LinkedList类"></a>七、LinkedList类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="构造方法摘要-1"><a href="#构造方法摘要-1" class="headerlink" title="构造方法摘要"></a>构造方法摘要</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList() </span><br><span class="line">          构造一个空列表。 </span><br><span class="line">LinkedList(Collection&lt;? extends E&gt; c) </span><br><span class="line">          构造一个包含指定集合中的元素的列表，这些元素按其集合的迭代器返回的顺序排列。</span><br></pre></td></tr></table></figure><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将指定元素追加到此列表的结尾。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          在此列表中指定的位置插入指定的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          追加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          将指定集合中的所有元素从指定位置开始插入此列表。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将给定元素插入此列表的开头。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将给定元素追加到此列表的结尾。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          从此列表中移除所有元素。 </span></span><br><span class="line"><span class="function"> Object <span class="title">clone</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此 LinkedList 的浅表复制。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          如果此列表包含指定元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> E <span class="title">element</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          找到但不移除此列表的头（第一个元素）。 </span></span><br><span class="line"><span class="function"> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回此列表中指定位置处的元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">getFirst</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此列表的第一个元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">getLast</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此列表的最后一个元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          返回此列表中首次出现的指定元素的索引，如果列表中不包含此元素，则返回 -1。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          返回此列表中最后出现的指定元素的索引，如果列表中不包含此元素，则返回 -1。 </span></span><br><span class="line"><span class="function"> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将指定元素添加到此列表的末尾（最后一个元素）。 </span></span><br><span class="line"><span class="function"> E <span class="title">peek</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          找到但不移除此列表的头（第一个元素）。 </span></span><br><span class="line"><span class="function"> E <span class="title">poll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          找到并移除此列表的头（第一个元素）。 </span></span><br><span class="line"><span class="function"> E <span class="title">remove</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          找到并移除此列表的头（第一个元素）。 </span></span><br><span class="line"><span class="function"> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          移除此列表中指定位置处的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          移除此列表中首次出现的指定元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">removeFirst</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          移除并返回此列表的第一个元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">removeLast</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          移除并返回此列表的最后一个元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          将此列表中指定位置的元素替换为指定的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此列表的元素数。 </span></span><br><span class="line"><span class="function"> Object[] <span class="title">toArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          以正确顺序返回包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="function">&lt;T&gt; T[] </span></span><br><span class="line"><span class="function"> <span class="title">toArray</span><span class="params">(T[] a)</span> </span></span><br><span class="line"><span class="function">          以正确顺序返回包含此列表中所有元素的数组；返回数组的运行时类型即为指定数组的类。</span></span><br></pre></td></tr></table></figure><h3 id="八、vector"><a href="#八、vector" class="headerlink" title="八、vector"></a>八、vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="构造方法摘要-2"><a href="#构造方法摘要-2" class="headerlink" title="构造方法摘要"></a>构造方法摘要</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector() </span><br><span class="line">          构造一个空向量，使其内部数据数组的大小为 <span class="number">10</span>，其标准容量增量为零。 </span><br><span class="line">Vector(Collection&lt;? extends E&gt; c) </span><br><span class="line">          构造一个包含指定集合中的元素的向量，这些元素按其集合的迭代器返回元素的顺序排列。 </span><br><span class="line">Vector(<span class="keyword">int</span> initialCapacity) </span><br><span class="line">          使用指定的初始容量和等于零的容量增量构造一个空向量。 </span><br><span class="line">Vector(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement) </span><br><span class="line">          使用指定的初始容量和容量增量构造一个空的向量</span><br></pre></td></tr></table></figure><h4 id="特有方法摘要"><a href="#特有方法摘要" class="headerlink" title="特有方法摘要"></a>特有方法摘要</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function">          将指定元素追加到此向量的末尾。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          在此向量的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          将指定 Collection 中的所有元素追加到此向量的末尾，按照指定集合的迭代器所返回的顺序追加这些元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function">          在指定位置将指定 Collection 中的所有元素插入到此向量中。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span></span><br><span class="line"><span class="function">          将指定的组件添加到此向量的末尾，将其大小增加 1。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的当前容量。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          从此向量中移除所有元素。 </span></span><br><span class="line"><span class="function"> Object <span class="title">clone</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回向量的一个副本。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          测试指定的对象是否为此向量中的组件。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          如果此向量包含指定 Collection 中的所有元素，则返回 <span class="keyword">true</span>。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span></span><br><span class="line"><span class="function">          将此向量的组件复制到指定的数组中。 </span></span><br><span class="line"><span class="function"> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回指定索引处的组件。 </span></span><br><span class="line"><span class="function"> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的组件的枚举。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span></span><br><span class="line"><span class="function">          增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          比较指定对象与此向量的相等性。 </span></span><br><span class="line"><span class="function"> E <span class="title">firstElement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的第一个组件（位于索引 0 处的项）。 </span></span><br><span class="line"><span class="function"> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          返回向量中指定位置的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的哈希码值。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          搜索给定参数的第一个匹配项，使用 equals 方法测试相等性。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object elem, <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          搜索给定参数的第一个匹配项，从 index 处开始搜索，并使用 equals 方法测试其相等性。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          将指定对象作为此向量中的组件插入到指定的 index 处。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          测试此向量是否不包含组件。 </span></span><br><span class="line"><span class="function"> E <span class="title">lastElement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的最后一个组件。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object elem)</span> </span></span><br><span class="line"><span class="function">          返回指定的对象在此向量中最后一个匹配项的索引。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object elem, <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          向后搜索指定的对象，从指定的索引处开始搜索，并返回一个索引。 </span></span><br><span class="line"><span class="function"> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          移除此向量中指定位置的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">          移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          从此向量中移除包含在指定 Collection 中的所有元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          从此向量中移除全部组件，并将其大小设置为零。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function">          从此向量中移除变量的第一个（索引最小的）匹配项。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          删除指定索引处的组件。 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span></span><br><span class="line"><span class="function">          从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span></span><br><span class="line"><span class="function">          在此向量中仅保留包含在指定 Collection 中的元素。 </span></span><br><span class="line"><span class="function"> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function">          用指定的元素替换此向量中指定位置处的元素。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">          将此向量指定 index 处的组件设置为指定的对象。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span></span><br><span class="line"><span class="function">          设置此向量的大小。 </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量中的组件数。 </span></span><br><span class="line"><span class="function"> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span></span><br><span class="line"><span class="function">          返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。 </span></span><br><span class="line"><span class="function"> Object[] <span class="title">toArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回一个数组，包含此向量中以正确顺序存放的所有元素。 </span></span><br><span class="line"><span class="function">&lt;T&gt; T[] </span></span><br><span class="line"><span class="function"> <span class="title">toArray</span><span class="params">(T[] a)</span> </span></span><br><span class="line"><span class="function">          返回一个数组，包含此向量中以正确顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。 </span></span><br><span class="line"><span class="function"> String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。 </span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          对此向量的容量进行微调，使其等于向量的当前大小。</span></span><br><span class="line"><span class="function">```          </span></span><br><span class="line"><span class="function">#### vector 使用示例:</span></span><br><span class="line"><span class="function">```java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">v.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">23</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>, <span class="number">24</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>, <span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">Iterator it = v.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Object s = (Student) it.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">v.add(<span class="string">"a"</span>);</span><br><span class="line">v.add(<span class="string">"b"</span>);</span><br><span class="line">v.add(<span class="string">"c"</span>);</span><br><span class="line">v.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(v);</span><br><span class="line">System.out.println(v.capacity());</span><br><span class="line">System.out.println(v.size());</span><br><span class="line">System.out.println(v.contains(<span class="string">"a"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collection </tag>
            
            <tag> ArrayList </tag>
            
            <tag> Vector </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2018/08/31/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2018/08/31/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h3 id="二叉搜索树概念"><a href="#二叉搜索树概念" class="headerlink" title="二叉搜索树概念"></a>二叉搜索树概念</h3><p>二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树</p><ul><li>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值</li><li>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值</li><li>它的左右子树也分别为二叉搜索树</li></ul><h3 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h3><p><strong><em>头文件定义</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;BSTreeNode;</span><br></pre></td></tr></table></figure></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><strong>若根结点不为空</strong><br><strong>当key == 查找的key，返回true</strong><br><strong>当key &gt; 查找的key，在其左子树中查找</strong><br><strong>当key &lt; 查找的key，在其右子树中查找</strong><br><strong>否则返回false</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTreeFind</span><span class="params">(<span class="keyword">const</span> BSTreeNode *root, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == root-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span><span class="keyword">if</span> (root-&gt;key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">BSTreeFind(root-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">BSTreeFind(root-&gt;left, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找非递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTreeFind2</span><span class="params">(<span class="keyword">const</span> BSTreeNode *root,DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BSTreeNode *cur = (BSTreeNode *)root;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>在二叉搜索树中插入新元素时，必须先检测该元素是否在树中已经存在。如果已经存在，则不进行插入；否则将新元素加入到搜索停止的地方。</p><p><strong><em>插入具体过程</em></strong>   </p><ol><li>树为空，则直接插入,返回true</li><li>树不空，按二叉搜索树性质查找插入位置，插入新节点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归插入写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTreeInsert</span><span class="params">(BSTreeNode **root,DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BSTreeNode *cur = *root;</span><br><span class="line">BSTreeNode *parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先找到要插入的位置</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先判断是否已存在该元素</span></span><br><span class="line"><span class="keyword">if</span> (key == cur-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent = cur;</span><br><span class="line"><span class="keyword">if</span> (key&gt;cur-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line">BSTreeNode *node = (BSTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTreeNode));</span><br><span class="line">node-&gt;key = key;</span><br><span class="line">node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*root = node;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key&lt;parent-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归插入写法   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTreeInsert2</span><span class="params">(BSTreeNode **root, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">BSTreeNode *node = (BSTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTreeNode));</span><br><span class="line">node-&gt;key = key;</span><br><span class="line">node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">*root = node;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*root)-&gt;key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key &gt;(*root)-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BSTreeInsert2(&amp;(*root)-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BSTreeInsert2(&amp;(*root)-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>首先查找元素是否在二叉搜索树中，如果不存在，则返回, 否则要删除的结点可能分下面四种情况：</strong><br>a. 要删除的结点无孩子结点<br>b. 要删除的结点只有左孩子结点<br>c. 要删除的结点只有右孩子结点<br>d. 要删除的结点有左、右孩子结点<br>==情况1可以归类到2或者3==<br>对于上述情况，相应的删除方法如下：<br>a. 直接删除该结点<br>b. 删除该结点且使被删除节点的双亲结点指向被删除节点的左孩子结点<br>c. 删除该结点且使被删除节点的双亲结点指向被删除结点的右孩子结点<br>d. 在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被删除节点中，在来处理该结点的删除问题   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveLeftNULL</span><span class="params">(BSTreeNode *parent,BSTreeNode *cur, BSTreeNode **root,DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*root = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; parent-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveRightNULL</span><span class="params">(BSTreeNode *parent, BSTreeNode *cur, BSTreeNode **root, DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*root = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key &lt; parent-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveHasLeftAndRight</span><span class="params">(BSTreeNode *cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BSTreeNode *del = cur-&gt;left;</span><br><span class="line">BSTreeNode *delParent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (del-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">delParent = del;</span><br><span class="line">del = del-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;key = del-&gt;key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除del结点</span></span><br><span class="line"><span class="keyword">if</span> (delParent == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左孩子中最大的就是cur的左孩子</span></span><br><span class="line">cur-&gt;left = del-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">delParent-&gt;right = del-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTreeRemove</span><span class="params">(BSTreeNode **root,DataType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BSTreeNode *cur = *root;</span><br><span class="line">BSTreeNode *parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先找到要插入的位置</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先判断是否已存在该元素</span></span><br><span class="line"><span class="keyword">if</span> (key == cur-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">RemoveLeftNULL(parent,cur,root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">RemoveRightNULL(parent,cur,root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">RemoveHasLeftAndRight(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent = cur;<span class="comment">//parent记录当前找到结点</span></span><br><span class="line"><span class="keyword">if</span> (key &gt; cur-&gt;key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树应用"><a href="#二叉搜索树应用" class="headerlink" title="二叉搜索树应用"></a>二叉搜索树应用</h4><ol><li>判断一个单词是否拼写正确</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Word</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> word[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Word</span> *<span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Word</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;Word;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WordFind</span><span class="params">(Word *root,<span class="keyword">char</span> word[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> Word *cur = root;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = <span class="built_in">strncmp</span>(word, cur-&gt;word, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WordInsert</span><span class="params">(Word **root,<span class="keyword">char</span> word[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span> (*root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Word *node = (Word *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Word));</span><br><span class="line"><span class="built_in">strncpy</span>(node-&gt;word,word,<span class="number">20</span>);</span><br><span class="line">node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">*root = node;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = <span class="built_in">strncmp</span>(word, (*root)-&gt;word, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// r为0时，此时该word已存在，返回0</span></span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// r小于0，此时该word放在左子树，否则放右子树</span></span><br><span class="line"><span class="keyword">if</span> (r&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> WordInsert(&amp;(*root)-&gt;left,word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> WordInsert(&amp;(*root)-&gt;right, word);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestWord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Word *dict = <span class="literal">NULL</span>;</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Apple"</span>);</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Banana"</span>);</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Orange"</span>);</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Watermelon"</span>);</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Pinapple"</span>);</span><br><span class="line">WordInsert(&amp;dict, <span class="string">"Pear"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> word[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,word);</span><br><span class="line"><span class="keyword">if</span> (WordFind(dict,word) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"拼写正确\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"拼写错误\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模拟实现一个简单的字典</li><li>log文件中有许多异常重复的IP地址，请统计出每个异常IP出现了多少<br>次？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象之封装</title>
      <link href="/2018/08/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/"/>
      <url>/2018/08/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h4 id="封装概述："><a href="#封装概述：" class="headerlink" title="封装概述："></a>封装概述：</h4><pre><code>封装就是隐藏对象的属性和实现细节，仅对外提供访问方式</code></pre><h4 id="封装的好处："><a href="#封装的好处：" class="headerlink" title="封装的好处："></a>封装的好处：</h4><pre><code>隐藏对象属性和实现细节，提供公共访问方式提高代码的复用性提高了安全性</code></pre><h4 id="封装原则"><a href="#封装原则" class="headerlink" title="封装原则"></a>封装原则</h4><p>  将不需要对外提供的内容隐藏起来<br>  把属性隐藏，提供公共方法对其访问</p><h4 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h4><p>   (1) private 关键字 ：</p><pre><code>a：修改属性的可见性来限制对属性的访问特点：是一个修饰符，可以修饰成员变量和成员方法，被修饰的成员只能在本类中被访问</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p><pre><code>b： 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   (2) this 关键字：是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p><pre><code>特点：代表当前对象的引用</code></pre><p><strong><em>以下是一个java封装实例</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String idNum;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getIdNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> newAge)</span></span>&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String newName)</span></span>&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNum</span><span class="params">( String newId)</span></span>&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>public方法是外部类访问该类成员变量的入口。</strong></p><p>通常情况下，这些方法被称为getter和setter方法。</p><p><strong><em>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</em></strong></p><p>通过如下的例子说明Test类的变量怎样被访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunEncap</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Test test= <span class="keyword">new</span> Test();</span><br><span class="line">      test.setName(<span class="string">"James"</span>);</span><br><span class="line">      test.setAge(<span class="number">20</span>);</span><br><span class="line">      test.setIdNum(<span class="string">"12343ms"</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.print(<span class="string">"Name : "</span> + test.getName()+ </span><br><span class="line">                             <span class="string">" Age : "</span>+ test.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码编译运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name : James Age : 20</span><br></pre></td></tr></table></figure></p><p><strong><em>本人学习总结所用，如有纰漏错误之处请指正，定虚心学习改正！谢谢。</em></strong></p><p><strong>不为失败找借口，只为成功找方法！！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆</title>
      <link href="/2018/08/28/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>/2018/08/28/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><ul><li>如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元<br>素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：<br>Ki &lt;= K2<em>i+1 且 Ki&lt;= K2</em>i+2 (Ki &gt;= K2<em>i+1 且 Ki &gt;= K2</em>i+2) i = 0，1，2…，则称为小堆(或大堆)。   </li><li><p>小堆(大堆)中：任一结点的关键码均小于(大于)等于它的左右孩子的关键码，位于堆顶结点的关键码最小(最大)，从根节点到每个结点的路径上数组元素组成的序列都是递增(递减)的</p></li><li><p>堆存储在下标为0开始的数组中，因此在堆中给定下标为i的结点时：<br>(1)如果i=0，结点i是根节点，没有双亲节点；否则结点i的双亲结点为结点(i-1)/2<br>(2)如果2 <em> i + 1 &lt;= n - 1，则结点i的左孩子为结点2 </em> i + 1，否则结点i无左孩子<br>(3)如果2 <em> i + 2 &lt;= n - 1，则结点i的右孩子为结点2 </em> i + 2，否则结<br>点i无右孩子</p></li></ul><h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><p><strong><em>将二叉树调整为最小堆的原理：<br>从最后一个非叶子结点开始调整，一直到根节点为止，将每个结点及其子树调整到满足小堆的性质即可</em></strong></p><h5 id="头文件的定义"><a href="#头文件的定义" class="headerlink" title="头文件的定义"></a>头文件的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;Heap;</span><br></pre></td></tr></table></figure><h5 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapInit</span><span class="params">(Heap *pH,<span class="keyword">int</span> arr[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pH-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">pH-&gt;<span class="built_in">array</span>[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">pH-&gt;size = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆的创建"><a href="#堆的创建" class="headerlink" title="堆的创建"></a>堆的创建</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeaoAdjustDown</span><span class="params">(Heap *pH,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> parent = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当左孩子存在时</span></span><br><span class="line"><span class="keyword">int</span> left = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//判断左孩子是否越界</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= pH-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当一定有右孩子时</span></span><br><span class="line"><span class="keyword">int</span> MaxChild = left;</span><br><span class="line"><span class="keyword">if</span> (parent*<span class="number">2</span>+<span class="number">2</span>&lt;pH-&gt;size &amp;&amp; pH-&gt;<span class="built_in">array</span>[parent*<span class="number">2</span>+<span class="number">2</span>]&gt;MaxChild)</span><br><span class="line">&#123;</span><br><span class="line">MaxChild = parent * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pH-&gt;<span class="built_in">array</span>[parent]&gt;pH-&gt;<span class="built_in">array</span>[MaxChild])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = pH-&gt;<span class="built_in">array</span>[parent];</span><br><span class="line">pH-&gt;<span class="built_in">array</span>[parent] = pH-&gt;<span class="built_in">array</span>[MaxChild];</span><br><span class="line">pH-&gt;<span class="built_in">array</span>[MaxChild] = temp;</span><br><span class="line"></span><br><span class="line">parent = MaxChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapMake</span><span class="params">(Heap *pH)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (pH-&gt;size<span class="number">-2</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">HeaoAdjustDown(pH,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆的插入操作"><a href="#堆的插入操作" class="headerlink" title="堆的插入操作"></a>堆的插入操作</h5><p><strong><em>堆的插入：在已经建成的最小堆的后面插入新元素，插入之后，当树中结点不满足堆的性质时，就需要对堆进行重新调整</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapPush</span><span class="params">(Heap *pH,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pH-&gt;size &lt; MAX_SIZE);</span><br><span class="line">pH-&gt;<span class="built_in">array</span>[pH-&gt;size++] = data;</span><br><span class="line">HeapAdjustUp(pH, pH-&gt;size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="堆的插入操作-1"><a href="#堆的插入操作-1" class="headerlink" title="堆的插入操作"></a>堆的插入操作</h5><p><strong><em>堆的删除：删除时每次删除堆顶元素</em></strong><br>具体方法：将最后一个元素顶替堆顶元素，将堆中元素个数减少一个，相当于将堆中最后一个元素删掉，此时堆结构可能破坏，在向下调整使其满足堆的性质<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapPop</span><span class="params">(Heap *pH)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pH-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = pH-&gt;<span class="built_in">array</span>[pH-&gt;size - <span class="number">1</span>];</span><br><span class="line">pH-&gt;size--;</span><br><span class="line"></span><br><span class="line">HeapAdjustUp(pH, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立大堆</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = (size<span class="number">-2</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span>;  i--)</span><br><span class="line">&#123;</span><br><span class="line">ArrayAdjustDown(<span class="built_in">array</span>,size,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s = size - <span class="number">1</span> - j;</span><br><span class="line">Swap(<span class="built_in">array</span>, <span class="built_in">array</span> + s);</span><br><span class="line">ArrayAdjustDown(<span class="built_in">array</span>, size - <span class="number">1</span> - j, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找最小-大-的前K个数"><a href="#查找最小-大-的前K个数" class="headerlink" title="查找最小(大)的前K个数"></a>查找最小(大)的前K个数</h4><p><strong><em>100亿个数中找出最小的前K个数（海量数据top K问题）</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">TopK</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> size,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *heapArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(k * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">assert(heapArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">//搬前K个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">heapArray[i] = <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立堆(大堆)</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> j = (k<span class="number">-2</span>)/<span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">ArrayAdjustDown(heapArray,k,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将第K个与堆中最大元素比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt;= heapArray[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heapArray[<span class="number">0</span>] = <span class="built_in">array</span>[i];     <span class="comment">//替换堆中最大元素</span></span><br><span class="line">ArrayAdjustDown(heapArray,k,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> heapArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="测试部分"><a href="#测试部分" class="headerlink" title="测试部分"></a>测试部分</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">53</span>, <span class="number">17</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">23</span>, <span class="number">31</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Heapheap;</span><br><span class="line">HeapInit(&amp;heap, <span class="built_in">array</span>, size);</span><br><span class="line">HeapMake(&amp;heap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"建堆完成\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最小的前K个数</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ret = TopK(<span class="built_in">array</span>, sz, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,ret[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象之类以及内部类</title>
      <link href="/2018/08/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/08/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="面向对象之内部类"><a href="#面向对象之内部类" class="headerlink" title="面向对象之内部类"></a>面向对象之内部类</h3><h4 id="类及其常见修饰符"><a href="#类及其常见修饰符" class="headerlink" title="类及其常见修饰符"></a>类及其常见修饰符</h4><ul><li>A：修饰符<br>权限修饰符  private 默认的，protected，public<br>状态修饰符  static，final<br>抽象修饰符  abstract</li><li>B：类<br>权限修饰符  默认的，public<br>状态修饰符  final<br>抽象修饰符  abstract</li><li>C：成员变量<br>权限修饰符  private 默认的，protected，public<br>状态修饰符  static，final</li><li>D：构造方法<br>权限修饰符  private 默认的，protected，public</li><li>E：成员方法：<br>  权限修饰符：private，默认的，protected，public<br>  状态修饰符：static，final<br>  抽象修饰符：abstract    </li><li>F：除此以外的组合规则：<ul><li>成员变量：public static final</li><li>成员方法：<ul><li>public static </li><li>public abstract</li><li>public final<br>内部类访问特点<br>a:内部类可以直接访问外部类的成员，包括私有。<br>b:外部类要访问内部类的成员，必须创建对象。<br>外部类名.内部类名 对象名 = 外部类对象.内部类对象;<br>案例演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Outer.Inner  io = <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line">io.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="静态类及其方法访问"><a href="#静态类及其方法访问" class="headerlink" title="静态类及其方法访问"></a>静态类及其方法访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">oi.method();</span><br><span class="line">Outer.Inner2.method2();<span class="comment">//静态方法调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="私有类及其访问特点"><a href="#私有类及其访问特点" class="headerlink" title="私有类及其访问特点"></a>私有类及其访问特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outer oi = <span class="keyword">new</span> Outer();</span><br><span class="line">oi.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(num);   <span class="comment">//20</span></span><br><span class="line">System.out.println(Outer.<span class="keyword">this</span>.num);  <span class="comment">//30</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">inner.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类<br>。。。未完待续</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树基本操作下</title>
      <link href="/2018/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8B/"/>
      <url>/2018/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="二叉树进阶"><a href="#二叉树进阶" class="headerlink" title="二叉树进阶"></a>二叉树进阶</h3><h4 id="将三种递归遍历改写成非递归遍历形式"><a href="#将三种递归遍历改写成非递归遍历形式" class="headerlink" title="将三种递归遍历改写成非递归遍历形式"></a>将三种递归遍历改写成非递归遍历形式</h4><p><strong>头文件引用</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二叉树的遍历非递归、层序遍历、是否是完全二叉树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BTree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.h"</span>   <span class="comment">//递归遍历用stack完成</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Queue.h"</span>  <span class="comment">//层序遍历用queue完成</span></span></span><br></pre></td></tr></table></figure></p><p><strong>先序遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTreeNode *cur = root;</span><br><span class="line">BTreeNode *top = <span class="literal">NULL</span>;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;LeftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">cur = top-&gt;RightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>中序遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTreeNode *cur = root;</span><br><span class="line">BTreeNode *top;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">cur = cur-&gt;LeftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,top-&gt;data);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">cur = top-&gt;RightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>后序遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lastOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTreeNode *cur = root;</span><br><span class="line">BTreeNode *top,*last = <span class="literal">NULL</span>;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">cur = cur-&gt;LeftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">if</span> (top-&gt;RightChild == <span class="literal">NULL</span> || top-&gt;RightChild == last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断右子树是否遍历过</span></span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, top-&gt;data);</span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = top-&gt;RightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>层序遍历非递归算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue <span class="built_in">queue</span>;</span><br><span class="line">QueueInit(&amp;<span class="built_in">queue</span>);</span><br><span class="line">BTreeNode *pre;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>,root); <span class="comment">//存放结点地址，不是结点</span></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;<span class="built_in">queue</span>))</span><br><span class="line">&#123;</span><br><span class="line">pre = QueueFront(&amp;<span class="built_in">queue</span>);</span><br><span class="line">QueuePop(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre-&gt;LeftChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, pre-&gt;LeftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre-&gt;RightChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, pre-&gt;RightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, pre-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h4><p>1.判断一棵树是不是完全二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一棵树是不是完全二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsCompleteBTree</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue <span class="built_in">queue</span>;</span><br><span class="line">QueueInit(&amp;<span class="built_in">queue</span>);</span><br><span class="line">BTreeNode *pre;</span><br><span class="line"><span class="comment">//这里和层序遍历的区别：pre 可能是NULL</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是完全二叉树，剩下的结点应该全是NULL</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, root);</span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;<span class="built_in">queue</span>))</span><br><span class="line">&#123;</span><br><span class="line">pre = QueueFront(&amp;<span class="built_in">queue</span>);</span><br><span class="line">QueuePop(&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, pre-&gt;LeftChild);</span><br><span class="line">QueuePush(&amp;<span class="built_in">queue</span>, pre-&gt;RightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列剩余结点是否都是NULL</span></span><br><span class="line"><span class="comment">//判定队列为空 </span></span><br><span class="line"><span class="keyword">while</span> (!QueueEmpty(&amp;<span class="built_in">queue</span>))</span><br><span class="line">&#123;</span><br><span class="line">pre = QueueFront(&amp;<span class="built_in">queue</span>);</span><br><span class="line">QueuePop(&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.求二叉树的镜像</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求镜像 递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mirror(root-&gt;LeftChild);</span><br><span class="line">Mirror(root-&gt;RightChild);</span><br><span class="line"></span><br><span class="line">BTreeNode *t = root-&gt;LeftChild;</span><br><span class="line">root-&gt;LeftChild = root-&gt;RightChild;</span><br><span class="line">root-&gt;RightChild = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror2</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTreeNode *cur = root;</span><br><span class="line">BTreeNode *top, *last = <span class="literal">NULL</span>;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">cur = cur-&gt;LeftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//top的左子树已经遍历过了</span></span><br><span class="line">top = StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">if</span> (top-&gt;RightChild == <span class="literal">NULL</span> || top-&gt;RightChild == last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断右子树是否遍历过</span></span><br><span class="line"></span><br><span class="line">BTreeNode *t = top-&gt;LeftChild;</span><br><span class="line">top-&gt;LeftChild = top-&gt;RightChild;</span><br><span class="line">top-&gt;RightChild = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录这个被遍历的结点</span></span><br><span class="line">last = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = top-&gt;RightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.有前序遍历和中序遍历重建二叉树(前序遍历结果：1,2,3,4,5,6 ;中序遍历结果：4, 2, 5, 1, 6, 3)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTreeNode* <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span> preOrder[],<span class="keyword">int</span> inOrder[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootValue = preOrder[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rootIndexInOrder = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (inOrder[i] == rootValue)</span><br><span class="line">&#123;</span><br><span class="line">rootIndexInOrder = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(rootIndexInOrder != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">BTreeNode *root = CreateNode(rootValue);</span><br><span class="line">root-&gt;LeftChild = CreateTree(preOrder+<span class="number">1</span>,inOrder,rootIndexInOrder);</span><br><span class="line">root-&gt;RightChild = CreateTree(preOrder + <span class="number">1</span> + rootIndexInOrder, </span><br><span class="line">inOrder + <span class="number">1</span> + rootIndexInOrder, size - <span class="number">1</span> - rootIndexInOrder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.测试<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestBTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> pUsedSize;</span><br><span class="line"></span><br><span class="line">BTreeNode *root = CreateBTree(arr, size, &amp;pUsedSize);</span><br><span class="line"></span><br><span class="line">preOrderTraverse(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">inOrderTraverse(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">lastOrderTraverse(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">LevelTraverse(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">IsCompleteBTree(root) == <span class="number">1</span> ? <span class="built_in">printf</span>(<span class="string">"是完全二叉树\n"</span>): <span class="built_in">printf</span>(<span class="string">"是完全二叉树\n"</span>);</span><br><span class="line"></span><br><span class="line">Mirror(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树重建测试</span></span><br><span class="line"><span class="keyword">int</span> preOrder[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> inOrder[] = &#123; <span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(preOrder) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">BTreeNode * root = CreateTree(preOrder,inOrder,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树基本操作上</title>
      <link href="/2018/08/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8A/"/>
      <url>/2018/08/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的二叉树组成<br><strong>二叉树特点</strong>：</p><ul><li>每个结点最多有两棵子树，即二叉树不存在度大于2的结点</li><li>二叉树的子树有左右之分，其子树的次序不能颠倒   </li></ul><p>因此：二叉树是通过上述形式的组合或嵌套而形成   </p><h3 id="满二叉树-amp-完全二叉树"><a href="#满二叉树-amp-完全二叉树" class="headerlink" title="满二叉树&amp;完全二叉树"></a>满二叉树&amp;完全二叉树</h3><ul><li>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子节点都在同一层上</li><li>完全二叉树：如果一棵具有N个结点的二叉树的结构与满二叉树的前N个结点的结构相同，称为完全二叉树</li></ul><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有<br>(i&gt;0)个结点</li><li>若规定只有根节点的二叉树的深度为1，则深* 度为K的二叉树的最大<br>结点数是(k&gt;=0)</li><li>对任何一棵二叉树, 如果其叶结点个数为 n0, 度为2的非叶结点个数<br>为 n2,则有n0＝n2＋1</li><li>具有n个结点的完全二叉树的深度k为上取整<br>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的顺序</li><li>对所有节点从0开始编号，则对于序号为i的结点有：<br>  1.若i&gt;0，双亲序号：(i-1)/2；<br>  i=0，i为根节点编号，无双亲结点<br>  2.若2i+1<n,左孩子序号：2i+1,否则无左孩子 3.若2i+1="">n,右孩子序号：2i+1,否则无右孩子</n,左孩子序号：2i+1,否则无左孩子></li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p><strong>二叉树主要有顺序存储和链式存储结构</strong></p><ul><li>顺序存储结构<br>对于一棵完全二叉树所有结点按照层序自顶向下，同一层自左向右顺<br>序编号，就得到一个节点的顺序序列<br>1.优点：存储完全二叉树，简单省空间<br>2.缺点：存储一般二叉树尤其单支树，存储空间利用不高</li><li>链式存储<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>* _<span class="title">pLeft</span>;</span> <span class="comment">// 当前节点左孩子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>* _<span class="title">pRight</span>;</span> <span class="comment">// 当前节点右孩子</span></span><br><span class="line">DataType _data; <span class="comment">// 当前节点值域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树基本操作"><a href="#二叉树基本操作" class="headerlink" title="二叉树基本操作"></a>二叉树基本操作</h3><h4 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> *<span class="title">LeftChild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> *<span class="title">RightChild</span>;</span></span><br><span class="line">&#125; BTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeInit</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root-&gt;data = <span class="number">0</span>;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建结点</span></span><br><span class="line"><span class="function">BTreeNode * <span class="title">CreateNode</span><span class="params">(DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTreeNode *node = (BTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTreeNode));</span><br><span class="line">node-&gt;data = data;</span><br><span class="line">node-&gt;LeftChild = node-&gt;RightChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"><span class="function">BTreeNode * <span class="title">CreateBTree</span><span class="params">( <span class="keyword">int</span> arr[],<span class="keyword">int</span> size,<span class="keyword">int</span> *pUsedSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pUsedSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leftUse, rightUse;</span><br><span class="line"><span class="keyword">int</span> data = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (data == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pUsedSize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeNode *root = CreateNode(data);</span><br><span class="line"></span><br><span class="line">root-&gt;LeftChild = CreateBTree(arr + <span class="number">1</span>,size - <span class="number">1</span>,&amp;leftUse);</span><br><span class="line">root-&gt;RightChild = CreateBTree(arr + <span class="number">1</span>+leftUse, size - leftUse - <span class="number">1</span>,&amp;rightUse);</span><br><span class="line"></span><br><span class="line">*pUsedSize = leftUse + rightUse + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>遵循某种次序，遍历二叉树中的所有节点，使得每个结点被访问一次，而且仅访问一次。“访问”：即对结点施行某些操作。<br>若规定VLR分别代表：遍历根节点、遍历根节点的左子树、遍历根节点的右子树，则有：<br>前序：VLR<br>中序：LVR<br>后序：LRV<br><strong>前序遍历递归算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">PreOrderTraverse(root-&gt;LeftChild);</span><br><span class="line">PreOrderTraverse(root-&gt;RightChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>中序遍历递归算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InOrderTraverse(root-&gt;LeftChild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">InOrderTraverse(root-&gt;RightChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>后序遍历递归算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">LastOrderTraverse</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LastOrderTraverse(root-&gt;LeftChild);</span><br><span class="line">LastOrderTraverse(root-&gt;RightChild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二叉树的其他操作："><a href="#二叉树的其他操作：" class="headerlink" title="二叉树的其他操作："></a>二叉树的其他操作：</h4><p>　1. 求二叉树的高度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHight</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root ==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX(GetHight(root-&gt;LeftChild) ,GetHight(root-&gt;RightChild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　2. 求二叉树叶子结点的个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeafNum</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;LeftChild == <span class="literal">NULL</span> &amp;&amp; root-&gt;RightChild == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> GetLeafNum(root-&gt;LeftChild) + GetLeafNum(root-&gt;RightChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　3. 求二叉树结点的个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNodeNum</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">GetNodeNum(root-&gt;LeftChild);</span><br><span class="line">GetNodeNum(root-&gt;RightChild);</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNodeNum2</span><span class="params">(BTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = GetNodeNum2(root-&gt;LeftChild);</span><br><span class="line"><span class="keyword">int</span> right = GetNodeNum2(root-&gt;RightChild);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>求二叉树第K层结点的个数   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLevelKNum</span><span class="params">(BTreeNode *root,DataType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(k&gt;=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DataType left = GetLevelKNum(root-&gt;LeftChild, k<span class="number">-1</span>);</span><br><span class="line">DataType right = GetLevelKNum(root-&gt;RightChild, k<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>　5. 判断一个节点是否在一棵二叉树中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTreeNode * <span class="title">FindNode</span><span class="params">(BTreeNode *root,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;data == data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeNode *result1 = FindNode(root-&gt;LeftChild,data);</span><br><span class="line">BTreeNode *result2 = FindNode(root-&gt;LeftChild, data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result1 == <span class="literal">NULL</span> ? result1 : result2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂链表的复制</title>
      <link href="/2018/08/24/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2018/08/24/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="复制链表的复制"><a href="#复制链表的复制" class="headerlink" title="复制链表的复制"></a>复制链表的复制</h3><p>在复杂链表中，每个结点除了有一个next指针指向下一个结点之外，还有一个random指向链表中的任意结点或者NULL。<br><a id="more"></a><br>结点定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span> *<span class="title">random</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;Link_C;</span><br></pre></td></tr></table></figure></p><p>思路：（我们分三步骤）   </p><ul><li>第一步：复制结点，将新结点连接在原结点后</li><li>第二步：复制random</li><li>第三步：拆分新旧结点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link_C</span> *<span class="title">random</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;Link_C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Link_C * <span class="title">linkCreateNode</span><span class="params">(DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Link_C *node = (Link_C *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link_C));</span><br><span class="line">node-&gt;data = data;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Link_C * <span class="title">LinkCopy</span><span class="params">(Link_C *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一步，复制结点</span></span><br><span class="line">Link_C *cur = head;</span><br><span class="line">Link_C *newNode;</span><br><span class="line">Link_C *newLink;</span><br><span class="line">Link_C *pre;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">newNode = linkCreateNode(cur-&gt;data);</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newNode;</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，复制random</span></span><br><span class="line"></span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;random != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步，新旧链表拆开</span></span><br><span class="line">cur = head;</span><br><span class="line">newLink = cur-&gt;next;</span><br><span class="line"><span class="keyword">while</span> ( cur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">cur-&gt;next = pre-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为测试方便查看写了打印<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Link_C *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Link_C *node = head;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d  random(%p)-&gt;%d ] \n"</span>,</span><br><span class="line">node-&gt;data,</span><br><span class="line">node-&gt;random,</span><br><span class="line">node-&gt;random ? node-&gt;random-&gt;data:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下为测试部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">TestCopy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Link_C *n1 = linkCreateNode(<span class="number">1</span>);</span><br><span class="line">Link_C *n2 = linkCreateNode(<span class="number">2</span>);</span><br><span class="line">Link_C *n3 = linkCreateNode(<span class="number">3</span>);</span><br><span class="line">Link_C *n4 = linkCreateNode(<span class="number">4</span>);</span><br><span class="line">Link_C *n5 = linkCreateNode(<span class="number">5</span>);</span><br><span class="line">Link_C *n6 = linkCreateNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Link_C *result;</span><br><span class="line"></span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br><span class="line">n4-&gt;next = n5;</span><br><span class="line">n5-&gt;next = n6;</span><br><span class="line"></span><br><span class="line">n1-&gt;random = n3;</span><br><span class="line">n2-&gt;random = n6;</span><br><span class="line">n3-&gt;random = n3;</span><br><span class="line">n4-&gt;random = n4;</span><br><span class="line">n5-&gt;random = n2;</span><br><span class="line"></span><br><span class="line">Print(n1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n----------------\n"</span>);</span><br><span class="line">result = LinkCopy(n1);</span><br><span class="line">Print(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果就不在这里赘述了，有兴趣的伙伴可以自己尝试</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断元素出栈入栈合法性</title>
      <link href="/2018/08/23/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E5%90%88%E6%B3%95%E6%80%A7/"/>
      <url>/2018/08/23/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E5%90%88%E6%B3%95%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="判断元素入栈出栈的合法性"><a href="#判断元素入栈出栈的合法性" class="headerlink" title="判断元素入栈出栈的合法性"></a>判断元素入栈出栈的合法性</h3><p>一般来说，这种判断性的问题会出现在一些面试题目的选择题中，当然学习了栈之后，我们就要有解决这种问题的能力。<br><strong>思路：</strong> 判断元素是否相同，相同就进行下一个元素比较，当栈不为空并且栈顶元素和输出的栈元素相同，则将该元素出栈并指向输出元素的下一个，否则就将该元素进栈，并指向比较的元素的下一个 ，直到所有元素比较完<br>然后按出栈顺序进行比较，当栈不为空时，将栈顶元素与当前元素进行比较，不相同直接返回，则判断出栈元素不合法，否则将该元素出栈，并指向下一个元素；</p><p><strong>创建一个Valid.h的文件，在这里我们引入了stack.h文件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Valid</span><span class="params">(<span class="keyword">char</span> in[], <span class="keyword">char</span> out[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> io = <span class="number">0</span>;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ii &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (in[ii] == out[io])</span><br><span class="line">&#123;</span><br><span class="line">ii++;</span><br><span class="line">io++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!StackEmpty(&amp;<span class="built_in">stack</span>) &amp;&amp; StackTop(&amp;<span class="built_in">stack</span>) == out[io])</span><br><span class="line">&#123;</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">io++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>,in[ii]);</span><br><span class="line">ii++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (StackTop(&amp;<span class="built_in">stack</span>) == out[io])</span><br><span class="line">&#123;</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">io++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>接下来我们进行测试</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestValid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *in = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">char</span> *out1 = <span class="string">"decfbga"</span>;</span><br><span class="line"><span class="keyword">char</span> *out2 = <span class="string">"fegdacb"</span>;</span><br><span class="line"><span class="keyword">char</span> *out3 = <span class="string">"efdgbca"</span>;</span><br><span class="line"><span class="keyword">char</span> *out4 = <span class="string">"cdbefag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,Valid(in,out1,<span class="built_in">strlen</span>(in)) ? <span class="string">"合法顺序"</span>:<span class="string">"非法顺序"</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,Valid(in,out2,<span class="built_in">strlen</span>(in)) ? <span class="string">"合法顺序"</span>:<span class="string">"非法顺序"</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,Valid(in,out3,<span class="built_in">strlen</span>(in)) ? <span class="string">"合法顺序"</span>:<span class="string">"非法顺序"</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,Valid(in,out4,<span class="built_in">strlen</span>(in)) ? <span class="string">"合法顺序"</span>:<span class="string">"非法顺序"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">合法顺序</span><br><span class="line">非法顺序</span><br><span class="line">非法顺序</span><br><span class="line">合法顺序</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现括号匹配</title>
      <link href="/2018/08/23/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/08/23/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="栈实现括号匹配"><a href="#栈实现括号匹配" class="headerlink" title="栈实现括号匹配"></a>栈实现括号匹配</h3><p><strong>匹配思想</strong>：从左至右扫描一个字符串(或表达式)，则每个右括号将与最近遇到的那个左括号相匹配。则可以在从左至右扫描过程中把所遇到的左括号存放到堆栈中。每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。<br><strong>算法思想</strong>：设置一个栈，当读到左括号时，左括号进栈。当读到右括号时，则从栈中弹出一个元素，与读到的左括号进行匹配，若匹配成功，继续读入；否则匹配失败，返回FLASE。另外,在算法的开始和结束时,栈都应该是空的.所以匹配到最后还要判断栈是否为空,若非空,则说明匹配失败.   </p><p><strong>创建一个StackTest.h的文件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是括号匹配具体代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BracketMatch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">char</span> leftBracket;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">StackInit(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">ch = str[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">StackPush(&amp;<span class="built_in">stack</span>,(DataType)ch);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"右括号多\n"</span>);</span><br><span class="line">StackDestory(&amp;<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftBracket = (<span class="keyword">char</span>)StackTop(&amp;<span class="built_in">stack</span>);</span><br><span class="line">StackPop(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftBracket == <span class="string">'('</span> &amp;&amp; ch != <span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不匹配\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftBracket == <span class="string">'['</span> &amp;&amp; ch != <span class="string">']'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不匹配\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (leftBracket == <span class="string">'&#123;'</span> &amp;&amp; ch != <span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不匹配\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StackEmpty(&amp;<span class="built_in">stack</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"左括号多\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"匹配正常\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是Stack.h文件</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE (100)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line"></span><br><span class="line">DataType arr[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack *<span class="built_in">stack</span>,DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(<span class="built_in">stack</span>-&gt;top &lt;MAX_SIZE);</span><br><span class="line"><span class="built_in">stack</span>-&gt;arr[<span class="built_in">stack</span>-&gt;top++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DataType <span class="title">StackTop</span><span class="params">(<span class="keyword">const</span> Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;arr[<span class="built_in">stack</span>-&gt;top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stackSize</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top &gt;= MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下我们测试括号是否匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestBracket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *seq[]=&#123;</span><br><span class="line"><span class="string">"(())abc&#123;[(])&#125;"</span>,</span><br><span class="line"><span class="string">"(()))abc&#123;[]&#125;"</span>,</span><br><span class="line"><span class="string">"(()()abc&#123;[]&#125;"</span>,</span><br><span class="line"><span class="string">"(())abc&#123;[]()&#125;"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">BracketMatch(seq[i],<span class="built_in">strlen</span>(seq[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line">不匹配   </span><br><span class="line">右括号多  </span><br><span class="line">左括号多  </span><br><span class="line">匹配正常</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//以上就是括号匹配的问题，如有问题望批评指正</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建git服务器教程</title>
      <link href="/2018/07/25/git%E6%95%99%E7%A8%8B/"/>
      <url>/2018/07/25/git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="1-下载安装git"><a href="#1-下载安装git" class="headerlink" title="1.下载安装git"></a>1.下载安装git</h2><h3 id="安装依赖库和编译工具"><a href="#安装依赖库和编译工具" class="headerlink" title="安装依赖库和编译工具"></a>安装依赖库和编译工具</h3><p>为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具    </p><pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code></pre><p>安装编译工具  </p><pre><code>yum install gcc perl-ExtUtils-MakeMaker</code></pre><h3 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h3><p>选一个目录，用来放下载下来的安装包，这里将安装包放在 /usr/local/src 目录里   </p><pre><code>cd /usr/local/src    </code></pre><p>到官网找一个新版稳定的源码包下载到 /usr/local/src 文件夹里    </p><pre><code>wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz</code></pre><h3 id="解压和编译"><a href="#解压和编译" class="headerlink" title="解压和编译"></a>解压和编译</h3><p>解压下载的资源包 </p><pre><code>tar -zvxf git-2.10.0.tar.gz</code></pre><p>解压后进入git-2.10.0  </p><pre><code>cd git-2.10.0</code></pre><p>执行编译</p><pre><code>make all prefix=/usr/local/git</code></pre><p>编译完成后, 安装到 /usr/local/git 目录下   </p><pre><code>make install prefix=/usr/local/git</code></pre><h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><h3 id="将git目录加入PATH"><a href="#将git目录加入PATH" class="headerlink" title="将git目录加入PATH"></a>将git目录加入PATH</h3><p>将原来的PATH指向目录修改为现在的目录   </p><pre><code>echo &apos;export PATH=$PATH:/usr/local/git/bin&apos; &gt;&gt; /etc/bashrc</code></pre><p>生成环境变量   </p><pre><code>source /etc/bashrc</code></pre><p>此时我们查看git版本号，说明我们已经安装成功了。   </p><pre><code>git --version</code></pre><h2 id="3-创建git账号密码"><a href="#3-创建git账号密码" class="headerlink" title="3.创建git账号密码"></a>3.创建git账号密码</h2><h3 id="创建git账号"><a href="#创建git账号" class="headerlink" title="创建git账号"></a>创建git账号</h3><p>为我们刚刚搭建好的 git 创建一个账号   </p><pre><code>useradd -m gituser</code></pre><p>然后为这个账号设置密码[?]   </p><pre><code>passwd gituser</code></pre><h2 id="4-初始化git仓库并配置用户权限"><a href="#4-初始化git仓库并配置用户权限" class="headerlink" title="4.初始化git仓库并配置用户权限"></a>4.初始化git仓库并配置用户权限</h2><h3 id="创建git参考并初始化"><a href="#创建git参考并初始化" class="headerlink" title="创建git参考并初始化"></a>创建git参考并初始化</h3><p>我们创建 /data/repositories 目录用于存放 git 仓库   </p><pre><code>mkdir -p /data/repositories</code></pre><p>创建好后，初始化这个仓库   </p><pre><code>cd /data/repositories/ &amp;&amp; git init --bare test.git</code></pre><h3 id="配置用户权限"><a href="#配置用户权限" class="headerlink" title="配置用户权限"></a>配置用户权限</h3><p>给 git 仓库目录设置用户和用户组并设置权限   </p><pre><code>chown -R gituser:gituser /data/repositorieschmod 755 /data/repositories</code></pre><p>[查找 git-shell 所在目录] , 编辑 /etc/passwd 文件，将最后一行关于 gituser 的登录 shell 配置改为 如下</p><p>示例代码：/etc/passwd</p><pre><code>gituser:x:500:500::/home/gituser:/usr/local/git/bin/git-shell</code></pre><h3 id="使用搭建好的-Git-服务"><a href="#使用搭建好的-Git-服务" class="headerlink" title="使用搭建好的 Git 服务"></a>使用搭建好的 Git 服务</h3><p>克隆test repo 到本地</p><pre><code>cd ~ &amp;&amp; git clone gituser@&lt;您的 CVM IP 地址&gt;:/data/repositories/test.git</code></pre><p>恭喜，Git 服务器搭建完成, 从此以后你可以方便地将你的本地代码提交到 Git 服务器托管了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome To MyBlog</title>
      <link href="/2018/07/19/index/"/>
      <url>/2018/07/19/index/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><strong>今晚12点前向我发暑假学习计划及安排，以word形式私发给我，具体学习计划及内容如下，每人至少选择两个课程，如果有其它想法，可以写word一同发给我，暑假期间将进行不定期考察学习成果，开学将进行统一考核评优，希望各位小伙伴在放假期间也不要耽误学习哦，另外需要学习资源的可以私我</strong></p><a id="more"></a><h2 id="大一到大二："><a href="#大一到大二：" class="headerlink" title="大一到大二："></a>大一到大二：</h2><h3 id="主攻方向："><a href="#主攻方向：" class="headerlink" title="主攻方向："></a>主攻方向：</h3><p>大二必修课：数据结构  </p><p>Web前端：HTML+CSS+JavaScript  </p><p>主流语言：Java，PHP，python，</p><h2 id="大二到大三："><a href="#大二到大三：" class="headerlink" title="大二到大三："></a>大二到大三：</h2><p>大三必修课：操作系统，java，  </p><p>Linux操作系统，C++</p><h3 id="其他：hexo-GitHub-node-js个人博客搭建"><a href="#其他：hexo-GitHub-node-js个人博客搭建" class="headerlink" title="其他：hexo+GitHub+node.js个人博客搭建"></a>其他：hexo+GitHub+node.js个人博客搭建</h3><p>（学习过程中最好使用CSDN养成写博客的习惯）</p><p>不忘初心，方得始终。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
